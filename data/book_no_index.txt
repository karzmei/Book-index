Statistical Learning
with Sparsity
The Lasso and
Generalizations Statistical Learning with Sparsity
Trevor Hastie
Robert Tibshirani
Martin Wainwright
Hastie • Tibshirani • Wainwright
143 Monographs on Statistics and Applied Probability 143
To our parents:
Valerie and Patrick Hastie
Vera and Sami Tibshirani
Patricia and John Wainwright
and to our families:
Samantha, Timothy, and Lynda
Charlie, Ryan, Jess, Julie, and Cheryl
Haruko and Hana

Contents
Preface xv
1 Introduction 1
2 The Lasso for Linear Models 7
2.1 Introduction 7
2.2 The Lasso Estimator 8
2.3 Cross-Validation and Inference 13
2.4 Computation of the Lasso Solution 14
2.4.1 Single Predictor: Soft Thresholding 15
2.4.2 Multiple Predictors: Cyclic Coordinate Descent 15
2.4.3 Soft-Thresholding and Orthogonal Bases 17
2.5 Degrees of Freedom 17
2.6 Uniqueness of the Lasso Solutions 19
2.7 A Glimpse at the Theory 20
2.8 The Nonnegative Garrote 20
2.9 `q Penalties and Bayes Estimates 22
2.10 Some Perspective 23
Exercises 24
3 Generalized Linear Models 29
3.1 Introduction 29
3.2 Logistic Regression 31
3.2.1 Example: Document Classification 32
3.2.2 Algorithms 35
3.3 Multiclass Logistic Regression 36
3.3.1 Example: Handwritten Digits 37
3.3.2 Algorithms 39
3.3.3 Grouped-Lasso Multinomial 39
3.4 Log-Linear Models and the Poisson GLM 40
3.4.1 Example: Distribution Smoothing 40
3.5 Cox Proportional Hazards Models 42
3.5.1 Cross-Validation 43
3.5.2 Pre-Validation 45
3.6 Support Vector Machines 46
3.6.1 Logistic Regression with Separable Data 49
ix
x
3.7 Computational Details and glmnet 50
Bibliographic Notes 52
Exercises 53
4 Generalizations of the Lasso Penalty 55
4.1 Introduction 55
4.2 The Elastic Net 56
4.3 The Group Lasso 58
4.3.1 Computation for the Group Lasso 62
4.3.2 Sparse Group Lasso 64
4.3.3 The Overlap Group Lasso 65
4.4 Sparse Additive Models and the Group Lasso 69
4.4.1 Additive Models and Backfitting 69
4.4.2 Sparse Additive Models and Backfitting 70
4.4.3 Approaches Using Optimization and the Group Lasso 72
4.4.4 Multiple Penalization for Sparse Additive Models 74
4.5 The Fused Lasso 76
4.5.1 Fitting the Fused Lasso 77
4.5.1.1 Reparametrization 78
4.5.1.2 A Path Algorithm 79
4.5.1.3 A Dual Path Algorithm 79
4.5.1.4 Dynamic Programming for the Fused Lasso 80
4.5.2 Trend Filtering 81
4.5.3 Nearly Isotonic Regression 83
4.6 Nonconvex Penalties 84
Bibliographic Notes 86
Exercises 88
5 Optimization Methods 95
5.1 Introduction 95
5.2 Convex Optimality Conditions 95
5.2.1 Optimality for Differentiable Problems 95
5.2.2 Nondifferentiable Functions and Subgradients 98
5.3 Gradient Descent 100
5.3.1 Unconstrained Gradient Descent 101
5.3.2 Projected Gradient Methods 102
5.3.3 Proximal Gradient Methods 103
5.3.4 Accelerated Gradient Methods 107
5.4 Coordinate Descent 109
5.4.1 Separability and Coordinate Descent 110
5.4.2 Linear Regression and the Lasso 112
5.4.3 Logistic Regression and Generalized Linear Models 115
5.5 A Simulation Study 117
5.6 Least Angle Regression 118
5.7 Alternating Direction Method of Multipliers 121
xi
5.8 Minorization-Maximization Algorithms 123
5.9 Biconvexity and Alternating Minimization 124
5.10 Screening Rules 127
Bibliographic Notes 131
Appendix 132
Exercises 134
6 Statistical Inference 139
6.1 The Bayesian Lasso 139
6.2 The Bootstrap 142
6.3 Post-Selection Inference for the Lasso 147
6.3.1 The Covariance Test 147
6.3.2 A General Scheme for Post-Selection Inference 150
6.3.2.1 Fixed- Inference for the Lasso 154
6.3.2.2 The Spacing Test for LAR 156
6.3.3 What Hypothesis Is Being Tested? 157
6.3.4 Back to Forward Stepwise Regression 158
6.4 Inference via a Debiased Lasso 158
6.5 Other Proposals for Post-Selection Inference 160
Bibliographic Notes 161
Exercises 162
7 Matrix Decompositions, Approximations, and Completion 167
7.1 Introduction 167
7.2 The Singular Value Decomposition 169
7.3 Missing Data and Matrix Completion 169
7.3.1 The Netflix Movie Challenge 170
7.3.2 Matrix Completion Using Nuclear Norm 174
7.3.3 Theoretical Results for Matrix Completion 177
7.3.4 Maximum Margin Factorization and Related Methods 181
7.4 Reduced-Rank Regression 184
7.5 A General Matrix Regression Framework 185
7.6 Penalized Matrix Decomposition 187
7.7 Additive Matrix Decomposition 190
Bibliographic Notes 195
Exercises 196
8 Sparse Multivariate Methods 201
8.1 Introduction 201
8.2 Sparse Principal Components Analysis 202
8.2.1 Some Background 202
8.2.2 Sparse Principal Components 204
8.2.2.1 Sparsity from Maximum Variance 204
8.2.2.2 Methods Based on Reconstruction 206
8.2.3 Higher-Rank Solutions 207
xii
8.2.3.1 Illustrative Application of Sparse PCA 209
8.2.4 Sparse PCA via Fantope Projection 210
8.2.5 Sparse Autoencoders and Deep Learning 210
8.2.6 Some Theory for Sparse PCA 212
8.3 Sparse Canonical Correlation Analysis 213
8.3.1 Example: Netflix Movie Rating Data 215
8.4 Sparse Linear Discriminant Analysis 217
8.4.1 Normal Theory and Bayes’ Rule 217
8.4.2 Nearest Shrunken Centroids 218
8.4.3 Fisher’s Linear Discriminant Analysis 221
8.4.3.1 Example: Simulated Data with Five Classes 222
8.4.4 Optimal Scoring 225
8.4.4.1 Example: Face Silhouettes 226
8.5 Sparse Clustering 227
8.5.1 Some Background on Clustering 227
8.5.1.1 Example: Simulated Data with Six Classes 228
8.5.2 Sparse Hierarchical Clustering 228
8.5.3 Sparse K-Means Clustering 230
8.5.4 Convex Clustering 231
Bibliographic Notes 232
Exercises 234
9 Graphs and Model Selection 241
9.1 Introduction 241
9.2 Basics of Graphical Models 241
9.2.1 Factorization and Markov Properties 241
9.2.1.1 Factorization Property 242
9.2.1.2 Markov Property 243
9.2.1.3 Equivalence of Factorization and Markov
Properties 243
9.2.2 Some Examples 244
9.2.2.1 Discrete Graphical Models 244
9.2.2.2 Gaussian Graphical Models 245
9.3 Graph Selection via Penalized Likelihood 246
9.3.1 Global Likelihoods for Gaussian Models 247
9.3.2 Graphical Lasso Algorithm 248
9.3.3 Exploiting Block-Diagonal Structure 251
9.3.4 Theoretical Guarantees for the Graphical Lasso 252
9.3.5 Global Likelihood for Discrete Models 253
9.4 Graph Selection via Conditional Inference 254
9.4.1 Neighborhood-Based Likelihood for Gaussians 255
9.4.2 Neighborhood-Based Likelihood for Discrete Models 256
9.4.3 Pseudo-Likelihood for Mixed Models 259
9.5 Graphical Models with Hidden Variables 261
Bibliographic Notes 261
xiii
Exercises 263
10 Signal Approximation and Compressed Sensing 269
10.1 Introduction 269
10.2 Signals and Sparse Representations 269
10.2.1 Orthogonal Bases 269
10.2.2 Approximation in Orthogonal Bases 271
10.2.3 Reconstruction in Overcomplete Bases 274
10.3 Random Projection and Approximation 276
10.3.1 Johnson–Lindenstrauss Approximation 277
10.3.2 Compressed Sensing 278
10.4 Equivalence between `0 and `1 Recovery 280
10.4.1 Restricted Nullspace Property 281
10.4.2 Sufficient Conditions for Restricted Nullspace 282
10.4.3 Proofs 284
10.4.3.1 Proof of Theorem 10.1 284
10.4.3.2 Proof of Proposition 10.1 284
Bibliographic Notes 285
Exercises 286
11 Theoretical Results for the Lasso 289
11.1 Introduction 289
11.1.1 Types of Loss Functions 289
11.1.2 Types of Sparsity Models 290
11.2 Bounds on Lasso `2-Error 291
11.2.1 Strong Convexity in the Classical Setting 291
11.2.2 Restricted Eigenvalues for Regression 293
11.2.3 A Basic Consistency Result 294
11.3 Bounds on Prediction Error 299
11.4 Support Recovery in Linear Regression 301
11.4.1 Variable-Selection Consistency for the Lasso 301
11.4.1.1 Some Numerical Studies 303
11.4.2 Proof of Theorem 11.3 305
11.5 Beyond the Basic Lasso 310
Bibliographic Notes 311
Exercises 312
Bibliography 315
Author Index 337
Index 343

Preface
In this monograph, we have attempted to summarize the actively developing
field of statistical learning with sparsity. A sparse statistical model is one
having only a small number of nonzero parameters or weights. It represents a
classic case of “less is more”: a sparse model can be much easier to estimate
and interpret than a dense model. In this age of big data, the number of
features measured on a person or object can be large, and might be larger
than the number of observations. The sparsity assumption allows us to tackle
such problems and extract useful and reproducible patterns from big datasets.
The ideas described here represent the work of an entire community of
researchers in statistics and machine learning, and we thank everyone for
their continuing contributions to this exciting area. We particularly thank our
colleagues at Stanford, Berkeley and elsewhere; our collaborators, and our
past and current students working in this area. These include Alekh Agarwal,
Arash Amini, Francis Bach, Jacob Bien, Stephen Boyd, Andreas Buja, Emmanuel
Candes, Alexandra Chouldechova, David Donoho, John Duchi, Brad
Efron, Will Fithian, Jerome Friedman, Max G’Sell, Iain Johnstone, Michael
Jordan, Ping Li, Po-Ling Loh, Michael Lim, Jason Lee, Richard Lockhart,
Rahul Mazumder, Balasubramanian Narashimhan, Sahand Negahban, Guillaume
Obozinski, Mee-Young Park, Junyang Qian, Garvesh Raskutti, Pradeep
Ravikumar, Saharon Rosset, Prasad Santhanam, Noah Simon, Dennis Sun,
Yukai Sun, Jonathan Taylor, Ryan Tibshirani,1 Stefan Wager, Daniela Witten,
Bin Yu, Yuchen Zhang, Ji Zhou, and Hui Zou. We also thank our editor
John Kimmel for his advice and support.
Stanford University Trevor Hastie
and Robert Tibshirani
University of California, Berkeley Martin Wainwright
1Some of the bibliographic references, for example in Chapters 4 and 6, are to
Tibshirani2, R.J., rather than Tibshirani, R.; the former is Ryan Tibshirani, the latter
is Robert (son and father).
xv

Chapter 1
Introduction
“I never keep a scorecard or the batting averages. I hate statistics. What
I got to know, I keep in my head.”
This is a quote from baseball pitcher Dizzy Dean, who played in the major
leagues from 1930 to 1947.
How the world has changed in the 75 or so years since that time! Now large
quantities of data are collected and mined in nearly every area of science, entertainment,
business, and industry. Medical scientists study the genomes of
patients to choose the best treatments, to learn the underlying causes of their
disease. Online movie and book stores study customer ratings to recommend
or sell them new movies or books. Social networks mine information about
members and their friends to try to enhance their online experience. And
yes, most major league baseball teams have statisticians who collect and analyze
detailed information on batters and pitchers to help team managers and
players make better decisions.
Thus the world is awash with data. But as Rutherford D. Roger (and
others) has said:
“We are drowning in information and starving for knowledge.”
There is a crucial need to sort through this mass of information, and pare
it down to its bare essentials. For this process to be successful, we need to
hope that the world is not as complex as it might be. For example, we hope
that not all of the 30, 000 or so genes in the human body are directly involved
in the process that leads to the development of cancer. Or that the ratings
by a customer on perhaps 50 or 100 different movies are enough to give us a
good idea of their tastes. Or that the success of a left-handed pitcher against
left-handed batters will be fairly consistent for different batters.
This points to an underlying assumption of simplicity. One form of simplicity
is sparsity, the central theme of this book. Loosely speaking, a sparse
statistical model is one in which only a relatively small number of parameters
(or predictors) play an important role. In this book we study methods that
exploit sparsity to help recover the underlying signal in a set of data.
The leading example is linear regression, in which we observe N observations
of an outcome variable yi and p associated predictor variables (or
features) xi = (xi1, . . . xip)T . The goal is to predict the outcome from the
1
2 INTRODUCTION
predictors, both for actual prediction with future data and also to discover
which predictors play an important role. A linear regression model assumes
that
yi = 0 +
Xp
j=1
xijj + ei, (1.1)
where 0 and  = (1, 2, . . . p) are unknown parameters and ei is an error
term. The method of least squares provides estimates of the parameters by
minimization of the least-squares objective function
minimize
0,
XN
i=1
(yi − 0 −
Xp
j=1
xijj)2. (1.2)
Typically all of the least-squares estimates from (1.2) will be nonzero. This
will make interpretation of the final model challenging if p is large. In fact, if
p > N, the least-squares estimates are not unique. There is an infinite set of
solutions that make the objective function equal to zero, and these solutions
almost surely overfit the data as well.
Thus there is a need to constrain, or regularize the estimation process. In
the lasso or `1-regularized regression, we estimate the parameters by solving
the problem
minimize
0,
XN
i=1
(yi − 0 −
Xp
j=1
xijj)2 subject to kk1  t (1.3)
where kk1 = Pp
j=1 |j | is the `1 norm of , and t is a user-specified parameter.
We can think of t as a budget on the total `1 norm of the parameter vector,
and the lasso finds the best fit within this budget.
Why do we use the `1 norm? Why not use the `2 norm or any `q norm? It
turns out that the `1 norm is special. If the budget t is small enough, the lasso
yields sparse solution vectors, having only some coordinates that are nonzero.
This does not occur for `q norms with q > 1; for q < 1, the solutions are
sparse but the problem is not convex and this makes the minimization very
challenging computationally. The value q = 1 is the smallest value that yields
a convex problem. Convexity greatly simplifies the computation, as does the
sparsity assumption itself. They allow for scalable algorithms that can handle
problems with even millions of parameters.
Thus the advantages of sparsity are interpretation of the fitted model and
computational convenience. But a third advantage has emerged in the last
few years from some deep mathematical analyses of this area. This has been
termed the “bet on sparsity” principle:
Use a procedure that does well in sparse problems, since no procedure
does well in dense problems.
STATISTICAL LEARNING WITH SPARSITY 3
We can think of this in terms of the amount of information N/p per parameter.
If p  N and the true model is not sparse, then the number of samples N
is too small to allow for accurate estimation of the parameters. But if the true
model is sparse, so that only k < N parameters are actually nonzero in the
true underlying model, then it turns out that we can estimate the parameters
effectively, using the lasso and related methods that we discuss in this book.
This may come as somewhat of a surprise, because we are able to do this even
though we are not told which k of the p parameters are actually nonzero. Of
course we cannot do as well as we could if we had that information, but it
turns out that we can still do reasonably well.
Bladder
Breast
CNS
Colon
Kidney
Liver
Lung
Lymph
Normal
Ovary
Pancreas
Prostate
Soft
Stomach
Testis
Figure 1.1 15-class gene expression cancer data: estimated nonzero feature weights
from a lasso-regularized multinomial classifier. Shown are the 254 genes (out of 4718)
with at least one nonzero weight among the 15 classes. The genes (unlabelled) run
from top to bottom. Line segments pointing to the right indicate positive weights,
and to the left, negative weights. We see that only a handful of genes are needed to
characterize each class.
For all of these reasons, the area of sparse statistical modelling is exciting—
for data analysts, computer scientists, and theorists—and practically useful.
Figure 1.1 shows an example. The data consists of quantitative gene expression
measurements of 4718 genes on samples from 349 cancer patients. The cancers
have been categorized into 15 different types such as “Bladder,” “Breast”,
4 INTRODUCTION
“CNS,” etc. The goal is to build a classifier to predict cancer class based on
some or all of the 4718 features. We want the classifier to have a low error rate
on independent samples and would prefer that it depend only on a subset of
the genes, to aid in our understanding of the underlying biology.
For this purpose we applied a lasso-regularized multinomial classifier to
these data, as described in Chapter 3. This produces a set of 4718 weights or
coefficients for each of the 15 classes, for discriminating each class from the
rest. Because of the `1 penalty, only some of these weights may be nonzero
(depending on the choice of the regularization parameter). We used crossvalidation
to estimate the optimal choice of regularization parameter, and
display the resulting weights in Figure 1.1. Only 254 genes have at least one
nonzero weight, and these are displayed in the figure. The cross-validated
error rate for this classifier is about 10%, so the procedure correctly predicts
the class of about 90% of the samples. By comparison, a standard support
vector classifier had a slightly higher error rate (13%) using all of the features.
Using sparsity, the lasso procedure has dramatically reduced the number of
features without sacrificing accuracy. Sparsity has also brought computational
efficiency: although there are potentially 4718 × 15  70, 000 parameters to
estimate, the entire calculation for Figure 1.1 was done on a standard laptop
computer in less than a minute. For this computation we used the glmnet
procedure described in Chapters 3 and 5.
Figure 1.2 shows another example taken from an article by Cand`es and
Wakin (2008) in the field of compressed sensing. On the left is a megapixel
image. In order to reduce the amount of space needed to store the image,
we represent it in a wavelet basis, whose coefficients are shown in the middle
panel. The largest 25, 000 coefficients are then retained and the rest zeroed
out, yielding the excellent reconstruction in the right image. This all works
because of sparsity: although the image seems complex, in the wavelet basis it
is simple and hence only a relatively small number of coefficients are nonzero.
The original image can be perfectly recovered from just 96, 000 incoherent
measurements. Compressed sensing is a powerful tool for image analysis, and
is described in Chapter 10.
In this book we have tried to summarize the hot and rapidly evolving field
of sparse statistical modelling. In Chapter 2 we describe and illustrate the
lasso for linear regression, and a simple coordinate descent algorithm for its
computation. Chapter 3 covers the application of `1 penalties to generalized
linear models such as multinomial and survival models, as well as support
vector machines. Generalized penalties such as the elastic net and group lasso
are discussed in Chapter 4. Chapter 5 reviews numerical methods for optimization,
with an emphasis on first-order methods that are useful for the
large-scale problems that are discussed in this book. In Chapter 6, we discuss
methods for statistical inference for fitted (lasso) models, including the
bootstrap, Bayesian methods and some more recently developed approaches.
Sparse matrix decomposition is the topic of Chapter 7, and we apply these
methods in the context of sparse multivariate analysis in Chapter 8. GraphSTATISTICAL
LEARNING WITH SPARSITY 5
where x is the coefficient sequence of f , xi = f,ψi. It will be
convenient to express f as x (where  is the n× n matrix
ψ1, . . . ,ψn as columns). The implication of sparsity is
clear: when a signal has a sparse expansion, one can discard
the small coefficients without much perceptual loss.
Formally, consider fS(t ) obtained by keeping only the terms
corresponding to the S largest values of (xi) in the expansion
By definition, fS := xS, where here and below, xS is the
vector of coefficients (xi) with all but the largest S set to zero.
vector is sparse in a strict sense since all but a few of its
entries are zero; we will call S-sparse
objects with at most S nonzero
entries. Since  is an orthonormal
basis (or “orthobasis”), we have
fS2
= x− xS2 , and if x is
sparse or compressible in the sense
the sorted magnitudes of the (xi)
decay quickly, then x is well approximated
by xS and, therefore, the error
fS2 is small. In plain terms,
can “throw away” a large fraction
the coefficients without much loss.
Figure 1(c) shows an example where
perceptual loss is hardly noticeable
a megapixel image to its approximation
obtained by throwing away
97.5% of the coefficients.
This principle is, of course, what
underlies most modern lossy coders
such as JPEG-2000 [4] and many
μ(,) =
√
n · max
1≤k, j≤n
|ϕk,ψj|. (3)
In plain English, the coherence measures the largest correlation
between any two elements of  and ; see also [5]. If  and 
contain correlated elements, the coherence is large. Otherwise,
it is small. As for how large and how small, it follows from linear
algebra that μ(,) ∈ [1,
√
n].
Compressive sampling is mainly concerned with low coherence
pairs, and we now give examples of such pairs. In our first
example,  is the canonical or spike basis ϕk(t ) = δ(t− k) and
[FIG1] (a) Original megapixel image with pixel values in the range [0,255] and (b) its
wavelet transform coefficients (arranged in random order for enhanced visibility).
Relatively few wavelet coefficients capture most of the signal energy; many such images
are highly compressible. (c) The reconstruction obtained by zeroing out all the coefficients
in the wavelet expansion but the 25,000 largest (pixel values are thresholded to the range
[0,255]). The difference with the original picture is hardly noticeable. As we describe in
“Undersampling and Sparse Signal Recovery,” this image can be perfectly recovered from
just 96,000 incoherent measurements.
(a) (b)
−1
0 2 4 6 8 10
−0.5
0
0.5
1.5
2
Wavelet
× 104 Coefficients
1
(c)
× 105
IEEE SIGNAL PROCESSING MAGAZINE [23] MARCH 2008
Figure 1.2 (a) Original megapixel image with pixel values in the range [0, 255]
and (b) its wavelet transform coefficients (arranged in random order for enhanced
visibility). Relatively few wavelet coefficients capture most of the signal energy; many
such images are highly compressible. (c) The reconstruction obtained by zeroing out
all the coefficients in the wavelet expansion but the 25, 000 largest (pixel values are
thresholded to the range [0, 255]). The differences from the original picture are hardly
noticeable.
ical models and their selection are discussed in Chapter 9 while compressed
sensing is the topic of Chapter 10. Finally, a survey of theoretical results for
the lasso is given in Chapter 11.
We note that both supervised and unsupervised learning problems are discussed
in this book, the former in Chapters 2, 3, 4, and 10, and the latter in
Chapters 7 and 8.
Notation
We have adopted a notation to reduce mathematical clutter. Vectors are column
vectors by default; hence  2 Rp is a column vector, and its transpose
T is a row vector. All vectors are lower case and non-bold, except N-vectors
which are bold, where N is the sample size. For example xj might be the
N-vector of observed values for the jth variable, and y the response N-vector.
All matrices are bold; hence X might represent the N ×p matrix of observed
predictors, and  a p × p precision matrix. This allows us to use xi 2 Rp to
represent the vector of p features for observation i (i.e., xTi
is the ith row of
X), while xk is the kth column of X, without ambiguity.

Chapter 2
The Lasso for Linear Models
In this chapter, we introduce the lasso estimator for linear regression. We
describe the basic lasso method, and outline a simple approach for its implementation.
We relate the lasso to ridge regression, and also view it as a
Bayesian estimator.
2.1 Introduction
In the linear regression setting, we are given N samples {(xi, yi)}N
i=1, where
each xi = (xi1, . . . , xip) is a p-dimensional vector of features or predictors, and
each yi 2 R is the associated response variable. Our goal is to approximate
the response variable yi using a linear combination of the predictors
(xi) = 0 +
Xp
j=1
xijj . (2.1)
The model is parametrized by the vector of regression weights  =
(1, . . . , p) 2 Rp and an intercept (or “bias”) term 0 2 R.
The usual “least-squares” estimator for the pair (0, ) is based on minimizing
squared-error loss:
minimize
0,
8<
:
1
2N
XN
i=1
􀀀
yi − 0 −
Xp
j=1
xijj
2
9=
;. (2.2)
There are two reasons why we might consider an alternative to the leastsquares
estimate. The first reason is prediction accuracy: the least-squares
estimate often has low bias but large variance, and prediction accuracy can
sometimes be improved by shrinking the values of the regression coefficients,
or setting some coefficients to zero. By doing so, we introduce some bias but
reduce the variance of the predicted values, and hence may improve the overall
prediction accuracy (as measured in terms of the mean-squared error). The
second reason is for the purposes of interpretation. With a large number of
predictors, we often would like to identify a smaller subset of these predictors
that exhibit the strongest effects.
7
8 THE LASSO FOR LINEAR MODELS
This chapter is devoted to discussion of the lasso, a method that combines
the least-squares loss (2.2) with an `1-constraint, or bound on the sum of the
absolute values of the coefficients. Relative to the least-squares solution, this
constraint has the effect of shrinking the coefficients, and even setting some
to zero.1 In this way it provides an automatic way for doing model selection
in linear regression. Moreover, unlike some other criteria for model selection,
the resulting optimization problem is convex, and can be solved efficiently for
large problems.
2.2 The Lasso Estimator
Given a collection of N predictor-response pairs {(xi, yi)}Ni
=1, the lasso finds
the solution (b0, b) to the optimization problem
minimize
0,
8<
:
1
2N
XN
i=1
(yi − 0 −
Xp
j=1
xijj)2
9=
;
subject to
Xp
j=1 |j |  t.
(2.3)
The constraint Pp
j=1 |j |  t can be written more compactly as the `1-norm
constraint kk1  t. Furthermore, (2.3) is often represented using matrixvector
notation. Let y = (y1, . . . , yN) denote the N-vector of responses, and
X be an N × p matrix with xi 2 Rp in its ith row, then the optimization
problem (2.3) can be re-expressed as
minimize
0,
 1
2N ky − 01 − Xk22

subject to kk1  t,
(2.4)
where 1 is the vector of N ones, and k · k2 denotes the usual Euclidean norm
on vectors. The bound t is a kind of “budget”: it limits the sum of the absolute
values of the parameter estimates. Since a shrunken parameter estimate
corresponds to a more heavily-constrained model, this budget limits how well
we can fit the data. It must be specified by an external procedure such as
cross-validation, which we discuss later in the chapter.
Typically, we first standardize the predictors X so that each column is
centered ( 1
N
PN
i=1 xij = 0) and has unit variance ( 1
N
PN
i=1 x2
ij = 1). Without
1A lasso is a long rope with a noose at one end, used to catch horses and cattle. In
a figurative sense, the method “lassos” the coefficients of the model. In the original lasso
paper (Tibshirani 1996), the name “lasso” was also introduced as an acronym for “Least
Absolute Selection and Shrinkage Operator.”
Pronunciation: in the US “lasso” tends to be pronounced “lass-oh” (oh as in goat), while in
the UK “lass-oo.” In the OED (2nd edition, 1965): “lasso is pronounced l˘asoo by those who
use it, and by most English people too.”
THE LASSO ESTIMATOR 9
standardization, the lasso solutions would depend on the units (e.g., feet versus
meters) used to measure the predictors. On the other hand, we typically
would not standardize if the features were measured in the same units. For
convenience, we also assume that the outcome values yi have been centered,
meaning that 1
N
PN
i=1 yi = 0. These centering conditions are convenient, since
they mean that we can omit the intercept term 0 in the lasso optimization.
Given an optimal lasso solution b on the centered data, we can recover the
optimal solutions for the uncentered data: b is the same, and the intercept b0
is given by
b0 = ¯y −
Xp
j=1
¯xj bj ,
where ¯y and {¯xj}p1
are the original means.2 For this reason, we omit the
intercept 0 from the lasso for the remainder of this chapter.
It is often convenient to rewrite the lasso problem in the so-called Lagrangian
form
minimize
2Rp
 1
2N ky − Xk22
+ kk1

, (2.5)
for some   0. By Lagrangian duality, there is a one-to-one correspondence
between the constrained problem (2.3) and the Lagrangian form (2.5): for
each value of t in the range where the constraint kk1  t is active, there is
a corresponding value of  that yields the same solution from the Lagrangian
form (2.5). Conversely, the solution b to problem (2.5) solves the bound
problem with t = kbk1.
We note that in many descriptions of the lasso, the factor 1/2N appearing
in (2.3) and (2.5) is replaced by 1/2 or simply 1. Although this makes no
difference in (2.3), and corresponds to a simple reparametrization of  in
(2.5), this kind of standardization makes  values comparable for different
sample sizes (useful for cross-validation).
The theory of convex analysis tells us that necessary and sufficient conditions
for a solution to problem (2.5) take the form
−
1
N hxj , y − Xi + sj = 0, j = 1, . . . , p. (2.6)
Here each sj is an unknown quantity equal to sign(j) if j 6= 0 and some
value lying in [−1, 1] otherwise—that is, it is a subgradient for the absolute
value function (see Chapter 5 for details). In other words, the solutions ˆ 
to problem (2.5) are the same as solutions ( ˆ , ˆs) to (2.6). This system is a
form of the so-called Karush–Kuhn–Tucker (KKT) conditions for problem
(2.5). Expressing a problem in subgradient form can be useful for designing
2This is typically only true for linear regression with squared-error loss; it’s not true, for
example, for lasso logistic regression.
10 THE LASSO FOR LINEAR MODELS
algorithms for finding its solutions. More details are given in Exercises (2.3)
and (2.4).
As an example of the lasso, let us consider the data given in Table 2.1, taken
from Thomas (1990). The outcome is the total overall reported crime rate per
Table 2.1 Crime data: Crime rate and five predictors, for N = 50 U.S. cities.
city funding hs not-hs college college4 crime rate
1 40 74 11 31 20 478
2 32 72 11 43 18 494
3 57 70 18 16 16 643
4 31 71 11 25 19 341
5 67 72 9 29 24 773
...
...
...
...
...
50 66 67 26 18 16 940
one million residents in 50 U.S cities. There are five predictors: annual police
funding in dollars per resident, percent of people 25 years and older with four
years of high school, percent of 16- to 19-year olds not in high school and not
high school graduates, percent of 18- to 24-year olds in college, and percent
of people 25 years and older with at least four years of college. This small
example is for illustration only, but helps to demonstrate the nature of the
lasso solutions. Typically the lasso is most useful for much larger problems,
including “wide” data for which p  N.
The left panel of Figure 2.1 shows the result of applying the lasso with
the bound t varying from zero on the left, all the way to a large value on
the right, where it has no effect. The horizontal axis has been scaled so that
the maximal bound, corresponding to the least-squares estimates ˜ , is one.
We see that for much of the range of the bound, many of the estimates are
exactly zero and hence the corresponding predictor(s) would be excluded from
the model. Why does the lasso have this model selection property? It is due
to the geometry that underlies the `1 constraint kk1  t. To understand this
better, the right panel shows the estimates from ridge regression, a technique
that predates the lasso. It solves a criterion very similar to (2.3):
minimize
0,
8<
:
1
2N
XN
i=1
(yi − 0 −
Xp
j=1
xijj)2
9=
;
subject to
Xp
j=1
2
j  t2.
(2.7)
The ridge profiles in the right panel have roughly the same shape as the lasso
profiles, but are not equal to zero except at the left end. Figure 2.2 contrasts
the two constraints used in the lasso and ridge regression. The residual sum
THE LASSO ESTIMATOR 11
0.0 0.2 0.4 0.6 0.8 1.0
−5 0 5 10
Coefficients
hs
college
college4
not−hs
funding
Lasso
0.0 0.2 0.4 0.6 0.8 1.0
−5 0 5 10
Coefficients
hs
college
college4
not−hs
funding
Ridge Regression
kˆ k1/k˜ k1 kˆ k2/k˜ k2
Figure 2.1 Left: Coefficient path for the lasso, plotted versus the `1 norm of the
coefficient vector, relative to the norm of the unrestricted least-squares estimate ˜.
Right: Same for ridge regression, plotted against the relative `2 norm.
b ^
b ^
2
b . .
1
b2
b1
b
Figure 2.2 Estimation picture for the lasso (left) and ridge regression (right). The
solid blue areas are the constraint regions |1|+|2|  t and 2
1+2
2  t2, respectively,
while the red ellipses are the contours of the residual-sum-of-squares function. The
point b depicts the usual (unconstrained) least-squares estimate.
12 THE LASSO FOR LINEAR MODELS
Table 2.2 Results from analysis of the crime data. Left panel shows the least-squares
estimates, standard errors, and their ratio (Z-score). Middle and right panels show
the corresponding results for the lasso, and the least-squares estimates applied to the
subset of predictors chosen by the lasso.
LS coef SE Z Lasso SE Z LS SE Z
funding 10.98 3.08 3.6 8.84 3.55 2.5 11.29 2.90 3.9
hs -6.09 6.54 -0.9 -1.41 3.73 -0.4 -4.76 4.53 -1.1
not-hs 5.48 10.05 0.5 3.12 5.05 0.6 3.44 7.83 0.4
college 0.38 4.42 0.1 0.0 - - 0.0 - -
college4 5.50 13.75 0.4 0.0 - - 0.0 - -
of squares has elliptical contours, centered at the full least-squares estimates.
The constraint region for ridge regression is the disk 2
1 + 2
2  t2, while that
for lasso is the diamond |1|+|2|  t. Both methods find the first point where
the elliptical contours hit the constraint region. Unlike the disk, the diamond
has corners; if the solution occurs at a corner, then it has one parameter
j equal to zero. When p > 2, the diamond becomes a rhomboid, and has
many corners, flat edges, and faces; there are many more opportunities for
the estimated parameters to be zero (see Figure 4.2 on page 58.)
We use the term sparse for a model with few nonzero coefficients. Hence a
key property of the `1-constraint is its ability to yield sparse solutions. This
idea can be applied in many different statistical models, and is the central
theme of this book.
Table 2.2 shows the results of applying three fitting procedures to the
crime data. The lasso bound t was chosen by cross-validation, as described
in Section 2.3. The left panel corresponds to the full least-squares fit, while
the middle panel shows the lasso fit. On the right, we have applied leastsquares
estimation to the subset of three predictors with nonzero coefficients
in the lasso. The standard errors for the least-squares estimates come from the
usual formulas. No such simple formula exists for the lasso, so we have used
the bootstrap to obtain the estimate of standard errors in the middle panel
(see Exercise 2.6; Chapter 6 discusses some promising new approaches for
post-selection inference). Overall it appears that funding has a large effect,
probably indicating that police resources have been focused on higher crime
areas. The other predictors have small to moderate effects.
Note that the lasso sets two of the five coefficients to zero, and tends to
shrink the coefficients of the others toward zero relative to the full least-squares
estimate. In turn, the least-squares fit on the subset of the three predictors
tends to expand the lasso estimates away from zero. The nonzero estimates
from the lasso tend to be biased toward zero, so the debiasing in the right
panel can often improve the prediction error of the model. This two-stage
process is also known as the relaxed lasso (Meinshausen 2007).
CROSS-VALIDATION AND INFERENCE 13
2.3 Cross-Validation and Inference
The bound t in the lasso criterion (2.3) controls the complexity of the model;
larger values of t free up more parameters and allow the model to adapt
more closely to the training data. Conversely, smaller values of t restrict the
parameters more, leading to sparser, more interpretable models that fit the
data less closely. Forgetting about interpretability, we can ask for the value
of t that gives the most accurate model for predicting independent test data
from the same population. Such accuracy is called the generalization ability of
the model. A value of t that is too small can prevent the lasso from capturing
the main signal in the data, while too large a value can lead to overfitting.
In this latter case, the model adapts to the noise as well as the signal that is
present in the training data. In both cases, the prediction error on a test set
will be inflated. There is usually an intermediate value of t that strikes a good
balance between these two extremes, and in the process, produces a model
with some coefficients equal to zero.
In order to estimate this best value for t, we can create artificial training
and test sets by splitting up the given dataset at random, and estimating
performance on the test data, using a procedure known as cross-validation.
In more detail, we first randomly divide the full dataset into some number of
groups K > 1. Typical choices of K might be 5 or 10, and sometimes N. We
fix one group as the test set, and designate the remaining K − 1 groups as
the training set. We then apply the lasso to the training data for a range of
different t values, and we use each fitted model to predict the responses in the
test set, recording the mean-squared prediction errors for each value of t. This
process is repeated a total of K times, with each of the K groups getting the
chance to play the role of the test data, with the remaining K−1 groups used
as training data. In this way, we obtain K different estimates of the prediction
error over a range of values of t. These K estimates of prediction error are
averaged for each value of t, thereby producing a cross-validation error curve.
Figure 2.3 shows the cross-validation error curve for the crime-data example,
obtained using K = 10 splits. We plot the estimated mean-squared
prediction error versus the relative bound ˜t = kb(t)k1/k˜ k1, where the estimate
b(t) correspond to the lasso solution for bound t and ˜  is the ordinary
least-squares solution. The error bars in Figure 2.3 indicate plus and minus
one standard error in the cross-validated estimates of the prediction error. A
vertical dashed line is drawn at the position of the minimum (˜t = 0.56) while
a dotted line is drawn at the “one-standard-error rule” choice (˜t = 0.03). This
is the smallest value of t yielding a CV error no more than one standard error
above its minimum value. The number of nonzero coefficients in each model is
shown along the top. Hence the model that minimizes the CV error has three
predictors, while the one-standard-error-rule model has just one.
We note that the cross-validation process above focused on the bound
parameter t. One can just as well carry out cross-validation in the Lagrangian
14 THE LASSO FOR LINEAR MODELS
0.0 0.2 0.4 0.6 0.8 1.0
5e+04 7e+04 9e+04
Relative Bound
CV Mean−Squared Error
0 1 1 1 1 2 2 3 3 3 3 4 4 5 5
Figure 2.3 Cross-validated estimate of mean-squared prediction error, as a function
of the relative `1 bound ˜t = kb(t)k1/k ˜k1. Here b(t) is the lasso estimate corresponding
to the `1 bound t and ˜ is the ordinary least-squares solution. Included are the
location of the minimum, pointwise standard-error bands, and the “one-standarderror”
location. The standard errors are large since the sample size N is only 50.
form (2.5), focusing on the parameter . The two methods will give similar but
not identical results, since the mapping between t and  is data-dependent.
2.4 Computation of the Lasso Solution
The lasso problem is a convex program, specifically a quadratic program (QP)
with a convex constraint. As such, there are many sophisticated QP methods
for solving the lasso. However there is a particularly simple and effective
computational algorithm, that gives insight into how the lasso works. For
convenience, we rewrite the criterion in Lagrangian form:
minimize
2Rp
8<
:
1
2N
XN
i=1
(yi −
Xp
j=1
xijj)2 + 
Xp
j=1 |j |
9=
;. (2.8)
As before, we will assume that both yi and the features xij have been standardized
so that 1
N
P
i yi = 0, 1
N
P
i xij = 0, and 1
N
P
i x2
ij = 1. In this
case, the intercept term 0 can be omitted. The Lagrangian form is especially
convenient for numerical computation of the solution by a simple procedure
known as coordinate descent.
COMPUTATION OF THE LASSO SOLUTION 15
2.4.1 Single Predictor: Soft Thresholding
Let’s first consider a single predictor setting, based on samples {(zi, yi)}Ni
=1
(for convenience we have given the name zi to this single xi1). The problem
then is to solve
minimize

(
1
2N
XN
i=1
(yi − zi)2 + ||
)
. (2.9)
The standard approach to this univariate minimization problem would be to
take the gradient (first derivative) with respect to , and set it to zero. There
is a complication, however, because the absolute value function || does not
have a derivative at  = 0. However we can proceed by direct inspection of
the function (2.9), and find that
b =
8><
>:
1
N hz, yi −  if 1
N hz, yi > ,
0 if 1
N |hz, yi|  ,
1
N hz, yi +  if 1
N hz, yi < −.
(2.10)
(Exercise 2.2), which we can write succinctly as
b = S
􀀀 1
N hz, yi

. (2.11)
Here the soft-thresholding operator
S(x) = sign(x)
􀀀
|x| − 

+ (2.12)
translates its argument x toward zero by the amount , and sets it to zero
if |x|  .3 See Figure 2.4 for an illustration. Notice that for standardized
data with 1
N
P
i z2
i = 1, (2.11) is just a soft-thresholded version of the usual
least-squares estimate ˜  = 1
N hz, yi. One can also derive these results using
the notion of subgradients (Exercise 2.3).
2.4.2 Multiple Predictors: Cyclic Coordinate Descent
Using this intuition from the univariate case, we can now develop a simple
coordinatewise scheme for solving the full lasso problem (2.5). More precisely,
we repeatedly cycle through the predictors in some fixed (but arbitrary) order
(say j = 1, 2, . . . , p), where at the jth step, we update the coefficient j by
minimizing the objective function in this coordinate while holding fixed all
other coefficients {bk, k 6= j} at their current values.
Writing the objective in (2.5) as
1
2N
XN
i=1
(yi −
X
k6=j
xikk − xijj)2 + 
X
k6=j
|k| + |j |, (2.13)
3t+ denotes the positive part of t 2 R, equal to t if t > 0 and 0 otherwise.
16 THE LASSO FOR LINEAR MODELS
S(x) 
(0, 0) x
Figure 2.4 Soft thresholding function S(x) = sign(x) (|x| − )+ is shown in blue
(broken lines), along with the 45 line in black.
we see that solution for each j can be expressed succinctly in terms of the
partial residual r
(j)
i = yi −
P
k6=j xik bk, which removes from the outcome the
current fit from all but the jth predictor. In terms of this partial residual, the
jth coefficient is updated as
bj = S

1
N hxj , r(j)i

. (2.14)
Equivalently, the update can be written as
bj   S

bj + 1
N hxj , ri

, (2.15)
where ri = yi −
Pp
j=1 xij bj are the full residuals (Exercise 2.4). The overall
algorithm operates by applying this soft-thresholding update (2.14) repeatedly
in a cyclical manner, updating the coordinates of b (and hence the residual
vectors) along the way.
Why does this algorithm work? The criterion (2.5) is a convex function of
 and so has no local minima. The algorithm just described corresponds to
the method of cyclical coordinate descent, which minimizes this convex objective
along each coordinate at a time. Under relatively mild conditions (which
apply here), such coordinate-wise minimization schemes applied to a convex
function converge to a global optimum. It is important to note that some
conditions are required, because there are instances, involving nonseparable
penalty functions, in which coordinate descent schemes can become “jammed.”
Further details are in given in Chapter 5.
Note that the choice  = 0 in (2.5) delivers the solution to the ordinary
least-squares problem. From the update (2.14), we see that the algorithm
does a univariate regression of the partial residual onto each predictor, cycling
through the predictors until convergence. When the data matrix X is of full
DEGREES OF FREEDOM 17
rank, this point of convergence is the least-squares solution. However, it is not
a particularly efficient method for computing it.
In practice, one is often interested in finding the lasso solution not just for
a single fixed value of , but rather the entire path of solutions over a range
of possible  values (as in Figure 2.1). A reasonable method for doing so is to
begin with a value of  just large enough so that the only optimal solution is
the all-zeroes vector. As shown in Exercise 2.1, this value is equal to max =
maxj | 1
N hxj , yi|. Then we decrease  by a small amount and run coordinate
descent until convergence. Decreasing  again and using the previous solution
as a “warm start,” we then run coordinate descent until convergence. In this
way we can efficiently compute the solutions over a grid of  values. We refer
to this method as pathwise coordinate descent.
Coordinate descent is especially fast for the lasso because the coordinatewise
minimizers are explicitly available (Equation (2.14)), and thus an iterative
search along each coordinate is not needed. Secondly, it exploits the
sparsity of the problem: for large enough values of  most coefficients will be
zero and will not be moved from zero. In Section 5.4, we discuss computational
hedges for guessing the active set, which speed up the algorithm dramatically.
Homotopy methods are another class of techniques for solving the lasso.
They produce the entire path of solutions in a sequential fashion, starting at
zero. This path is actually piecewise linear, as can be seen in Figure 2.1 (as a
function of t or ). The least angle regression (LARS) algorithm is a homotopy
method that efficiently constructs the piecewise linear path, and is described
in Chapter 5.
2.4.3 Soft-Thresholding and Orthogonal Bases
The soft-thresholding operator plays a central role in the lasso and also in
signal denoising. To see this, notice that the coordinate minimization scheme
above takes an especially simple form if the predictors are orthogonal, meaning
that 1
N hxj , xki = 0 for each j 6= k. In this case, the update (2.14) simplifies
dramatically, since 1
N hxj , r(j)i = 1
N hxj , yi so that bj is simply the
soft-thresholded version of the univariate least-squares estimate of y regressed
against xj . Thus, in the special case of an orthogonal design, the lasso has an
explicit closed-form solution, and no iterations are required.
Wavelets are a popular form of orthogonal bases, used for smoothing and
compression of signals and images. In wavelet smoothing one represents the
data in a wavelet basis, and then denoises by soft-thresholding the wavelet
coefficients. We discuss this further in Section 2.10 and in Chapter 10.
2.5 Degrees of Freedom
Suppose we have p predictors, and fit a linear regression model using only a
subset of k of these predictors. Then if these k predictors were chosen without
18 THE LASSO FOR LINEAR MODELS
regard to the response variable, the fitting procedure “spends” k degrees of
freedom. This is a loose way of saying that the standard test statistic for testing
the hypothesis that all k coefficients are zero has a Chi-squared distribution
with k degrees of freedom (with the error variance 2 assumed to be known)
However if the k predictors were chosen using knowledge of the response
variable, for example to yield the smallest training error among all subsets of
size k, then we would expect that the fitting procedure spends more than k
degrees of freedom. We call such a fitting procedure adaptive, and clearly the
lasso is an example of one.
Similarly, a forward-stepwise procedure in which we sequentially add the
predictor that most decreases the training error is adaptive, and we would
expect that the resulting model uses more than k degrees of freedom after k
steps. For these reasons and in general, one cannot simply count as degrees
of freedom the number of nonzero coefficients in the fitted model. However, it
turns out that for the lasso, one can count degrees of freedom by the number
of nonzero coefficients, as we now describe.
First we need to define precisely what we mean by the degrees of freedom
of an adaptively fitted model. Suppose we have an additive-error model, with
yi = f(xi) + i, i = 1, . . . ,N, (2.16)
for some unknown f and with the errors i iid (0, 2). If the N sample predictions
are denoted by by, then we define
df(by) := 1
2
XN
i=1
Cov
􀀀
byi, yi

. (2.17)
The covariance here is taken over the randomness in the response variables
{yi}Ni
=1 with the predictors held fixed. Thus, the degrees of freedom
corresponds to the total amount of self-influence that each response measurement
has on its prediction. The more the model fits—that is, adapts—to the
data, the larger the degrees of freedom. In the case of a fixed linear model,
using k predictors chosen independently of the response variable, it is easy
to show that df(by) = k (Exercise 2.7). However, under adaptive fitting, it is
typically the case that the degrees of freedom is larger than k.
Somewhat miraculously, one can show that for the lasso, with a fixed
penalty parameter , the number of nonzero coefficients k is an unbiased estimate
of the degrees of freedom4 (Zou, Hastie and Tibshirani 2007, Tibshirani2
and Taylor 2012). As discussed earlier, a variable-selection method like
forward-stepwise regression uses more than k degrees of freedom after k steps.
Given the apparent similarity between forward-stepwise regression and the
lasso, how can the lasso have this simple degrees of freedom property? The
4An even stronger statement holds for the LAR path, where the degrees of freedom after
k steps is exactly k, under some conditions on X. The LAR path relates closely to the lasso,
and is described in Section 5.6.
UNIQUENESS OF THE LASSO SOLUTIONS 19
reason is that the lasso not only selects predictors (which inflates the degrees
of freedom), but also shrinks their coefficients toward zero, relative to the
usual least-squares estimates. This shrinkage turns out to be just the right
amount to bring the degrees of freedom down to k. This result is useful because
it gives us a qualitative measure of the amount of fitting that we have
done at any point along the lasso path.
In the general setting, a proof of this result is quite difficult. In the special
case of an orthogonal design, it is relatively easy to prove, using the fact
that the lasso estimates are simply soft-thresholded versions of the univariate
regression coefficients for the orthogonal design. We explore the details of this
argument in Exercise 2.8. This idea is taken one step further in Section 6.3.1
where we describe the covariance test for testing the significance of predictors
in the context of the lasso.
2.6 Uniqueness of the Lasso Solutions
We first note that the theory of convex duality can be used to show that when
the columns of X are in general position, then for  > 0 the solution to the
lasso problem (2.5) is unique. This holds even when p  N, although then the
number of nonzero coefficients in any lasso solution is at most N (Rosset, Zhu
and Hastie 2004, Tibshirani2 2013). Now when the predictor matrix X is not of
full column rank, the least squares fitted values are unique, but the parameter
estimates themselves are not. The non-full-rank case can occur when p  N
due to collinearity, and always occurs when p > N. In the latter scenario,
there are an infinite number of solutions b that yield a perfect fit with zero
training error. Now consider the lasso problem in Lagrange form (2.5) for
 > 0. As shown in Exercise 2.5, the fitted values Xb are unique. But it
turns out that the solution b may not be unique. Consider a simple example
with two predictors x1 and x2 and response y, and suppose the lasso solution
coefficients b at  are (b1, b2). If we now include a third predictor x3 = x2
into the mix, an identical copy of the second, then for any  2 [0, 1], the vector
˜ () = (b1,  · b2, (1 − ) · b2) produces an identical fit, and has `1 norm
k˜ ()k1 = kbk1. Consequently, for this model (in which we might have either
p  N or p > N), there is an infinite family of solutions.
In general, when  > 0, one can show that if the columns of the model
matrix X are in general position, then the lasso solutions are unique. To be
precise, we say the columns {xj}p
j=1 are in general position if any affine subspace
L  RN of dimension k < N contains at most k + 1 elements of the
set {±x1,±x2, . . . ± xp}, excluding antipodal pairs of points (that is, points
differing only by a sign flip). We note that the data in the example in the
previous paragraph are not in general position. If the X data are drawn from
a continuous probability distribution, then with probability one the data are
in general position and hence the lasso solutions will be unique. As a result,
non-uniqueness of the lasso solutions can only occur with discrete-valued
data, such as those arising from dummy-value coding of categorical predic20
THE LASSO FOR LINEAR MODELS
tors. These results have appeared in various forms in the literature, with a
summary given by Tibshirani2 (2013).
We note that numerical algorithms for computing solutions to the lasso will
typically yield valid solutions in the non-unique case. However, the particular
solution that they deliver can depend on the specifics of the algorithm. For
example with coordinate descent, the choice of starting values can affect the
final solution.
2.7 A Glimpse at the Theory
There is a large body of theoretical work on the behavior of the lasso. It is
largely focused on the mean-squared-error consistency of the lasso, and recovery
of the nonzero support set of the true regression parameters, sometimes
called sparsistency. For MSE consistency, if  and ˆ  are the true and lassoestimated
parameters, it can be shown that as p, n ! 1
kX( ˆ  − )k22
/N  C · kk1
p
log(p)/N (2.18)
with high probability (Greenshtein and Ritov 2004, B¨uhlmann and van de
Geer 2011, Chapter 6). Thus if kk1 = o(
p
N/ log(p)) then the lasso is
consistent for prediction. This means that the true parameter vector must
be sparse relative to the ratio N/ log(p). The result only assumes that the
design X is fixed and has no other conditions on X. Consistent recovery of
the nonzero support set requires more stringent assumptions on the level of
cross-correlation between the predictors inside and outside of the support set.
Details are given in Chapter 11.
2.8 The Nonnegative Garrote
The nonnegative garrote (Breiman 1995)5 is a two-stage procedure, with a
close relationship to the lasso.6 Given an initial estimate of the regression
coefficients ˜  2 Rp, we then solve the optimization problem
minimize
c2Rp
8<
:
XN
i=1
􀀀
yi −
Xp
j=1
cjxij ˜ j
2
9=
;
subject to c  0 and kck1  t,
(2.19)
where c  0 means the vector has nonnegative coordinates. Finally, we set
bj = ˆcj · ˜ j , j = 1, . . . , p. There is an equivalent Lagrangian form for this
procedure, using a penalty kck1 for some regularization weight   0, plus
the nonnegativity constraints.
5A garrote is a device used for execution by strangulation or by breaking the neck. It is
a Spanish word, and is alternately spelled garrotte or garotte. We are using the spelling in
the original paper of Breiman (1995).
6Breiman’s paper was the inspiration for Tibshirani’s 1996 lasso paper.
THE NONNEGATIVE GARROTE 21
In the original paper (Breiman 1995), the initial ˜  was chosen to
be the ordinary-least-squares (OLS) estimate. Of course, when p > N,
these estimates are not unique; since that time, other authors (Yuan and
Lin 2007b, Zou 2006) have shown that the nonnegative garrote has attractive
properties when we use other initial estimators such as the lasso, ridge
regression or the elastic net.
(0,0) b
Lasso
Garrote
Figure 2.5 Comparison of the shrinkage behavior of the lasso and the nonnegative
garrote for a single variable. Since their s are on different scales, we used 2 for the
lasso and 7 for the garrote to make them somewhat comparable. The garrote shrinks
smaller values of  more severely than lasso, and the opposite for larger values.
The nature of the nonnegative garrote solutions can be seen when the
columns of X are orthogonal. Assuming that t is in the range where the
equality constraint kck1 = t can be satisfied, the solutions have the explicit
form
bcj =
 
1 −

˜ 2
j
!
+
, j = 1, . . . , p, (2.20)
where  is chosen so that kˆck1 = t. Hence if the coefficient ˜ j is large, the
shrinkage factor will be close to 1 (no shrinkage), but if it is small the estimate
will be shrunk toward zero. Figure 2.5 compares the shrinkage behavior of the
lasso and nonnegative garrote. The latter exhibits the shrinkage behavior of
the nonconvex penalties (next section and Section 4.6). There is also a close
relationship between the nonnegative garrote and the adaptive lasso, discussed
in Section 4.6; see Exercise 4.26.
Following this, Yuan and Lin (2007b) and Zou (2006) have shown that the
nonnegative garrote is path-consistent under less stringent conditions than the
lasso. This holds if the initial estimates are pN-consistent, for example those
based on least squares (when p < N), the lasso, or the elastic net. “Pathconsistent”
means that the solution path contains the true model somewhere
in its path indexed by t or . On the other hand, the convergence of the
parameter estimates from the nonnegative garrote tends to be slower than
that of the initial estimate.
22 THE LASSO FOR LINEAR MODELS
Table 2.3 Estimators of j from (2.21) in the
case of an orthonormal model matrix X.
q Estimator Formula
0 Best subset ˜ j · I[|˜ j | > p2]
1 Lasso sign( ˜ j)(|˜ j | − )+
2 Ridge ˜ j/(1 + )
2.9 `q Penalties and Bayes Estimates
For a fixed real number q  0, consider the criterion
minimize
2Rp
8<
:
1
2N
XN
i=1
(yi −
Xp
j=1
xijj)2 + 
Xp
j=1 |j |q
9=
;. (2.21)
TPhis is the lasso for q = 1 and ridge regression for q = 2. For q = 0, the term p
j=1 |j |q counts the number of nonzero elements in , and so solving (2.21)
amounts to best-subset selection. Figure 2.6 displays the constraint regions
corresponding to these penalties for the case of two predictors (p = 2). Both
q = 4 q = 2 q = 1 q = 0.5 q = 0.1
Figure 2.6 Constraint regions
Pp
j=1 |j |q  1 for different values of q. For q < 1,
the constraint region is nonconvex.
the lasso and ridge regression versions of (2.21) amount to solving convex
programs, and so scale well to large problems. Best subset selection leads to
a nonconvex and combinatorial optimization problem, and is typically not
feasible with more than say p = 50 predictors.
In the special case of an orthonormal model matrix X, all three procedures
have explicit solutions. Each method applies a simple coordinate-wise
transformation to the least-squares estimate ˜ , as detailed in Table 2.9. Ridge
regression does a proportional shrinkage. The lasso translates each coefficient
by a constant factor  and truncates at zero, otherwise known as soft thresholding.
Best-subset selection applies the hard thresholding operator: it leaves
the coefficient alone if it is bigger than p2, and otherwise sets it to zero.
The lasso is special in that the choice q = 1 is the smallest value of q
(closest to best-subset) that leads to a convex constraint region and hence a
SOME PERSPECTIVE 23
convex optimization problem. In this sense, it is the closest convex relaxation
of the best-subset selection problem.
There is also a Bayesian view of these estimators. Thinking of |j |q as
proportional to the negative log-prior density for j , the constraint contours
represented in Figure 2.6 have the same shape as the equi-contours of the prior
distribution of the parameters. Notice that for q  1, the prior concentrates
more mass in the coordinate directions. The prior corresponding to the q = 1
case is an independent double exponential (or Laplace) distribution for each
parameter, with joint density (1/2 ) exp(−kk1)/) and  = 1/. This means
that the lasso estimate is the Bayesian MAP (maximum aposteriori) estimator
using a Laplacian prior, as opposed to the mean of the posterior distribution,
which is not sparse. Similarly, if we sample from the posterior distribution
corresponding to the Laplace prior, we do not obtain sparse vectors. In order
to obtain sparse vectors via posterior sampling, one needs to start with a prior
distribution that puts a point mass at zero. Bayesian approaches to the lasso
are explored in Section 6.1.
2.10 Some Perspective
The lasso uses an `1-penalty, and such penalties are now widely used in statistics,
machine learning, engineering, finance, and other fields. The lasso was
proposed by Tibshirani (1996), and was directly inspired by the nonnegative
garrote of Breiman (1995). Soft thresholding was popularized earlier in the
context of wavelet filtering by Donoho and Johnstone (1994); this is a popular
alternative to Fourier filtering in signal processing, being both “local in time
and frequency.” Since wavelet bases are orthonormal, wavelet filtering corresponds
to the lasso in the orthogonal X case (Section 2.4.1). Around the same
time as the advent of the lasso, Chen, Donoho and Saunders (1998) proposed
the closely related basis pursuit method, which extends the ideas of wavelet filtering
to search for a sparse representation of a signal in over-complete bases
using an `1-penalty. These are unions of orthonormal frames and hence no
longer completely mutually orthonormal.
Taking a broader perspective, `1-regularization has a pretty lengthy history.
For example Donoho and Stark (1989) discussed `1-based recovery in
detail, and provided some guarantees for incoherent bases. Even earlier (and
mentioned in Donoho and Stark (1989)) there are related works from the
1980s in the geosciences community, for example Oldenburg, Scheuer and
Levy (1983) and Santosa and Symes (1986). In the signal processing world,
Alliney and Ruzinsky (1994) investigated some algorithmic issues associated
with `1 regularization. And there surely are many other authors who have
proposed similar ideas, such as Fuchs (2000). Rish and Grabarnik (2014) provide
a modern introduction to sparse methods for machine learning and signal
processing.
In the last 10–15 years, it has become clear that the `1-penalty has a
number of good properties, which can be summarized as follows:
24 THE LASSO FOR LINEAR MODELS
Interpretation of the final model: The `1-penalty provides a natural way to
encourage or enforce sparsity and simplicity in the solution.
Statistical efficiency: In the book The Elements of Statistical Learning
(Hastie, Tibshirani and Friedman 2009), the authors discuss an informal
“bet-on-sparsity principle.” Assume that the underlying true signal is sparse
and we use an `1 penalty to try to recover it. If our assumption is correct,
we can do a good job in recovering the true signal. Note that sparsity can
hold in the given bases (set of features) or a transformation of the features
(e.g., a wavelet bases). But if we are wrong—the underlying truth is not
sparse in the chosen bases—then the `1 penalty will not work well. However
in that instance, no method can do well, relative to the Bayes error. There
is now a large body of theoretical support for these loose statements: see
Chapter 11 for some results.
Computational efficiency: `1-based penalties are convex and this fact and the
assumed sparsity can lead to significant computational advantages. If we
have 100 observations and one million features, and we have to estimate
one million nonzero parameters, then the computation is very challenging.
However, if we apply the lasso, then at most 100 parameters can be nonzero
in the solution, and this makes the computation much easier. More details
are given in Chapter 5.7
In the remainder of this book, we describe many of the exciting developments
in this field.
Exercises
Ex. 2.1 Show that the smallest value of  such that the regression coefficients
estimated by the lasso are all equal to zero is given by
max = max
j |
1
N hxj , yi|.
Ex. 2.2 Show that the soft-threshold estimator (2.12) yields the solution to
the single predictor lasso problem (2.9). (Do not make use of subgradients,
and note that z is standardized).
Ex. 2.3 Soft thresholding and subgradients. Since (2.9) is a convex function, it
is guaranteed to have a subgradient (see Chapter 5 for more details), and any
optimal solution must satisfy the subgradient equation
−
1
N
XN
i=1
(yi − zi)zi + s = 0, where s is a subgradient of ||. (2.22)
For the absolute value function, subgradients take the form s 2 sign(), meaning
that s = sign() when  6= 0 and s 2 [−1, +1] when  = 0. The general
7Ridge regression also enjoys a similar efficiency in the p  N case.
EXERCISES 25
theory of convex optimization, as discussed in Chapter 5, guarantees that any
pair (b, bs) that is a solution to the zero subgradient Equation (2.22) with
bs 2 sign(b) defines an optimal solution to the original minimization problem
(2.9).
Solve Equation (2.22) and hence arrive at solutions (2.10) and (2.11).
Ex. 2.4 Show that the subgradient equations for Problem (2.5) take the form
given in (2.6). Hence derive expressions for coordinate descent steps (2.14)
and (2.15).
Ex. 2.5 Uniqueness of fitted values from the lasso. For some   0, suppose
that we have two lasso solutions b, b
 with common optimal value c.
(a) Show that it must be the case that Xb = Xb
, meaning that the two
solutions must yield the same predicted values. (Hint: If not, then use the
strict convexity of the function f(u) = ky − uk22
and convexity of the `1-
norm to establish a contradiction.)
(b) If  > 0, show that we must have kbk1 = kb
k1.
(Tibshirani2 2013).
Ex. 2.6 Here we use the bootstrap as the basis for inference with the lasso.
(a) For the crime data, apply the bootstrap to estimate the standard errors
of the estimated lasso coefficients, as in the middle section of Table 2.2. Use
the nonparametric bootstrap, sampling features and outcome values (xi, yi)
with replacement from the observed data. Keep the bound t fixed at its
estimated value from the original lasso fit. Estimate as well the probability
that an estimated coefficient is zero.
(b) Repeat part (a), but now re-estimate ˆ for each bootstrap replication.
Compare the results to those in part (a).
Ex. 2.7 Consider a fixed linear model based on k predictors and fit by least
squares. Show that its degrees of freedom (2.17) is equal to k.
Ex. 2.8 Degrees of freedom for lasso in the orthogonal case. Suppose that
yi = 0 +P
j xijj +i where i  N(0, 2), with the xij fixed (non-random).
Assume that the features are centered and also assume they are uncorrelated,
so that P
i xijxik = 0 for all j, k. Stein’s lemma (Stein 1981) states that for
Y  N(μ, 2) and all absolutely continuous functions g such that E|g0(Y )| <
1,
E(g(Y )(Y − μ)) = 2E(g0(Y )). (2.23)
Use this to show that the degrees of freedom (2.17) for the lasso in the orthogonal
case is equal to k, the number of nonzero estimated coefficients in
the solution.
26 THE LASSO FOR LINEAR MODELS
Ex. 2.9 Derive the solutions (2.20) to the nonnegative garrote criterion (2.19).
Ex. 2.10 Robust regression view of lasso. Consider a robust version of the
standard linear regression problem, in which we wish to protect ourselves
against perturbations of the features. In order to do so, we consider the minmax
criterion
minimize

max
2U
 1
2N ky − (X +)k22

, (2.24)
where the allowable perturbations  := (1, . . . , p) belong to the subset of
RN×p
U :=
n
(1, 2, . . . p) | kjk2  cj for all j = 1, 2, . . . , p
o
. (2.25)
Hence each feature value xij can be perturbed by a maximum amount cj , with
the `2-norm of the overall perturbation vector for that feature bounded by cj .
The perturbations for different features also act independently of one another.
We seek the coefficients that minimize squared error under the “worst” allowable
perturbation of the features. We assume that both y and the columns of
X have been standardized, and have not included an intercept.
Show that the solution to this problem is equivalent to
min
2Rp
8<
:
1
2N ky − Xk22
+
Xp
j=1
cj |j |
9= ;
.
(
2.26)
In the special case cj =  for all j = 1, 2, . . . , p, we thus obtain the lasso,
so that it can be viewed as a method for guarding against uncertainty in the
measured predictor values, with more uncertainty leading to a greater amount
of shrinkage. (See Xu, Caramanis and Mannor (2010) for further details.)
Ex. 2.11 Robust regression and constrained optimization. This exercise doesn’t
involve the lasso itself, but rather a related use of the `1-norm in regression.
We consider the model
yi =
Xp
j=1
xijj + 
i + i
with i  N(0, 2) and 
i, i = 1, 2, . . . ,N are unknown constants.
Let 
 = (
1, 
2, . . . , 
N) and consider minimization of
minimize
2Rp,
2RN
1
2
XN
i=1
(yi −
Xp
j=1
xijj − 
i)2 + 
XN
1 |
i|. (2.27)
The idea is that for each i, 
i allows yi to be an outlier; setting 
i = 0 means
that the observation is not deemed an outlier. The penalty term effectively
limits the number of outliers.
EXERCISES 27
(a) Show this problem is jointly convex in  and 
.
(b) Consider Huber’s loss function
(t; ) =
(
|t| − 2/2 if |t| > 
t2/2 if |t|  .
(2.28)
This is a tapered squared-error loss; it is quadratic for |t|   but linear
outside of that range, to reduce the effect of outliers on the estimation of .
With the scale parameter  fixed at one, Huber’s robust regression method
solves
minimize
2Rp
XN
i=1
(yi −
Xp
j=1
xijj ; ). (2.29)
Show that problems (2.27) and (2.29) have the same solutions b. (Antoniadis
2007, Gannaz 2007, She and Owen 2011).

Chapter 3
Generalized Linear Models
In Chapter 2, we focused exclusively on linear regression models fit by least
squares. Such linear models are suitable when the response variable is quantitative,
and ideally when the error distribution is Gaussian. However, other
types of response arise in practice. For instance, binary variables can be used
to indicate the presence or absence of some attribute (e.g., “cancerous” versus
“normal” cells in a biological assay, or “clicked” versus “not clicked” in web
browsing analysis); here the binomial distribution is more appropriate. Sometimes
the response occurs as counts (e.g., number of arrivals in a queue, or
number of photons detected); here the Poisson distribution might be called
for. In this chapter, we discuss generalizations of simple linear models and the
lasso that are suitable for such applications.
3.1 Introduction
With a binary response coded in the form Y 2 {0, 1}, the linear logistic model
is often used: it models the log-likelihood ratio as the linear combination
log Pr(Y = 1 | X = x)
Pr(Y = 0 | X = x) = 0 + T x, (3.1)
where X = (X1,X2, . . .Xp) is a vector of predictors, 0 2 R is an intercept
term, and  2 Rp is a vector of regression coefficients. Inverting this transformation
yields an expression for the conditional probability
Pr(Y = 1 | X = x) = e0+T x
1 + e0+T x
. (3.2)
By inspection, without any restriction on the parameters (0, ), the model
specifies probabilities lying in (0, 1). We typically fit logistic models by maximizing
the binomial log-likelihood of the data.
The logit transformation (3.1) of the conditional probabilities is an example
of a link function. In general, a link function is a transformation of the
conditional mean E[Y | X = x]—in this case, the conditional probability that
Y = 1—to a more natural scale on which the parameters can be fit without
constraints. As another example, if the response Y represents counts, taking
29
30 GENERALIZED LINEAR MODELS
values in {0, 1, 2, . . .}, then we need to ensure that the conditional mean is
positive. A natural choice is the log-linear model
log E[Y | X = x] = 0 + T x, (3.3)
with its log link function. Here we fit the parameters by maximizing the Poisson
log-likelihood of the data.
The models (3.1) and (3.3) are both special cases of generalized linear models
(McCullagh and Nelder 1989). These models describe the response variable
using a member of the exponential family, which includes the Bernoulli, Poisson,
and Gaussian as particular cases. A transformed version of the response
mean E[Y | X = x] is then approximated by a linear model. In detail, if we
use μ(x) = E[Y | X = x] to denote the conditional mean of Y given X = x,
then a GLM is based on a model of the form
g

μ(x)

= 0 + T | {z x}
(x)
, (3.4)
where g : R ! R is a strictly monotonic link function. For example, for a binary
response Y 2 {0, 1}, the logistic regression model is based on the choices
μ(x) = Pr[Y = 1 | X = x] and g(μ) = logit(μ) = log
􀀀
μ/(1 − μ)

. When the
response variable is modeled as a Gaussian, the choices μ(x) = 0 + T x
and g(μ) = μ recover the standard linear model, as discussed in the previous
chapter.
Generalized linear models can also be used to model the multicategory
responses that occur in many problems, including handwritten digit classification,
speech-recognition, document classification, and cancer classification.
The multinomial replaces the binomial distribution here, and we use a symmetric
log-linear representation:
Pr[Y = k | X = x] = e0k+T
k x
PK
`=1 e0`+T
` x
. (3.5)
Here there are K coefficients for each variable (one per class).
In this chapter, we discuss approaches to fitting generalized linear models
that are based on maximizing the likelihood, or equivalently minimizing the
negative log-likelihood along with an `1-penalty
minimize
0,

−
1
N L(0, ; y,X) + kk1

. (3.6)
Here y is the N-vector of outcomes and X is the N × p matrix of predictors,
and the specific form of the log-likelihood L varies according to the GLM. In
the special case of Gaussian responses and the standard linear model, we have
L(0, ; y,X) = 1
22 ky − 01 − Xk22
+ c, where c is a constant independent
of (0, ), so that the optimization problem (3.6) corresponds to the ordinary
linear least-squares lasso.
LOGISTIC REGRESSION 31
Similar forms of `1-regularization are also useful for related models. With
survival models, the response is the time to failure (death), with possible
censoring if subjects are lost to followup. In this context, a popular choice is
the Cox proportional hazards model, which takes the form
h(t | x) = h0(t)eT x. (3.7)
Here t 7! h(t | x) is the hazard function for an individual with covariates x:
the value h(t | x) corresponds to the instantaneous probability of failure at
time Y = t, given survival up to time t. The function h0 specifies the baseline
hazard, corresponding to x = 0.
As another example, the support-vector machine (SVM) is a popular classifier
in the machine-learning community. Here the goal is to predict a twoclass
response y 2 {−1, +1},1 in the simplest case using a linear classification
boundary of the form f(x) = 0 + T x, with the predicted class given by
sign(f(x)). Thus, the correctness of a given decision can be determined by
checking whether or not the margin yf(x) is positive. The traditional softmargin
linear SVM is fit by solving the optimization problem2
minimize
0,
8><
>:
1
N
XN
i=1
[1 − yif(xi)]+ | {z }
(yif(xi))
+kk22
9>= >;
. (3.8)
The first term, known as hinge loss, is designed to penalize the negative margins
that represent incorrect classifications. In general, an optimal solution
vector  2 Rp to the standard linear SVM (3.8) is not sparse, since the
quadratic penalty has no sparsity-enforcing properties. However, replacing
the quadratic penalty by the `1-norm kk1 leads to an `1 linear SVM, which
does produce sparse solutions.
In the following sections, we discuss each of these models in more detail.
In each case, we provide examples of their applications, discuss some of the
issues that arise, as well as computational approaches for fitting the models.
3.2 Logistic Regression
Logistic regression has been popular in biomedical research for half a century,
and has recently gained popularity for modeling a wider range of data. In the
high-dimensional setting, in which the number of features p is larger than the
sample size, it cannot be used without modification. When p > N, any linear
model is over-parametrized, and regularization is needed to achieve a stable
fit. Such high-dimensional models arise in various applications. For example,
document classification problems can involve binary features (presence versus
1For SVMs, it is convenient to code the binary response via the sign function.
2This is not the most standard way to introduce the support vector machine. We discuss
this topic in more detail in Section 3.6.
32 GENERALIZED LINEAR MODELS
absence) over a predefined dictionary of p = 20, 000 or more words and tokens.
Another example is genome-wide association studies (GWAS), where we have
genotype measurements at p = 500, 000 or more “SNPs,” and the response is
typically the presence/absence of a disease. A SNP (pronounced “snip”) is a
single-nucleotide polymorphism, and is typically represented as a three-level
factor with possible values {AA, Aa, aa}, where “A” refers to the wild-type,
and “a” the mutation.
When the response is binary, it is typically coded as 0/1. Attention then
focuses on estimating the conditional probability Pr(Y = 1 | X = x) = E[Y | X = x]. Given the logistic model (3.1), the negative log likelihood with `1-
regularization takes the form
−
1
N
XN
i=1 {yi log Pr(Y = 1 | xi) + (1 − yi) log Pr(Y = 0 | xi)} + kk1
= −
1
N
XN
i=1
n
yi(0 + T xi) − log(1 + e0+T xi )
o
+ kk1. (3.9)
In the machine-learning community, it is more common to code the response
Y in terms of sign variables {−1, +1} rather than {0, 1} values; when using
sign variables, the penalized (negative) log-likelihood has the form
1
N
XN
i=1
log(1 + e−yif(xi ;0,)) + kk1, (3.10)
where f(xi ; 0, ) := 0 + T xi. For a given covariate-response pair (x, y),
the product yf(x) is referred to as the margin: a positive margin means a
correct classification, whereas a negative margin means an incorrect classification.
From the form of the log-likelihood (3.10), we see that maximizing
the likelihood amounts to minimizing a loss function monotone decreasing
in the margins. We discuss the interplay of the margin and the penalty in
Section 3.6.1.
3.2.1 Example: Document Classification
We illustrate `1-regularized logistic regression in a domain where it has gained
popularity, namely document classification using the 20-Newsgroups corpus
(Lang 1995). We use the particular feature set and class definition defined
by Koh, Kim and Boyd (2007).3 There are N = 11, 314 documents and p =
777, 811 features, with 52% in the positive class. Only 0.05% of the features
are nonzero for any given document.
3The positive class consists of the 10 groups with names of the form sci.*, comp.* and
misc.forsale, and the rest are the negative class. The feature set consists of trigrams, with
message headers skipped, no stoplist, and features with less than two documents omitted.
LOGISTIC REGRESSION 33
0.0 0.2 0.4 0.6 0.8
−4 −2 0 2
Fraction Deviance Explained
Coefficients
0 66 246 1061 3176
Figure 3.1 Coefficient paths for an `1-regularized logistic regression for a documentclassification
task—the “NewsGroup” data. There are 11K documents roughly divided
into two classes, and 0.78M features. Only 0.05% of the features are nonzero. The
coefficients are plotted as a function of the fraction of null deviance explained.
Figure 3.1 shows the coefficient profile, computed using the R package
glmnet. Although the solutions were computed at 100 values of , uniformly
spaced on the log scale, we have indexed the solutions by the fraction of
deviance explained4 on the training data:
D2
 = Devnull − Dev
Devnull
. (3.11)
Here the deviance Dev is defined as minus twice the difference in the loglikelihood
for a model fit with parameter  and the “saturated” model (having
by = yi). Devnull is the null deviance computed at the constant (mean) model.
Since for these data the classes are separable, the range of  is chosen so as not
to get too close to the saturated fit (where the coefficients would be undefined;
see the next section).
The maximum number of nonzero coefficients in any of these models can
be shown to be min(N, p), which is equal 11, 314 in this case. In Figure 3.1, the
largest model actually had only 5, 277 coefficients since glmnet did not go to
the very end of the solution path. Although it might seem more natural to plot
against the log() sequence, or perhaps kˆ ()k1, there are problems with both
in the p  N setting. The former quantity is data and problem dependent,
4the name D2 is by analogy with R2, the fraction of variance explained in regression.
34 GENERALIZED LINEAR MODELS
0.0 0.2 0.4 0.6 0.8
0.0 0.1 0.2 0.3 0.4 0.5
Fraction Deviance Explained
Misclassification Error
0 7 28 95 169 352 756 1785 3502
10−fold CV
Train
0.0 0.2 0.4 0.6 0.8
0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4
Fraction Deviance Explained
Binomial Deviance
0 7 28 95 169 352 756 1785 3502
Figure 3.2 Lasso (`1)-penalized logistic regression. Tenfold cross-validation curves
for the Newsgroup data are shown in red, along with pointwise standard-error bands
(not visible). The left plot shows misclassification error; the right plot shows deviance.
Also shown in blue is the training error for each of these measures. The number of
nonzero coefficients in each model is shown along the top of each plot.
and gives no indication of the amount of overfitting, whereas for the latter
measure, the graph would be dominated by the less interesting right-hand
side, in which the coefficients and hence their norm explode.
Figure 3.2 shows the results of tenfold cross-validation for these data, as
well as training error. These are also indexed by the fraction of deviance
explained on the training data. Figure 3.3 shows the analogous results to those
in Figure 3.2, for ridge regression. The cross-validated error rates are about
the same as for the lasso. The number of nonzero coefficients in every model
is p = 777, 811 compared to a maximum of 5, 277 in Figure 3.2. However the
rank of the ridge regression fitted values is actually min(N, p) which equals
11, 314 in this case, not much different from that of the lasso fit. Nonetheless,
ridge regression might be more costly from a computational viewpoint. We
produced the cross-validation results in Figure 3.3 using the glmnet package;
for ridge the tenfold cross-validation took 8.3 minutes, while for lasso under
one minute. A different approach would be to use the kernel trick (Hastie and
Tibshirani 2004, for example), but this requires a singular value or similar
decomposition of an 11, 314 × 11, 314 matrix.
For this example, using the package glmnet, we fit the regularization path
in Figure 3.1 at 100 values of  in 5 secs on a 2.6 GHz Macbook Pro. In examples
like this with so many features, dramatic speedups can be achieved by
screening the features. For example, the first feature to enter the regularization
path achieves max = maxj |hxj , y − ¯pi|, where y is the vector of binary
LOGISTIC REGRESSION 35
0.3 0.4 0.5 0.6 0.7 0.8 0.9
0.00 0.02 0.04 0.06 0.08 0.10 0.12
Fraction Deviance Explained
Misclassification Error
10−fold CV
Train
0.3 0.4 0.5 0.6 0.7 0.8 0.9
0.2 0.4 0.6 0.8 1.0
Fraction Deviance Explained
Binomial Deviance
Figure 3.3 Ridge (`2)-penalized logistic regression: tenfold cross validation curves
for the Newsgroup data are shown in red, along with pointwise standard-error bands.
The left plot shows misclassification error; the right plot shows deviance. Also shown
in blue is the training error for each of these measures.
outcomes, and ¯p = 0.52 1 is a vector of the overall mean. This is the entry
value for ; that is the smallest value for which all coefficients are zero. When
computing the solution path from max down to a slightly lower value 1, we
can screen out the vast majority of variables for which this inner-product is
substantially lower than 1. Once we have computed the solution with the
much smaller subset, we can check if any those screened were omitted in error.
This can be repeated as we move down the path, using inner-products
with the current residuals. This “strong-rule” screening is implemented in
the glmnet package that we used for the computations in the above example.
We discuss strong rules and other computational speedups in more detail in
Section 5.10.
3.2.2 Algorithms
Two-class logistic regression is a popular generalization of linear regression,
and as a consequence much effort has gone into fitting lasso-penalized logistic
models. The objective (3.9) is convex and the likelihood part is differentiable,
so in principle finding a solution is a standard task in convex optimization
(Koh et al. 2007).
Coordinate descent is both attractive and efficient for this problem, and in
the bibliographic notes we give a partial account of the large volume of research
on this approach; see also Sections 2.4.2 and 5.4. The glmnet package uses
a proximal-Newton iterative approach, which repeatedly approximates the
negative log-likelihood by a quadratic function (Lee, Sun and Saunders 2014).
36 GENERALIZED LINEAR MODELS
In detail, with the current estimate ( ˜ 0, ˜ ), we form the quadratic function
Q(0, ) = 1
2N
XN
i=1
wi(zi − 0 − T xi)2 + C( ˜ 0, ˜ ), (3.12)
where C denotes a constant independent of (0, ), and
zi = ˜ 0 + ˜ T xi + yi − ˜p(xi)
˜p(xi)(1 − ˜p(xi)) , and wi = ˜p(xi)(1 − ˜p(xi)), (3.13)
with ˜p(xi) being the current estimate for Pr(Y = 1 | X = xi). Each outer loop
then amounts to a weighted lasso regression. By using warm starts on a fine
grid of values for , typically only a few outer-loop iterations are required,
because locally the quadratic approximation is very good. We discuss some of
the features of glmnet in Sections 3.7 and 5.4.2.
3.3 Multiclass Logistic Regression
Some classification and discrimination problems have K > 2 output classes. In
machine learning a popular approach is to build all
􀀀K2

classifiers (“one versus
one” or OvO), and then classify to the class that wins the most competitions.
Another approach is “one versus all” (OvA) which treats all but one class as
the negative examples. Both of these methods can be put on firm theoretical
grounds, but also have limitations. OvO can be computationally wasteful,
and OvA can suffer from certain masking effects (Hastie et al. 2009, Chapter
4). With multiclass logistic regression, a more natural approach is available.
We use the multinomial likelihood and represent the probabilities using the
log-linear representation
Pr(Y = k | X = x) = e0k+T
k x
PK
`=1 e0`+T
` x
. (3.14)
This model is over specified, since we can add the linear term 
0 + 
T x
to the linear model for each class, and the probabilities are unchanged. For
this reason, it is customary to set one of the class models to zero—often the
last class—leading to a model with K −1 linear functions to estimate (each a
contrast with the last class). The model fit by maximum-likelihood is invariant
to the choice of this base class, and the parameter estimates are equivariant
(the solution for one base can be obtained from the solution for another).
Here we prefer the redundant but symmetric approach (3.14), because
• we regularize the coefficients, and the regularized solutions are not equivariant
under base changes, and
• the regularization automatically eliminates the redundancy (details below).
For observations {(xi, yi}Ni
=1, we can write the regularized form of the negative
MULTICLASS LOGISTIC REGRESSION 37
log-likelihood as
−
1
N
XN
i=1
log Pr(Y = yi | xi; {0k, k}Kk
=1) + 
XK
k=1 kkk1. (3.15)
Denote by R the N × K indicator response matrix with elements rik =
I(yi = k). Then we can write the log-likelihood part of the objective (3.15)
in the more explicit form
1
N
XN
i=1
wi
"
XK
k=1
rik(0k + T
k xi) − log
(
XK
k=1
e0k+T
k xi
)#
. (3.16)
We have included a weight wi per observation, where the setting wi = 1/N
is the default. This form allows for grouped response data: at each value xi
we have a collection of ni multicategory responses, with rik in category k.
Alternatively, the rows of R can be a vector of class proportions, and we can
provide wi = ni as the observation weights.
As mentioned, the model probabilities and hence the log-likelihood are invariant
under a constant shift in the K coefficients for each variable xj—in
other words {kj + cj}Kk
=1 and {kj}Kk
=1 produce exactly the same probabilities.
It is therefore up to the penalty in the criterion (3.15) to resolve the
choice of cj . Clearly, for any candidate set {˜ kj}Kk
=1, the optimal cj should
satisfy
cj = arg min
c2R
(
XK
k=1 |˜ kj − c|
)
. (3.17)
Consequently, as shown in Exercise 3.3, for each j = 1, . . . , p, the maximizer of
the objective (3.17) is given by the median of {˜ 1j , . . . , ˜ Kj}. Since the intercepts
{0k}Kk
=1 are not penalized, we do need to resolve their indeterminacy;
in the glmnet package, they are constrained to sum to zero.
3.3.1 Example: Handwritten Digits
As an illustration, we consider the US post-office handwritten digits
data (Le Cun, Boser, Denker, Henderson, Howard, Hubbard and Jackel 1990).
There are N = 7291 training images of the digits {0, 1, . . . , 9}, each digitized
to a 16 × 16 gray-scale image. Using the p = 256 pixels as features, we fit a
10-class lasso multinomial model. Figure 3.4 shows the training and test misclassification
error as a function of the sequence of  values used. In Figure 3.5
we display the coefficients as images (on average about 25% are nonzero). Some
of these can be identified as appropriate contrast functionals for highlighting
each digit.
38 GENERALIZED LINEAR MODELS
5e−05 5e−04 5e−03 5e−02
0.0 0.1 0.2 0.3 0.4
Misclassification Error
train
test
Multinomial Lasso on Zip Code Data
log()
Figure 3.4 Training and test misclassification errors of a multinomial lasso model
fit to the zip code data, plotted as a function of log(). The minimum test error
here is around 0.086, while the minimum training error is 0. We highlight the value
 = 0.001, where we examine the individual class coefficients in Figure 3.5.
0 1 2 3 4
5 6 7 8 9
Figure 3.5 Coefficients of the multinomial lasso, displayed as images for each digit
class. The gray background image is the average training example for that class.
Superimposed in two colors (yellow for positive, blue for negative) are the nonzero
coefficients for each class. We notice that they are nonzero in different places, and
create discriminant scores for each class. Not all of these are interpretable.
MULTICLASS LOGISTIC REGRESSION 39
3.3.2 Algorithms
Although one could tackle this problem with standard convex-optimization
software, we have found coordinate-descent to be particularly effective
(Friedman, Hastie, Simon and Tibshirani 2015). In the two-class case, there
is an outer Newton loop and an inner weighted least-squares step. The outer
loop can be seen as making a quadratic approximation to the log-likelihood,
centered at the current estimates ( ˜ 0k, ˜ k}Kk
=1. Here we do the same, except
we hold all but one class’s parameters fixed when making this approximation.
In detail, when updating the parameters (0`, `), we form the quadratic
function
Q`(0`, `) = −
1
2N
XN
i=1
wi` (zi` − 0` − T
` xi)2 + C({˜ 0k, ˜ k}Kk
=1), (3.18)
where C denotes a constant independent of (0`, `), and
zi` = ˜ 0` + ˜ T
` xi + ri` − ˜p`(xi)
˜p`(xi)(1 − ˜p`(xi)) , and wi` = ˜p`(xi)(1 − ˜p`(xi))
where ˜p`(xi) is the current estimate for the conditional probability
Pr(Y = ` | xi). Our approach is similar to the two-class case, except now we
have to cycle over the classes as well in the outer loop. For each value of , we
create an outer loop which cycles over ` 2 {1, . . . ,K} and computes the partial
quadratic approximation Q` about the current parameters ( ˜ 0, ˜ ). Then
we use coordinate descent to solve the weighted lasso problem problem
minimize
(0`,`)2Rp+1 {Q(0`, `) + k`k1} . (3.19)
3.3.3 Grouped-Lasso Multinomial
As can be seen in Figure 3.5, the lasso penalty will select different variables for
different classes. This can mean that although individual coefficient vectors
are sparse, the overall model may not be. In this example, on average there
are 25% of the coefficients nonzero per class, while overall 81% of the variables
are used.
An alternative approach is to use a grouped-lasso penalty (see Section 4.3)
for the set of coefficients j = (1j , 2j , . . . , Kj ), and hence replace the criterion
(3.15) with the regularized objective
−
1
N
XN
i=1
log Pr(Y = yi | X = xi; {j}p
j=1) + 
Xp
j=1 kjk2. (3.20)
It is important that this criterion involves the sum of the ordinary `2-norms
k · k2, as opposed to the squared `2-norms. In this way, it amounts to imposing
a block `1/`2 constraint on the overall collection of coefficients: the
40 GENERALIZED LINEAR MODELS
sum of the `2-norms over the groups. The effect of this group penalty is to
select all the coefficients for a particular variable to be in or out of the model.
When included, they are all nonzero in general, and as shown in Exercise 3.6,
they will automatically satisfy the constraint PK
k=1 kj = 0. Criterion (3.20)
is convex, so standard methods can be used to find the optimum. As before,
coordinate descent techniques are one reasonable choice, in this case block
coordinate descent on each vector j , holding all the others fixed; see Exercise
3.7 for the details. The group lasso and variants are discussed in more
detail in Chapter 4.3.
3.4 Log-Linear Models and the Poisson GLM
When the response variable Y is nonnegative and represents a count, its mean
will be positive and the Poisson likelihood is often used for inference. In this
case we typically use the log-linear model (3.3) to enforce the positivity. We
assume that for each X = x, the response Y follows a Poisson distribution
with mean μ satisfying
log μ(x) = 0 + T x. (3.21)
The `1-penalized negative log-likelihood is given by
−
1
N
XN
i=1
n
yi(0 + T xi) − e0+T xi
o
+ kk1. (3.22)
As with other GLMs, we can fit this model by iteratively reweighted least
squares, which amounts to fitting a weighted lasso regression at each outer
iteration. Typically, we do not penalize the intercept 0. It is easy to see that
this enforces the constraint that the average fitted value is equal to the mean
response—namely, that 1
N
PN
i=1 ˆμi = ¯y, where ˆμi := eˆ(xi) = eb0+bT xi .
Poisson models are often used to model rates, such as death rates. If the
length Ti of the observation window is different for each observation, then the
mean count is E(yi | Xi = xi) = Tiμ(xi) where μ(xi) is the rate per unit time
interval. In this case, our model takes the form
log(E(Y | X = x, T)) = log(T) + 0 + T x. (3.23)
The terms log(Ti) for each observation require no fitting, and are called an
offset. Offsets play a role in the following example as well.
3.4.1 Example: Distribution Smoothing
The Poisson model is a useful tool for estimating distributions. The following
example was brought to our attention by Yoram Singer (Singer and
Dubiner 2011). Suppose that we have a sample of N counts {yk}Nk
=1 from an
LOG-LINEAR MODELS AND THE POISSON GLM 41
N-cell multinomial distribution, and let rk = yk/
PN
`=1 y` be the corresponding
vector of proportions. For example, in large-scale web applications, these
counts might represent the number of people in each county in the USA that
visited a particular website during a given week. This vector could be sparse,
depending on the specifics, so there is a desire to regularize toward a broader,
more stable distribution u = {uk}Nk
=1 (for example, the same demographic,
except measured over a year). Singer and Dubiner (2011) posed the following
problem
minimize
q2RN, qk0
XN
k=1
qk log

qk
uk

such that kq − rk1   and PN
k=1 qk = 1.
(3.24)
In words, we find the distribution, within a  tolerance in the `1-norm from
the observed distribution, that is as close as possible to the nominal distribution
u in terms of Kullback–Leibler (KL) divergence. It can be shown (see
−6 −4 −2 0 2 4 6
0.00 0.01 0.02 0.03 0.04
X
−6 −4 −2 0 2 4 6
5e−07 5e−06 5e−05 5e−04
X
Differences
f(x)
Figure 3.6 Estimating distributions via the Poisson. In the left panel, the solid
black curve is the parent distribution u, here represented as a discretization of a onedimensional
distribution f(x) into 100 cells. The blue points represent the observed
distribution, and the orange points represent the distribution recovered by the model.
While the observed distribution may have many zero counts, the modeled distribution
has the same support as u. The right plot shows the N = 100 differences |ˆqk − rk|,
which are constrained to be less than  = 0.001, which is the horizontal orange line.
Exercise 3.4) that the Lagrange-dual to the optimization problem (3.24) has
the form
maximize
0,
(
XN
k=1
[rk log qk(0, k) − qk(0, k)] − kk1
)
, (3.25)
where qk(0, k) := uke0+k . This is equivalent to fitting a Poisson GLM
with offset log(uk), individual parameter k per observation, and the extremely
sparse design matrix X = IN×N. Consequently, it can be fit very
efficiently using sparse-matrix methods (see Section 3.7 below). Figure 3.6
42 GENERALIZED LINEAR MODELS
shows a simulation example, where the distribution uk is a discretized continuous
distribution (mixture of Gaussians). There are N = 100 cells, and a total
of PN
k=1 yk = 1000 observations distributed to these cells. As discussed above,
the presence of the unpenalized 0 ensures that PN
k=1 ˆqk = PN
k=1 rk = 1 (see
also Exercise 3.5). Although we only show one solution in Figure 3.6, the path
gives solutions ˆqk() that vary smoothly between the background distribution
uk and the observed distribution rk.
3.5 Cox Proportional Hazards Models
In medical studies, the outcome of interest after treatment is often time to
death or time to recurrence of the disease. Patients are followed after their
treatment, and some drop out because they move away, or perhaps die from
an independent cause. Such outcomes are called right censored. Denoting by
T the underlying survival time, for each patient we observe the quantity
Y = min(T,C) where C is a censoring time. Interest tends to focus on the
survivor function S(t) := Pr(T > t), the probability of surviving beyond a
certain time t.
0 5 10 15 20
0.0 0.2 0.4 0.6 0.8 1.0
Kaplan−Meier Estimates (naive)
Time
Survival Probability
Pred > 0
Pred<=0
Overall
0 5 10 15 20
0.0 0.2 0.4 0.6 0.8 1.0
Kaplan−Meier Estimates (prevalidated)
Time
Survival Probability
p=0.00012
Figure 3.7 The black curves are the Kaplan–Meier estimates of S(t) for the Lymphoma
data. In the left plot, we segment the data based on the predictions from
the Cox proportional hazards lasso model, selected by cross-validation. Although the
tuning parameter is chosen by cross-validation, the predictions are based on the full
training set, and are overly optimistic. The right panel uses prevalidation to build
a prediction on the entire dataset, with this training-set bias removed. Although the
separation is not as strong, it is still significant. The spikes indicate censoring times.
The p-value in the right panel comes from the log-rank test.
The black curves in Figure 3.7 show estimates of S(t) for a population of
N = 240 Lymphoma patients (Alizadeh et al. 2000). Each of the spikes in the
COX PROPORTIONAL HAZARDS MODELS 43
plot indicates a censoring point, meaning a time at which a patient was lost for
follow-ups. Although survival curves are useful summaries of such data, when
incorporating covariates it is more common to model the hazard function, a
monotone transformation of S. More specifically, the hazard at time t is given
by
h(t) = lim
!0
Pr(Y 2 (t, t + ) | Y  t)

= f(t)
S(t) , (3.26)
and corresponds to the instantaneous probability of death at time t, given
survival up till t.
We now discuss Cox’s proportional hazards model that was used to produce
the blue and orange survival curves in Figure 3.7. The proportional hazards
model (CPH) is based on the hazard function
h(t; x) = h0(t)eT x, (3.27)
where h0(t) is a baseline hazard (the hazard for an individual with x = 0).
We have data of the form (xi, yi, i), where i is binary-valued indicator of
whether yi is a death time or censoring time. For the lymphoma data, there
are p = 7399 variables, each a measure of gene expression. Of the N = 240
samples, a total of 102 samples are right censored. Here we fit an `1-penalized
CPH by solving
minimize

8<
:−
X
{i |i=1}
log
"
eT xi
P
j2Ri
eT xj
#
+ kk1
9=
;, (3.28)
where for each i = 1, . . . ,N, Ri is the risk set of individuals who are alive
and in the study at time yi. The first term is the log of the partial likelihood,
corresponding to the conditional probability in the risk set of the observed
death. Note that the baseline hazard does not play a role, an attractive feature
of this approach. Here we have assumed that there are no ties, that is, the
survival times are all unique. Modification of the partial likelihood is needed
in the event of ties.
Figure 3.8 shows the coefficients obtained in fitting the model (3.28) to the
Lymphoma data. Since p  N, the model would “saturate” as  # 0, meaning
that some parameters would diverge to ±1, and the log partial likelihood
would approach 0. We see evidence of this undesirable behavior as  gets
small.
The computations for the Cox model are similar to those for the multinomial
model but slightly more complex. Simon, Friedman, Hastie and Tibshirani
(2011) give details for an algorithm based on coordinate-descent.
3.5.1 Cross-Validation
All the models in this chapter require a choice of , and we typically use
K−fold cross-validation where K equal to 5 or 10, as in Figure 3.2. For the
44 GENERALIZED LINEAR MODELS
−6 −5 −4 −3 −2
−4 −2 0 2 4
Coefficients
219 202 188 126 31 15
−2.8 −2.6 −2.4 −2.2 −2.0 −1.8 −1.6
−0.4 −0.2 0.0 0.2 0.4
Coefficients
15
Zoomed in
31
log() log()
Figure 3.8 The `1-regularized coefficient path for the Cox model fit to the Lymphoma
data. Since p  N, the plot has a trumpet shape near the end, corresponding
to a saturated model with partial likelihood equal to one. The right-hand plot zooms
in on the area of interest, a fairly heavily regularized solution with 31 nonzero coefficients.
Cox model, we compute the cross-validated deviance, which is minus twice
the log partial likelihood. An issue arises in computing the deviance, since if
N/K is small, there will not be sufficient observations to compute the risk
sets. Here we use a trick due to van Houwelingen et al. (2006). When fold k
is left out, we compute the coefficients b−k(), and then compute
dDevk
 := Dev[b−k()] − Dev−k[b−k()]. (3.29)
The first term on the right uses all N samples in computing the deviance,
while the second term omits the fold-k samples. Finally DevCV
 = PK
k=1
dDevk

is obtained by subtraction. The point is that each of these terms has sufficient
data to compute the deviance, and in the standard cases (that is, any of the
other generalized linear models), the estimate would be precisely the deviance
on the left-out set.
The deviance in Figure 3.9 was computed in this fashion; we zoom in on
the right-hand section. We see that the minimum is achieved at 31 nonzero
coefficients. Figure 3.7 shows the effect of the chosen model. We compute
ˆ(xi) = xTi
ˆ (min) for each observation, and then create two groups by thresholding
these scores at zero. The two colored survival curves in the left-hand
plot show the difference in survival for the two groups thus formed. They are
well separated, which suggests we have derived a powerful signature. However,
these scores are biased: we are evaluating their performance on the same data
for which they were computed.
COX PROPORTIONAL HAZARDS MODELS 45
−6 −5 −4 −3 −2
50 100 150
Partial Likelihood Deviance
230 218 212 216 204 186 135 68 25 7
−2.8 −2.6 −2.4 −2.2 −2.0 −1.8 −1.6
11.0 11.5 12.0 12.5 13.0
Partial Likelihood Deviance
114 93 75 55 41 28 20 14 7 4 3 0
Zoomed in
log() log()
Figure 3.9 Cross-validated deviance for the lymphoma data, computed by subtractions,
as described in the text. The right-hand plot zooms in on the area of interest.
The dotted vertical line on the left corresponds to the minimum, and the model we
chose in this case; the one on the right corresponds to the rightmost point on the
curve (simplest model) within one standard error of the minimum. This is a basis
for a more conservative approach to selection. The number of nonzero coefficients is
shown along the top of each plot.
3.5.2 Pre-Validation
In Figure 3.7, we used a variant of cross-validation, known as pre-validation
(Tibshirani and Efron 2002), in order to obtain a fair evaluation of the model.
Cross-validation leaves out data in order to obtain a reasonably unbiased
estimate of the error rate of a model. But the error rate is not a very interpretable
measure in some settings such as survival modelling. The method of
pre-validation is similar to cross-validation, but instead produces a new set of
“unbiased data” that mimics the performance of the model applied to independent
data. The pre-validated data can then be analyzed and displayed. In
computing the score ˆ(xi)(k) for the observations in fold k, we use the coefficient
vector b(−k) computed with those observations omitted.5 Doing this for
all K folds, we obtain the “pre-validated” dataset {(ˆ(xi)(k), yi, i)}Ni
=1. The
key aspect of this pre-validated data is that each score ˆ(xi)(k) is derived independently
of its response value (yi, i). Hence we can essentially treat these
scores as if they were derived from a dataset completely separate from the
“test data” {(xi, yi, i)}Ni
=1. In the right-hand panel of Figure 3.7, we have
split the pre-validated scores into two groups and plotted the corresponding
5Strictly speaking  should be chosen each time as well, but we did not do that here.
46 GENERALIZED LINEAR MODELS
survival curves. Although the curves are not as spread out as in the left-hand
plot, they are still significantly different.
3.6 Support Vector Machines
We now turn to a method for binary classification known as the support vector
machine (SVM). The idea is shown in Figure 3.10. The decision boundary is
the solid line in the middle of the yellow slab. The margin is the half-width of
the yellow slab. Ideally, all of the blue data points should lie above the slab
on the right, and the red points should lie below it on the left. However in the
picture, three red points and two blue points lie on the wrong side of their
margin. These correspond to the “errors” i. The SVM decision boundary is
cPhosen to maximize the margin, subject to a fixed budget on the total error N
i=1 i. The idea is that a decision boundary achieving the largest margin
has more space between the classes and will generalize better to test data.
This leads to the optimization problem
maximize
0, , {i}N1
M subject to yi (0 + T xi)
| {z }
f(xi; 0, )
 M(1 − i) 8i, (3.30)
and i  0 8i,
XN
i=1
i  C, and kk2 = 1. (3.31)
(See Section 3.6.1 for an explanation of this particular form.)
This problem involves a linear cost function subject to convex constraints,
and many efficient algorithms have been designed for its solution. It can be
shown to be equivalent to the penalized form (3.8) previously specified on
page 31, which we restate here:
minimize
0,
(
1
N
XN
i=1
[1 − yif(x ; 0, )]+ + kk22
)
. (3.32)
Decreasing  has a similar effect to decreasing C.6 The linear SVM can be
generalized using a kernel to create nonlinear boundaries; it involves replacing
the squared `2-norm in the objective (3.32) by the squared Hilbert norm defined
by a symmetric bivariate kernel. Details on this extension can be found
elsewhere—for instance, see Hastie et al. (2009), Section 5.8.
Since the criterion (3.32) involves a quadratic penalty, the estimated coefficient
vector will not be sparse. However, because the hinge loss function is
piecewise linear, it introduces a different kind of sparsity. It can be shown via
the dual formulation of the SVM that the solution ˆ  has the form
ˆ  =
XN
i=1
ˆiyixi; (3.33)
6Solutions to (3.32) do not have k ˆk2 = 1, but since a linear classifier is scale invariant,
the solution coefficients can be rescaled.
SUPPORT VECTOR MACHINES 47
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
•
margin
1∗1
∗2∗2
∗3∗3
∗4∗4 ∗5
M = 1
kk2
M = 1
kk2
0 + T x = 0
Figure 3.10 Support vector classifier: The decision boundary is the solid line, while
broken lines bound the shaded maximal margin of width 2M = 2/kk2. The points
labelled 
j are on the wrong side of their margin by an amount 
j = Mj ; points
on the correct side have 
j P = 0. The margin is maximized subject to a total budget N
i=1 i  C. Hence
PN
i=1 
j is the total distance of points on the wrong side of
their margin.
each observation i 2 {1, . . . ,N} is associated with a nonnegative weight ˆi,
and only a subset V, referred to as the support set, will be associated with
nonzero weights.
SVMs are popular in high-dimensional classification problems with p  N,
since the computations are O(pN2) for both linear and nonlinear kernels. Additional
efficiencies can be realized for linear SVMs, using stochastic subgradient
methods (Shalev-Shwartz, Singer and Srebro 2007). They are not, however,
sparse in the features. Replacing the `2 penalty in the objective (3.32) with an
`1 penalty promotes such sparsity, and yields the `1-regularized linear SVM:
minimize
0,
(
1
N
XN
i=1
[1 − yif(xi; 0, )]+ + kk1
)
. (3.34)
The optimization problem (3.34) is a linear program with many constraints
(Zhu, Rosset, Hastie and Tibshirani 2004, Wang, Zhu and Zou 2006),
and efficient algorithms can be complex (Exercise 3.9). The solution paths (in
fine detail) can have many jumps, and show many discontinuities. For this
reason, some authors prefer to replace the usual hinge loss hin = (1 − t)+
48 GENERALIZED LINEAR MODELS
0.0 0.5 1.0 1.5 2.0 2.5
−0.2 0.0 0.2 0.4 0.6
SA Heart Disease p < N
L1 norm
Coefficients
Hinge Loss versus Binomial with L1 Regularization
0 1 2 3 4 5 6
0.0 0.5 1.0 1.5
Leukemia p >> N
L1 norm
Coefficients
Figure 3.11 A comparison of the coefficient paths for the `1-regularized SVM versus
logistic regression on two examples. In the left we have the South African heart
disease data (N = 462 and p = 9), and on the right the Leukemia data (N = 38
and p = 6087). The dashed lines are the SVM coefficients, the solid lines logistic
regression. The similarity is striking in the left example, and strong in the right.
with squared hinge loss sqh(t) = (1 − t)2
+, which is differentiable everywhere
(see Exercise 3.8).
The SVM loss function shares many similarities with the binomial
loss (Hastie et al. 2009, Section 12.3), and their solutions are not too different.
Figure 3.11 compares their `1 regularization paths on two examples,
and supports this claim. In the left-hand plot, they are virtually identical.
In the right-hand plot, for more than half of the path, the training data are
separated by the solution. As we proceed to the end of the path, the logistic
coefficients become less stable than those of the SVM, and can account for
the bigger discrepancies.
The support vector machine, on the other hand, is designed for finding
maximal-margin solutions for separable data, and its coefficients do not blow
up at the least-regularized end of the path. However, in terms of the `1 penalty,
this is at the nonsparse end of the path. In light of this, we do not recommend
the `1 regularized linear SVM as a variable selector, because the corresponding
logistic regression problem (3.6) gives very similar solutions when the penalty
is active, and the algorithms are more stable.
SUPPORT VECTOR MACHINES 49
3.6.1 Logistic Regression with Separable Data
It is a well-known fact that without a penalty on the coefficients, the linear
logistic regression model fails when the two classes are linearly separable (Exercise
3.1); the maximum-likelihood estimates for the coefficients are infinite.
The problem in this case is that the likelihood is trying to make the probabilities
all 1s and 0s, and inspection of (3.2) shows that this cannot be achieved
with finite parameters. Once we penalize the criterion as in (3.6) the problem
goes away, for as long as  > 0, very large coefficients will not be tolerated.
With wide data (N  p), the classes are almost always separable, unless
there are exact ties in covariate space for the two classes. Figure 3.1 shows the
logistic-regression coefficient path for a wide-data situation; notice how the
coefficients start to fan out near the end of the path. One has to take care at
this end of the path, and not allow  to get too small. In many situations, this
end represents the overfit situation, which is not of primary interest. It appears
not to be the case in this example, as can be seen in the cross-validation plots
in Figure 3.2.
The ends of the path have special meaning in the machine-learning community,
since we will see they amount to maximal-margin classifiers. Before
giving the details, we review some geometry associated with linear classification.
Consider the boundary B := {x 2 Rp | f(x) = 0} associated with a
linear classifier f(x)  f(x ; 0, ) = 0 + T x. The Euclidean distance from
a point x0 to the boundary is given by
dist2(x0, B) := inf
z2B kz − x0k2 = |f(x0)|
kk2
(3.35)
(Exercise 3.2). Consequently, for a given predictor-response pair (x, y), the
quantity y f(x)
kk2 is the signed Euclidean distance to the boundary: it will be
negative if the sign of y disagrees with that of f(x). For separable data, the
optimal separating hyperplane f(x) = 0 solves the optimization problem
M
2 = max
0,

min
i2{1,...,N}
yif(xi ; 0, )
kk2

. (3.36)
In words, it maximizes the Euclidean distance of the closest sample to the
boundary.
Rosset et al. (2004) establish an interesting connection between this optimal
separating hyperplane and a certain limiting case of ridge-regularized
logistic regression. In particular, suppose that we replace the `1-penalty in the
objective (3.10) with a squared `2-penalty, and solve the problem
minimize
0,
(
1
N
XN
i=1
log(1 + e−yif(xi ;0,)) + kk22
)
; (3.37)
let ( ˜ 0(), ˜ ()) be the optimal solution, specifying a particular linear classifier.
We then consider the behavior of this linear classifier as the regularization
50 GENERALIZED LINEAR MODELS
weight  vanishes: in particular, it can be shown (Rosset et al. 2004) that
lim
!0

min
i2{1,...,N}
yif(xi; ˜ 0(), ˜ ())
k˜ ()k2

= M
2 . (3.38)
Thus, the end of the `2-regularized logistic regression path corresponds to the
SVM solution. In particular, if ( ˘ 0, ˘ ) solves the SVM objective (3.30) with
C = 0, then
lim
!0
˜ ()
k˜ ()k2
= ˘ . (3.39)
How does this translate to the setting of `1-regularized models? Matters get
a little more complicated, since we move into the territory of general projections
and dual norms (Mangasarian 1999). The analog of the `2-distance (3.35)
is the quantity
dist1(x0, B) := inf
z2B kz − x0k1 = |f(x0)|
kk1
, (3.40)
For a given   0, let (b0(), b()) denote an optimal solution to the `1-
regularized logistic regression objective (3.10). Then as  decreases toward
zero, we have
lim
!0
"
min
i2{1,...,N}
yif(xi; b0(), b())
kb()k1
#
= M1
, (3.41)
so that the worst-case margin of the `1-regularized logistic regression converges
to the `1-regularized version of the support vector machine, which maximizes
the `1 margin (3.40).
In summary, then, we can make the following observations:
• At the end of the path, where the solution is most dense, the logistic regression
solution coincides with the SVM solution.
• The SVM approach leads to a more stable numerical method for computing
the solution in this region.
• In contrast, logistic regression is most useful in the sparser part of the
solution path.
3.7 Computational Details and glmnet
Most of the examples in this chapter were fit using the R package glmnet
(Friedman et al. 2015). Here we detail some of the options and features in
glmnet. Although these are specific to this package, they also would be natural
requirements in any other similar software.
COMPUTATIONAL DETAILS AND GLMNET 51
Family: The family option allows one to pick the loss-function and the associated
model. As of version 1.7, these are gaussian, binomial, multinomial
(grouped or not), poisson, and cox. The gaussian family allows for multiple
responses (multitask learning), in which case a group lasso is used to select
coefficients for each variable, as in the grouped multinomial. Associated with
each family is a deviance measure, the analog of the residual sum-of-squares
for Gaussian errors. Denote by ˆμ the N-vector of fitted mean values when
the parameter is , and ˜μ the unrestricted or saturated fit. Then
Dev
.=
2[`(y, ˜μ) − `(y, ˆμ)]. (3.42)
Here `(y,μ) is the log-likelihood of the model μ, a sum of N terms. The null
deviance is Devnull = Dev1; typically this means ˆμ1 = ¯y1, or in the case of
the cox family ˆμ1 = 0. Glmnet reports D2, the fraction of deviance explained,
as defined in (3.11) on page 33.
Penalties: For all models, the glmnet algorithm admits a range of elastic-net
penalties ranging from `2 to `1. The general form of the penalized optimization
problem is
minimize
0,
8<
:−
1
N
`(y; 0, ) + 
Xp
j=1

j

(1 − )2
j + |j |
	
9=
;. (3.43)
This family of penalties is specified by three sets of real-valued parameters:
• The parameter  determines the overall complexity of the model. By default,
the glmnet algorithm generates a sequence of 100 values for  that
cover the whole path (on the log scale), with care taken at the lower end
for saturated fits.
• The elastic-net parameter  2 [0, 1] provides a mix between ridge regression
and the lasso. Although one can select  via cross-validation, we typically
try a course grid of around three to five values of .
• For each j = 1, 2, . . . , p, the quantity 
j  0 is a penalty modifier. When

j = 0, the jth variable is always included; when 
j = inf it is always
excluded. Typically 
j = 1 (the default), and all variables are treated as
equals.
Coefficient bounds: With coordinate descent, it is very easy to allow for upper
and lower bounds on each coefficient in the model. For example, we might ask
for a nonnegative lasso. In this case, if a coefficient exceeds an upper or lower
bound during the coordinate-descent cycle, it is simply set to the bound.
Offset: All the models allow for an offset term. This is a real valued number
oi for each observation, that gets added to the linear predictor, and is not
associated with any parameter:
(xi) = oi + 0 + T xi. (3.44)
52 GENERALIZED LINEAR MODELS
The offset has many uses. Sometimes we have a previously-fit model h(z)
(where z might include or coincide with x), and we wish to see if augmenting
it with a linear model offers improvement. We would supply oi = h(zi) for
each observation.
For Poisson models the offset allows us to model rates rather than mean
counts, if the observation period differs for each observation. Suppose we observe
a count Y over period t, then E[Y | T = t,X = x] = tμ(x), where μ(x)
is the rate per unit time. Using the log link, we would supply oi = log(ti) for
each observation. See Section 3.4.1 for an example.
Matrix input and weights: Binomial and multinomial responses are typically
supplied as a 2 or K-level factor. As an alternative glmnet allows the response
to be supplied in matrix form. This allows for grouped data, where at each
xi we see a multinomial sample. In this case the rows of the N × K response
matrix represent counts in each category. Alternatively the rows can be proportions
summing to one. For the latter case, supplying an observation weight
equal to the total count for each observation is equivalent to the first form.
Trivially an indicator response matrix is equivalent to supplying the data as
a factor, in ungrouped form.
Sparse model matrices X: Often when p  N is very large, there are many
zeros in the input matrix X. For example, in document models, each feature
vector xi 2 Rp might count the number of times each word in a very large
dictionary occurs in a document. Such vectors and matrices can be stored
efficiently by only storing the nonzero values, and then row and column indices
of where they occur. Coordinate descent is ideally suited to capitalize on
such sparsity, since it handles the variables one-at-a-time, and the principal
operation is an inner-product. For example, in Section 3.4.1, the model-matrix
X = I is the extremely sparse N × N identity matrix. Even with N = 106,
the program can compute the relaxation path at 100 values of  in only 27
seconds.
Bibliographic Notes
Generalized linear models were proposed as a comprehensive class of models
by Nelder and Wedderburn (1972); see the book by McCullagh and Nelder
(1989) for a thorough account. Application of the lasso to logistic regression
was proposed in Tibshirani (1996); coordinate descent methods for logistic,
multinomial, and Poisson regression were developed in Friedman, Hastie, Hoefling
and Tibshirani (2007), Friedman, Hastie and Tibshirani (2010b), Wu and
Lange (2008), and Wu, Chen, Hastie, Sobel and Lange (2009). Pre-validation
was proposed by Tibshirani and Efron (2002). Boser, Guyon and Vapnik
(1992) described the support vector machine, with a thorough treatment in
Vapnik (1996).
EXERCISES 53
Exercises
Ex. 3.1 Consider a linear logistic regression model with separable data, meaning
that the data can be correctly separated into two classes by a hyperplane.
Show that the likelihood estimates are unbounded, and that the log-likelihood
objective reaches its maximal value of zero. Are the fitted probabilities welldefined?
Ex. 3.2 For a response variable y 2 {−1, +1} and a linear classification function
f(x) = 0 + T x, suppose that we classify according to sign(f(x)). Show
that the signed Euclidean distance of the point x with label y to the decision
boundary is given by
1
kk2
y f(x). (3.45)
Ex. 3.3 Here we show that for the multinomial model, the penalty used automatically
imposes a normalization on the parameter estimates. We solve this
problem for a general elastic-net penalty (Section 4.2). For some parameter
 2 [0, 1] consider the problem
cj() = arg min
t2R
(
XK
`=1
1
2(1 − )(j` − t)2 + |j` − t|
)
. (3.46)
Let ¯ j = 1
K
PK
`=1 j` be the sample mean, and let ˜ j be a sample median.
(For simplicity, assume that ¯ j  ˜ j ). Show that
¯ j  cj()  ˜ j for all  2 [0, 1] (3.47)
with the lower inequality achieved if  = 0, and the upper inequality achieved
if  = 1.
Ex. 3.4 Derive the Lagrange dual (3.25) of the maximum-entropy problem
(3.24). Note that positivity is automatically enforced, since the log function
in the objective (3.24) serves as a barrier. (Hint: It may help to introduce
additional variables wi = pi − ri, and now minimize the criterion (3.24)
with respect to both {pi,wi}Ni
=1, subject to the additional constraints that
wi = pi − ri.)
Ex. 3.5 Recall the dual (3.25) of the maximum entropy problem, and the
associated example motivating it. Suppose that for each cell, we also measure
the value xk corresponding to the mid-cell ordinate on the continuous domain
x. Consider the model
qk = uke0+
PM
m=1 mxm
k +k , (3.48)
and suppose that we fit it using the penalized log-likelihood (3.25) without
penalizing any of the coefficients. Show that for the estimated distribution
ˆq = {ˆqk}Nk
=1, the moments of X up to order M match those of the empirical
distribution r = {rk}Nk
=1.
54 GENERALIZED LINEAR MODELS
Ex. 3.6 Consider the group-lasso-regularized version of multinomial regression
(3.20). Suppose that for a particular value of , the coefficient bkj is
not equal to 0. Show that b`j 6= 0 for all ` 2 (1, . . . ,K), and moreover that PK
`=1
b`j = 0.
Ex. 3.7 This problem also applies to the group-lasso-regularized form of multinomial
regression (3.20). Suppose that for a particular value of , and the
fitted probabilities are ˆi = (ˆi1, . . . , ˆiK)T . Similarly let ri = (ri1, . . . , riK)T
be the observed proportions. Suppose we consider including an additional
variable (vector) Z with observed values zi, and wish to update the fit. Let
g = PN
i=1 zi(ri − ˆi). Show that if kgk2 < , then the coefficients of Z are
zero, and the model remains unchanged.
Ex. 3.8 The squared hinge loss function sqh(t) := (1 − t)2
+ can be used as a
margin-based loss function (y f(x)) for binary classification problems.
(a) Show that sqh is differentiable everywhere.
(b) Suppose Y 2 {−1, +1} with Pr(Y = +1) =  2 (0, 1). Find the function
f : Rp ! R that minimizes (for each x 2 Rp) the criterion
minimize
f
EY

sqh
􀀀
Y f(x)

(3.49)
(c) Repeat part (b) using the usual hinge loss hin(t) = (1 − t)+.
Ex. 3.9 Given binary responses yi 2 {−1, +1}, consider the `1-regularized
SVM problem
(b0, b) = arg min
0, 
8<
:
XN
i=1 {1 − yif(xi ; 0, )}+ + 
Xp
j=1 |j |
9=
;, (3.50)
where f(x ; 0, ) := 0 + T x. In this exercise, we compare solutions of this
problem to those of weighted `2-regularized SVM problem: given nonnegative
weights {wj}p
j=1, we solve
( ˜ 0, ˜ ) = arg min
0, 
8<
:
XN
i=1 {1 − yif(xi ; 0, )}+ + 
2
Xp
j=1
wj2
j
9=
;. (3.51)
(a) Show that if we solve the problem (3.51) with wj = 1/|bj |, then ( ˜ 0, ˜ ) =
(b0, b).
(b) For a given weight sequence {wj}p
j=1 with wj 2 (0,1) for all j = 1, . . . , p,
show how to solve the criterion (3.51) using a regular unweighted SVM
solver. What do you do if wj = 1 for some subset of indices?
(c) In light of the preceding parts, suggest an iterative algorithm for the
problem (3.50) using a regular SVM solver.
Chapter 4
Generalizations of the Lasso Penalty
4.1 Introduction
In the previous chapter, we considered some generalizations of the lasso obtained
by varying the loss function. In this chapter, we turn to some useful
variations of the basic lasso `1-penalty itself, which expand the scope of the
basic model. They all inherit the two essential features of the standard lasso,
namely the shrinkage and selection of variables, or groups of variables.
Such generalized penalties arise in a wide variety of settings. For instance,
in microarray studies, we often find groups of correlated features, such as genes
that operate in the same biological pathway. Empirically, the lasso sometimes
does not perform well with highly correlated variables. By combining a squared
`2-penalty with the `1-penalty, we obtain the elastic net, another penalized
method that deals better with such correlated groups, and tends to select the
correlated features (or not) together. In other applications, features may be
structurally grouped. Examples include the dummy variables that are used
to code a multilevel categorical predictor, or sets of coefficients in a multiple
regression problem. In such settings, it is natural to select or omit all the
coefficients within a group together. The group lasso and the overlap group
lasso achieve these effects by using sums of (un-squared) `2 penalties. Another
kind of structural grouping arises from an underlying index set such as time;
our parameters might each have an associated time stamp. We might then ask
for time-neighboring coefficients to be the same or similar. The fused lasso is
a method naturally tailored to such situations.
Finally, a variety of nonparametric smoothing methods operate implicitly
with large groups of variables. For example, each term in an additive
smoothing-spline model has an associated cubic-spline basis. The grouped
lasso extends naturally to these situations as well; the COSSO and the SPAM
families are examples of such nonparametric models. In summary, all these
variants deal with different kinds of groupings of the features in natural ways,
and it is the goal of this chapter to explore them in some more detail.
55
56 GENERALIZATIONS OF THE LASSO PENALTY
4.2 The Elastic Net
The lasso does not handle highly correlated variables very well; the coefficient
paths tend to be erratic and can sometimes show wild behavior. Consider a
simple but extreme example, where the coefficient for a variable Xj with a
particular value for  is bj > 0. If we augment our data with an identical
copy Xj0 = Xj , then they can share this coefficient in infinitely many ways—
any ˜ j + ˜ j0 = ˆ j with both pieces positive—and the loss and `1 penalty
are indifferent. So the coefficients for this pair are not defined. A quadratic
penalty, on the other hand, will divide ˆ j exactly equally between these two
twins (see Exercise 4.1). In practice, we are unlikely to have an identical
0 1 2 3 4
−1.5 −0.5 0.0 0.5 1.0 1.5
0 2 2 5 5
0 1 2 3 4
−1.5 −0.5 0.0 0.5 1.0 1.5
0 3 6 6 6
k kˆk1 ˆ k1
Coefficients ˆ j
Coefficients ˆ j
 = 1.0  = 0.3
Figure 4.1 Six variables, highly correlated in groups of three. The lasso estimates
( = 1), as shown in the left panel, exhibit somewhat erratic behavior as the regularization
parameter  is varied. In the right panel, the elastic net with ( = 0.3)
includes all the variables, and the correlated groups are pulled together.
pair of variables, but often we do have groups of very correlated variables. In
microarray studies, groups of genes in the same biological pathway tend to be
expressed (or not) together, and hence measures of their expression tend to
be strongly correlated. The left panel of Figure 4.1 shows the lasso coefficient
path for such a situation. There are two sets of three variables, with pairwise
correlations around 0.97 in each group. With a sample size of N = 100, the
data were simulated as follows:
Z1, Z2  N(0, 1) independent,
Y = 3 · Z1 − 1.5Z2 + 2", with "  N(0, 1),
Xj = Z1 + j/5, with j  N(0, 1) for j = 1, 2, 3, and
Xj = Z2 + j/5, with j  N(0, 1) for j = 4, 5, 6.
(4.1)
As shown in the left panel of Figure 4.1, the lasso coefficients do not reflect
the relative importance of the individual variables.
THE ELASTIC NET 57
The elastic net makes a compromise between the ridge and the lasso penalties
(Zou and Hastie 2005); it solves the convex program
minimize
(0,)2R×Rp
(
1
2
XN
i=1
(yi − 0 − xTi
)2 + 
h
1
2 (1 − )kk22
+ kk1
i)
, (4.2)
where  2 [0, 1] is a parameter that can be varied. By construction, the
penalty applied to an individual coefficient (disregarding the regularization
weight  > 0) is given by
1
2(1 − )2
j + |j |. (4.3)
When  = 1, it reduces to the `1-norm or lasso penalty, and with  = 0, it
reduces to the squared `2-norm, corresponding to the ridge penalty.1
Returning to Figure 4.1, the right-hand panel shows the elastic-net coefficient
path with  = 0.3. We see that in contrast to the lasso paths in the left
panel, the coefficients are selected approximately together in their groups, and
also approximately share their values equally. Of course, this example is idealized,
and in practice the group structure will not be so cleanly evident. But
by adding some component of the ridge penalty to the `1-penalty, the elastic
net automatically controls for strong within-group correlations. Moreover, for
any  < 1 and  > 0, the elastic-net problem (4.2) is strictly convex: a unique
solution exists irrespective of the correlations or duplications in the Xj .
Figure 4.2 compares the constraint region for the elastic net (left image) to
that of the lasso (right image) when there are three variables. We see that the
elastic-net ball shares attributes of the `2 ball and the `1 ball: the sharp corners
and edges encourage selection, and the curved contours encourage sharing of
coefficients. See Exercise 4.2 for further exploration of these properties.
The elastic net has an additional tuning parameter  that has to be determined.
In practice, it can be viewed as a higher-level parameter, and can
be set on subjective grounds. Alternatively, one can include a (coarse) grid of
values of  in a cross-validation scheme.
The elastic-net problem (4.2) is convex in the pair (0, ) 2 R × Rp, and
a variety of different algorithms can be used to solve it. Coordinate descent is
particularly effective, and the updates are a simple extension of those for the
lasso in Chapter 2. We have included an unpenalized intercept in the model,
which can be dispensed with at the onset; we simply center the covariates
xij , and then the optimal intercept is b0 = ¯y = 1
N
PN
j=1 yj . Having solved for
the optimal b0, it remains to compute the optimal vector b = (b1, . . . , bp). It
can be verified (Exercise 4.3) that the coordinate descent update for the jth
1The 12
in the quadratic part of the elastic-net penalty (4.3) leads to a more intuitive
soft-thresholding operator in the optimization.
58 GENERALIZATIONS OF THE LASSO PENALTY
2
1
3
1
1
2
3
1
Figure 4.2 The elastic-net ball with  = 0.7 (left panel) in R3, compared to the
`1 ball (right panel). The curved contours encourage strongly correlated variables to
share coefficients (see Exercise 4.2 for details).
coefficient takes the form
bj = S
􀀀PN
i=1 rijxij

PN
i=1 x2
ij + (1 − ) , (4.4)
where Sμ
􀀀
z

:= sign(z) (z − μ)+ is the soft-thresholding operator, and
rij := yi − b0 −
P
k6=j xik bk is the partial residual. We cycle over the updates
(4.4) until convergence. Friedman et al. (2015) give more details, and
provide an efficient implementation of the elastic net penalty for a variety of
loss functions.
4.3 The Group Lasso
There are many regression problems in which the covariates have a natural
group structure, and it is desirable to have all coefficients within a group
become nonzero (or zero) simultaneously. The various forms of group lasso
penalty are designed for such situations. A leading example is when we have
qualitative factors among our predictors. We typically code their levels using a
set of dummy variables or contrasts, and would want to include or exclude this
group of variables together. We first define the group lasso and then develop
this and other motivating examples.
Consider a linear regression model involving J groups of covariates, where
for j = 1, . . . , J, the vector Zj 2 Rpj represents the covariates in group j.
Our goal is to predict a real-valued response Y 2 R based on the collection of
covariates (Z1, . . . ,ZJ ). A linear model for the regression function E(Y | Z)
THE GROUP LASSO 59
takes the form 0 + PJ
j=1 ZT
j j , where j 2 Rpj represents a group of pj
regression coefficients.2
Given a collection of N samples {(yi, zi1, zi,2, . . . , zi,J )}Ni
=1, the group lasso
solves the convex problem
minimize
02R,j2R
pj
8<
:
1
2
XN
i=1
􀀀
yi − 0 −
XJ
j=1
zT
ijj
2 + 
XJ
j=1 kjk2
9=
;, (4.5)
where kjk2 is the Euclidean norm of the vector j .
This is a group generalization of the lasso, with the properties:
• depending on   0, either the entire vector ˆj will be zero, or all its
elements will be nonzero;3
• when pj = 1, then we have kjk2 = |j |, so if all the groups are singletons,
the optimization problem (4.5) reduces to the ordinary lasso.
Figure 4.3 compares the constraint region for the group lasso (left image) to
that of the lasso (right image) when there are three variables. We see that the
group lasso ball shares attributes of both the `2 and `1 balls.
1
3
2
1
1
2
3
1
Figure 4.3 The group lasso ball (left panel) in R3, compared to the `1 ball (right
panel). In this case, there are two groups with coefficients 1 = (1, 2) 2 R2 and
2 = 3 2 R1.
In the formulation (4.5), all groups are equally penalized, a choice which
leads larger groups to be more likely to be selected. In their original proposal,
Yuan and Lin (2006) recommended weighting the penalties for each
group according to their size, by a factor ppj . In their case, the group matrices
Zj were orthonormal; for general matrices one can argue for a factor
2To avoid confusion, we use Zj and j to represent groups of variables and their coefficients,
rather than the Xj and j we have used for scalars.
3Nonzero for generic problems, although special structure could result in some coefficients
in a group being zero, just as they can for linear or ridge regression.
60 GENERALIZATIONS OF THE LASSO PENALTY
kZjkF (Exercise 4.5). These choices are somewhat subjective, and are easily
accommodated; for simplicity, we omit this modification in our presentation.
We now turn to some examples to illustrate applications of the group
lasso (4.5).
Example 4.1. Regression with multilevel factors. When a predictor variable
in a linear regression is a multilevel factor, we typically include a separate
coefficient for each level of the factor. Take the simple case of one continuous
predictor X and a three-level factor G with levels g1, g2, and g3. Our linear
model for the mean is
E(Y | X,G) = X +
X3
k=1
k Ik[G], (4.6)
where Ik[G] is a 0-1 valued indicator function for the event {G = gk}. The
model (4.6) corresponds to a linear regression in X with different intercepts
k depending on the level of G.
By introducing a vector Z = (Z1,Z2,Z3) of three dummy variables with
Zk = Ik[G], we can write this model as a standard linear regression
E(Y | X,G) = E(Y | X,Z) = X + ZT , (4.7)
where  = (1, 2, 3). In this case Z is a group variable that represents the
single factor G. If the variable G—as coded by the vector Z—has no predictive
power, then the full vector  = (1, 2, 3) should be zero. On the other hand,
when G is useful for prediction, then at least generically, we expect that all
coefficients of  are likely to be nonzero. More generally we can have a number
of such single and group variables, and so have models of the form
E(Y | X,G1, . . . ,GJ ) = 0 + XT  +
XJ
j=1
ZT
j j . (4.8)
When selecting variables for such a model we would typically want to include
or exclude groups at a time, rather than individual coefficients, and the group
lasso is designed to enforce such behavior.
With unpenalized linear regression with factors, one has to worry about
aliasing; in the example here, the dummy variables in a set add to one, which is
aliased with the intercept term. One would then use contrasts to code factors
that enforce, for example, that the coefficients in a group sum to zero. With
the group lasso this is not a concern, because of the `2 penalties. We use the
symmetric full representation as above, because the penalty term ensures that
the coefficients in a group sum to zero (see Exercise 4.4). }
Variables can be grouped for other reasons. For example, in gene-expression
arrays, we might have a set of highly correlated genes from the same biological
pathway. Selecting the group amounts to selecting a pathway. Figure 4.4 shows
the coefficient path for a group-lasso fit to some genomic data for splice-site
THE GROUP LASSO 61
detection (Meier, van de Geer and B¨uhlmann 2008, Section 5). The data arise
from human DNA, and each observation consists of seven bases with values
{A, G,C, T}7. Some of the observations are at exon-intron boundaries (splice
sites), and others not, coded in a binary response; see Burge and Karlin (1977)
for further details about these data. The regression problem is to predict the
binary response Y using the seven four-level factors Gj as predictors, and we
use a training sample of 5610 observations in each class.
Group Lasso
Coefficients
0.16 0.14 0.12 0.1 0.08 0.06 0.04 0.02 0
−0.1 0.0 0.1 0.2
t
a
a
a
c
c
Pos7
Pos2
Pos5
Pos4
Pos3
Pos6

Figure 4.4 Coefficient profiles from the group lasso, fit to splice-site detection data.
The coefficients come in groups of four, corresponding to the nucleotides A, G,C, T.
The vertical lines indicate when a group enters. On the right-hand side we label some
of the variables; for example, “Pos6” and the level “c”. The coefficients in a group
have the same color, and they always average zero.
Example 4.2. Multivariate regression. Sometimes we are interested in predicting
a multivariate response Y 2 RK on the basis of a vector X 2 Rp of predictors
(also known as multitask learning). Given N observations {(yi, xi)}Ni
=1,
we let Y 2 RN×K and X 2 RN×p be matrices with yi and xi, respectively, as
their ith row. If we assume a linear model for the full collection of data, then
it can be written in the form
Y = X + E (4.9)
where  2 Rp×K is a matrix of coefficients, and E 2 RN×K a matrix of errors.
One way to understand the model (4.9) is as a coupled collection of K
standard regression problems in Rp, each sharing the same covariates, in which
62 GENERALIZATIONS OF THE LASSO PENALTY
the kth column k 2 Rp of  is the coefficient vector for the kth problem. Thus,
in principle, we could fit a separate regression coefficient vector k for each
of the K different problems, using the lasso in the case of a sparse linear
model. In many applications, the different components of the response vector
Y 2 RK are strongly related, so that one would expect that the underlying
regression vectors would also be related. For instance, in collaborative filtering
applications, the different components of Y might represent a given user’s
preference scores for different categories of objects, such as books, movies,
music, and so on, all of which are closely related. For this reason, it is natural—
and often leads to better prediction performance—to solve the K regression
problems jointly, imposing some type of group structure on the coefficients.
In another example, each response might be the daily return of an equity
in a particular market sector; hence we have multiple equities, and all being
predicted by the same market signals.
As one example, in the setting of sparsity, we might posit that there is
an unknown subset S  {1, 2, . . . , p} of the covariates that are relevant for
prediction, and this same subset is preserved across all K components of the
response variable. In this case, it would be natural to consider a group lasso
penalty, in which the p groups are defined by the rows {0j 2 RK, j = 1, . . . , p} of the full coefficient matrix  2 Rp×K. Using this penalty, we then solve the
regularized least-squares problem
minimize
2Rp×K
8<
:
12
kY − Xk2
F + 
0
@
Xp
j=1 k0
j k2
1
A
9=
;, (4.10)
where k · kF denotes the Frobenius norm.4 This problem is a special case of
the general group lasso (4.5), in which J = p, and pj = K for all groups j. }
4.3.1 Computation for the Group Lasso
Turning to computational issues associated with the group lasso, let us rewrite
the relevant optimization problem (4.5) in a more compact matrix-vector notation:
minimize
(1,...,J )
8<
:
1
2ky −
XJ
j=1
Zjjk22
+ 
XJ
j=1 kjk2
9=
;. (4.11)
For simplicity we ignore the intercept 0, since in practice we can center all
the variables and the response, and it goes away. For this problem, the zero
subgradient equations (see Section 5.2.2 take the form
−ZTj
(y −
XJ
`=1
Z`b`) + bsj = 0, for j = 1, · · · J, (4.12)
4The Frobenius norm of a matrix is simply the `2-norm applied to its entries.
THE GROUP LASSO 63
where bsj 2 Rpj is an element of the subdifferential of the norm k·k2 evaluated
at bj . As verified in Exercise 5.5 on page 135, whenever bj 6= 0, then we
necessarily have bsj = bj/kbjk2, whereas when bj = 0, then bsj is any vector
with kbsjk2  1. One method for solving the zero subgradient equations is by
holding fixed all block vectors {bk, k 6= j}, and then solving for bj . Doing so
amounts to performing block coordinate descent on the group lasso objective
function. Since the problem is convex, and the penalty is block separable,
it is guaranteed to converge to an optimal solution (Tseng 1993). With all
{bk, k 6= j} fixed, we write
−ZTj
(rj − Zj bj) + bsj = 0, (4.13)
where rj = y −
P
k6=j Zkbk is the jth partial residual. From the conditions
satisfied by the subgradient bsj , we must have bj = 0 if kZTj
rjk2 < , and
otherwise the minimizer bj must satisfy
bj =
 
ZTj
Zj + 
kbjk2
I
!−1
ZTj
rj . (4.14)
This update is similar to the solution of a ridge regression problem, except that
the underlying penalty parameter depends on kbjk2. Unfortunately, Equation
(4.14) does not have a closed-form solution for bj unless Zj is orthonormal.
In this special case, we have the simple update
bj =
 
1 −

kZTj
rjk2
!
+
ZTj
rj , (4.15)
where (t)+ := max{0, t} is the positive part function. See Exercise 4.6 for
further details.
Although the original authors (Yuan and Lin 2006) and many others since
have made the orthonormality assumption, it has implications that are not
always reasonable (Simon and Tibshirani 2012). Exercise 4.8 explores the impact
of this assumption on the dummy coding used here for factors. In the
general (nonorthonormal case) one has to solve (4.14) using iterative methods,
and it reduces to a very simple one-dimensional search (Exercise 4.7).
An alternative approach is to apply the composite gradient methods of
Section 5.3.3 to this problem. Doing so leads to an algorithm that is also
iterative within each block; at each iteration the block-optimization problem
is approximated by an easier problem, for which an update such as (4.15) is
possible. In detail, the algorithm would iterate until convergence the updates
!   bj +  · ZTj
(rj − Zj bj), and (4.16a)
bj  

1 −

k!k2

+
!, (4.16b)
where  is a step-size parameter. See Exercise 4.9 for details of this derivation.
64 GENERALIZATIONS OF THE LASSO PENALTY
4.3.2 Sparse Group Lasso
When a group is included in a group-lasso fit, all the coefficients in that group
are nonzero. This is a consequence of the `2 norm. Sometimes we would like
sparsity both with respect to which groups are selected, and which coefficients
are nonzero within a group. For example, although a biological pathway may
be implicated in the progression of a particular type of cancer, not all genes
in the pathway need be active. The sparse group lasso is designed to achieve
such within-group sparsity.
In order to achieve within-group sparsity, we augment the basic group
lasso (4.11) with an additional `1-penalty, leading to the convex program
minimize
{j2R
pj }Jj
=1
8<
:
12
ky −
XJ
j=1
Zjjk22
+ 
XJ
j=1

(1 − )kjk2 + kjk1

9=
;, (4.17)
with  2 [0, 1]. Much like the elastic net of Section 4.2, the parameter 
creates a bridge between the group lasso ( = 0) and the lasso ( = 1).
Figure 4.5 contrasts the group lasso constraint region with that of the sparse
group lasso for the case of three variables. Note that in the two horizontal
axes, the constraint region resembles that of the elastic net.
1
3
2
1
3
2
1
1
Figure 4.5 The group lasso ball (left panel) in R3, compared to the sparse grouplasso
ball with  = 0.5 (right panel). Depicted are two groups with coefficients 1 =
(1, 2) 2 R2 and 2 = 3 2 R1.
Since the optimization problem (4.17) is convex, its optima are specified
by zero subgradient equations, similar to (4.13) for the group lasso. More
precisely, any optimal solution must satisfy the condition
−ZTj
(y −
XJ
`=1
Z`b`) + (1 − ) · bsj + btj = 0, for j = 1, · · · , J, (4.18)
where bsj 2 Rpj belongs to the subdifferential of the Euclidean norm at bj ,
THE GROUP LASSO 65
andbtj 2 Rpj belongs to the subdifferential of the `1-norm at bj ; in particular,
we have each btjk 2 sign(jk) as with the usual lasso.
We once again solve these equations via block-wise coordinate descent,
although the solution is a bit more complex than before. As in Equation (4.13),
with rj the partial residual in the jth coordinate, it can be seen that bj = 0
if and only if the equation
ZTj
rj = (1 − )bsj + btj (4.19)
has a solution with kbsjk2  1 and btjk 2 [−1, 1] for k = 1, . . . , pj . Fortunately,
this condition is easily checked, and we find that (Exercise 4.12)
bj = 0 if and only if kS
􀀀
ZTj
rj

k2  (1 − ), (4.20)
where S
􀀀
·

is the soft-thresholding operator applied here componentwise
to its vector argument ZTj
rj . Notice the similarity with the conditions
for the group lasso (4.13), except here we use the soft-thresholded gradient
S
􀀀
ZTj
rj

. Likewise, if ZTj
Zj = I, then as shown in Exercise 4.13, we have
bj =
 
1 −
(1 − )
kS
􀀀
ZTj
rj

k2
!
+
S
􀀀
ZTj
rj

. (4.21)
In the general case when the Zj are not orthonormal and we have checked
that bj 6= 0, finding bj amounts to solving the subproblem
minimize
j2R
pj
1
2krj − Zjjk22
+ (1 − )kjk2 + kjk1

. (4.22)
Here we can again use generalized gradient descent (Section (5.3.3)) to produce
a simple iterative algorithm to solve each block, as in Equation (4.16a). The
algorithm would iterate until convergence the sequence
!   bj +  · ZTj
(rj − Zj bj), and (4.23a)
j  
 
1 −
(1 − )
kS
􀀀
!

k2
!
+
S
􀀀
!

, (4.23b)
where  is the step size. See Exercise 4.10 for the details.
4.3.3 The Overlap Group Lasso
Sometimes variables can belong to more than one group: for example, genes
can belong to more than one biological pathway. The overlap group lasso is a
modification that allows variables to contribute to more than one group.
To gain some intuition, consider the case of p = 5 variables partitioned
into two groups, say of the form
Z1 = (X1,X2,X3), and Z2 = (X3,X4,X5). (4.24)
66 GENERALIZATIONS OF THE LASSO PENALTY
Here X3 belongs to both groups. The overlap group lasso simply replicates
a variable in whatever group it appears, and then fits the ordinary group
lasso as before. In this particular example, the variable X3 is replicated, and
we fit coefficient vectors 1 = (11, 12, 13) and 2 = (21, 22, 23) using the
group lasso (4.5), using a group penalty k1k2+k2k2. In terms of the original
variables, the coefficient b3 of X3 is given by the sum b3 = b13 + b21. As
a consequence, the coefficient b3 can be nonzero if either (or both) of the
coefficients b13 or b21 are nonzero. Hence, all else being equal, the variable X3
has a better chance of being included in the model than the other variables,
by virtue of belonging to two groups.
Rather than replicate variables, it is tempting to simply replicate the coefficients
in the group-lasso penalty. For instance, for the given grouping above,
with X = (X1, . . . ,X5), and  = (1, . . . , 5), suppose that we define
1 = (1, 2, 3), and 2 = (3, 4, 5), (4.25)
and then apply the group-lasso penalty k1k2+k2k2 as before. However, this
approach has a major drawback. Whenever b1 = 0 in any optimal solution,
then we must necessarily have b3 = 0 in both groups. Consequently, in this
particular example, the only possible sets of nonzero coefficients are {1, 2},
{4, 5}, and {1, 2, 3, 4, 5}; the original groups {1, 2, 3} and {3, 4, 5} are not considered
as possibilities, since if either group appears, then both groups must
appear.5 As a second practical point, the penalty in this approach is not separable,
and hence coordinate-descent algorithms may fail to converge to an
optimal solution (see Section 5.4 for more details).
Jacob, Obozinski and Vert (2009) recognized this problem, and hence proposed
the replicated variable approach (4.24) or overlap group lasso. For our
motivating example, the possible sets of nonzero coefficients for the overlap
group lasso are {1, 2, 3}, {3, 4, 5}, and {1, 2, 3, 4, 5}. In general, the sets of possible
nonzero coefficients always correspond to groups, or the unions of groups.
They also defined an implicit penalty on the original variables that yields the
replicated variable approach as its solution, which we now describe.
Denote by j 2 Rp a vector which is zero everywhere except in those
positions corresponding to the members of group j, and let Vj  Rp be the
subspace of such possible vectors. In terms of the original variables, X =
(X1, · · · ,Xp), the coefficient vector is given by the sum  = PJ
j=1 j , and
hence the overlap group lasso solves the problem
minimize
j2Vj j=1,...,J
8<
:
1
2



y − X
􀀀XJ
j=1
j



2
2 + 
XJ
j=1 kjk2
9=
;. (4.26)
This optimization problem can be re-cast in the terms of the original  vari-
5More generally, the replicated-variable approach always yields solutions in which the
sets of zero coefficients are unions of groups, so that the sets of nonzeros must be the
intersections of complements of groups.
THE GROUP LASSO 67
ables by defining a suitable penalty function. With

V() := inf
j2Vj
=
PJ
j=1 j
XJ
j=1 kjk2, (4.27)
it can then be shown (Jacob et al. 2009) that solving problem (4.26) is equivalent
to solving
minimize
2Rp
1
2ky − Xk22
+  
V()

. (4.28)
This equivalence is intuitively obvious, and underscores the mechanism underlying
this penalty; the contributions to the coefficient for a variable are
distributed among the groups to which it belongs in a norm-efficient manner.
Figure 4.6 contrasts the group lasso constraint region with that of the
overlap group lasso when there are three variables. There are two rings corresponding
to the two groups, with X2 in both groups.
1
3
2
1
1
3
2
1
Figure 4.6 The group-lasso ball (left panel) in R3, compared to the overlap-grouplasso
ball (right panel). Depicted are two groups in both. In the left panel the groups
are {X1,X2} and X3; in the right panel the groups are {X1,X2} and {X2,X3}.
There are two rings corresponding to the two groups in the right panel. When 2 is
close to zero, the penalty on the other two variables is much like the lasso. When 2
is far from zero, the penalty on the other two variables “softens” and resembles the
`2 penalty.
Example 4.3. Interactions and hierarchy. The overlap-group lasso can also be
used to enforce hierarchy when selecting interactions in linear models. What
this means is that interactions are allowed in the model only in the presence
of both of their main effects. Suppose Z1 represents the p1 dummy variables
for the p1 levels of factor G1; likewise Z2 the p2 dummy variables for G2. A
linear model with Z1 and Z2 is a main-effects model. Now let Z1:2 = Z1 ? Z2,
68 GENERALIZATIONS OF THE LASSO PENALTY
a p1 × p2 vector of dummy variables (the vector of all pairwise products).
Lim and Hastie (2014) consider the following formulation for a pair of such
categorical variables6
minimize
μ,,˜
8><
>:
1
2







y − μ1 − Z11 − Z22 − [Z1 Z2 Z1:2]
2
4
˜1
˜2
1:2
3
5







2
2
+

k1k2 + k2k2 +
q
p2k˜1k22
+ p1k˜2k22
+ k1:2k22

(4.29)
subject to the constraints
Xp1
i=1
i1
= 0,
Xp2
j=1
j2
= 0,
Xp1
i=1
˜i1
= 0,
Xp2
j=1
˜j2
= 0, (4.30)
Xp1
i=1
ij
1:2 = 0 for fixed j,
Xp2
j=1
ij
1:2 = 0 for fixed i. (4.31)
The summation constraints are standard in hierarchical ANOVA formulations.
Notice that the main effect matrices Z1 and Z2 each have two different coefficient
vectors j and ˜j , creating an overlap in the penalties, and their ultimate
coefficient is the sum j = j + ˜j . The
p
p2k˜1k22
+ p1k˜2k22
+ k1:2k22
term
results in estimates that satisfy strong hierarchy, because either b˜1 = b˜2 =
b1:2 = 0 or all are nonzero, i.e., interactions are always present with both
main effects. They show that the solution to the above constrained problem
(4.29)–(4.31) is equivalent to the solution to the simpler unconstrained problem
minimize
μ,
12
ky − μ1 − Z11 − Z22 − Z1:21:2k
22
+ (k1k2 + k2k2 + k1:2k2)} (4.32)
(Exercise 4.14). In other words, a linear model in Z1:2 is the full interaction
model (i.e., interactions with main effects implicitly included). A group lasso
in Z1, Z2, and Z1:2 will hence result in a hierarchical model; whenever Z1:2 is
in the model, the pair of main effects is implicitly included. In this case the
variables do not strictly overlap, but their subspaces do. A different approach
to the estimation of hierarchical interactions is the hierNet proposal of Bien,
Taylor and Tibshirani (2013). }
6This extends naturally to more than two pairs, as well as other loss functions, e.g.,
logistic regression, as well as interactions between factors and quantitative variables.
SPARSE ADDITIVE MODELS AND THE GROUP LASSO 69
4.4 Sparse Additive Models and the Group Lasso
Suppose we have a zero-mean response variable Y 2 R, and a vector of predictors
X 2 RJ , and that we are interested in estimating the regression function
f(x) = E(Y | X = x). It is well-known that nonparametric regression suffers
from the curse of dimensionality, so that approximations are essential. Additive
models are one such approximation, and effectively reduce the estimation
problem to that of many one-dimensional problems. When J is very large, this
may not be sufficient; the class of sparse additive models limits these approximations
further, by encouraging many of the components to be zero. Methods
for estimating sparse additive models are closely related to the group lasso.
4.4.1 Additive Models and Backfitting
We begin by introducing some background on the class of additive models,
which are based on approximating the regression function by sums of the form
f(x) = f(x1, . . . , xJ ) 
XJ
j=1
fj(xj), (4.33)
fj 2 Fj , j = 1, . . . , J,
where the Fj are a fixed set of univariate function classes. Typically, each Fj
is assumed to be a subset of L2(Pj) where Pj is the distribution of covariate
Xj , and equipped with the usual squared L2(Pj) norm kfjk22
:= E[f2
j (Xj )].
In the population setting, the best additive approximation to the regression
function E(Y |X = x), as measured in the L2(P) sense, solves the problem
minimize
fj2Fj , j=1,...,J
E
􀀀
Y −
XJ
j=1
fj(Xj)
2
. (4.34)
The optimal solution ( ˜ f1, . . . , ˜ fJ ) is characterized by the backfitting equations,
namely
˜ fj(xj) = E

Y −
X
k6=j
˜ fk(Xk) | Xj = xj

, for j = 1, . . . , J. (4.35)
More compactly, this update can be written in the form ˜ fj = Pj(Rj ), where Pj
is the conditional-expectation operator in the jth coordinate, and the quantity
Rj := Y −
P
k6=j
˜ fk(Xk) is the jth partial residual.
Given data {(xi, yi)}Ni
=1, a natural approach is to replace the population
operator Pj with empirical versions, such as scatterplot smoothers Sj , and
then solve a data-based version version of the updates (4.35) by coordinate
descent or backfitting (Hastie and Tibshirani 1990). Hence we repeatedly cycle
over the coordinates j = 1, . . . , J, and update each function estimate b fj using
70 GENERALIZATIONS OF THE LASSO PENALTY
the smooth of the partial residuals
b fj   Sj(y −
X
k6=j
bfk), j = 1, . . . , J, (4.36)
until the fitted functions b fj stabilize. In (4.36) bfk is the fitted function ˆ fk evaluated
at the N sample values (x1k, . . . , xNk). The operator Sj represents an
algorithm that takes a response vector r, smooths it against the vector xj , and
returns the function b fj . Although Sj will have its own tuning parameters and
bells and whistles, for the moment we regard it as a black-box that estimates
a conditional expectation using data.
4.4.2 Sparse Additive Models and Backfitting
An extension of the basic additive model is the notion of a sparse additive
model, in which we assume that there is a subset S  {1, 2, . . . , J} such that
the regression function f(x) = E(Y | X = x) satisfies an approximation of the
form f(x) 
P
j2S fj(xj ). Ravikumar, Liu, Lafferty and Wasserman (2009)
proposed a natural extension of the backfitting equations, motivated by a
sparse analog of the population level problem (4.34). For a given sparsity level
k 2 {1, . . . , J}, the best k-sparse approximation to the regression function is
given by
minimize
|S|=k
fj2Fj ,j=1,...,J
E

Y −
X
j2S
fj(Xj)
2
. (4.37)
Unfortunately, this criterion is nonconvex and computationally intractable,
due to combinatorial number—namely
􀀀J
k

—of possible subsets of size k.
Suppose that instead we measure the sparsity of an additive approximation
f = PJ
j=1 fj via the sum PJ
j=1 kfjk2, where we recall that kfjk2 = q
E[f2
j (Xj )] is the L2(Pj) norm applied to component j. For a given regularization
parameter   0, this relaxed notion defines an alternative type of
best sparse approximation, namely one that minimizes the penalized criterion
minimize
fj2Fj , j=1,...,J
8<
:E

Y −
XJ
j=1
fj(Xj)
2
+ 
XJ
j=1 kfjk2
9=
;. (4.38)
Since this objective is a convex functional of (f1, . . . , fJ ), Lagrangian duality
ensures that it has an equivalent representation involving an explicit constraint
on the norm PJ
j=1 kfjk2. See Exercise 4.15.
Ravikumar et al. (2009) show that any optimal solution ( ˜ f1, . . . , ˜ fJ ) to the
penalized problem (4.38) is characterized by the sparse backfitting equations
˜ fj =

1 −

kPj(Rj)k2

+ Pj(Rj), (4.39)
SPARSE ADDITIVE MODELS AND THE GROUP LASSO 71
where the residual Rj and the conditional expectation operator Pj were defined
in the text after the ordinary backfitting equations (4.35).
In parallel with our earlier development, given data {(xi, yi)}N1
, these
population-level updates suggest the natural data-driven analog, in which we
replace the population operator Pj with the scatterplot smoother Sj , and then
perform the updates
e fj = Sj
􀀀
y −
X
k6=j
bfk

, and b fj =

1 −

k˜f k2

+
e fj , (4.40)
for j = 1, . . . , J, again iterating until convergence. Figure 4.7 illustrates the
performance of the SPAM updates (4.40) on some air-pollution data. We use
smoothing-splines, with a fixed degree of freedom df = 5 for each coordinate
(Hastie and Tibshirani 1990).
0 50 150 250
−1.0 −0.5 0.0 0.5 1.0
rad
f(rad)
60 70 80 90
−1.0 −0.5 0.0 0.5 1.0
temp
f(temp)
5 10 15 20
−1.0 −0.5 0.0 0.5 1.0
wind
f(wind)
log(ozone) ~ s(rad) + s(temp) + s(wind)
Figure 4.7 A sequence of three SPAM models fit to some air-pollution data. The
response is the log of ozone concentration, and there are three predictors: radiation,
temperature, and wind speed. Smoothing splines were used in the additive model fits,
each with df = 5 The three curves in each plot correspond to  = 0 (black curves),
 = 2 (orange curves), and  = 4 (red curves). We see that while the shrinkage
leaves the functions of temp relatively untouched, it has a more dramatic effect on
rad and wind.
We can make a more direct connection with the grouped lasso if the
smoothing method for variable Xj is a projection on to a set of basis functions.
Consider
fj(·) =
Xpj
`=1
 j`(·)j`, (4.41)
where the { j`}pj
1 are a family of basis functions in Xj , such as cubic splines
with a collection of knots along the range of Xj . Let 	j be the N × pj
matrix of evaluations of the  j`, and assume that 	Tj
	j = Ipj . Then for
72 GENERALIZATIONS OF THE LASSO PENALTY
any coefficient vector j = (j1, . . . , jpj )T and corresponding fitted vector
fj = 	jj , we have kfjk2 = kjk2. In this case it is easy to show that the
updates (4.40) are equivalent to those for a group lasso with predictor matrix
	 :=

	1 	2 · · · 	J

and a corresponding block vector of coefficients
 :=

1 2 · · · J

(see Exercise 4.16 for more details).
4.4.3 Approaches Using Optimization and the Group Lasso
Although the population-level sparse backfitting equations (4.39) do solve an
optimization problem, in general, the empirical versions (4.40) do not, but
rather are motivated by analogy to the population version. We now discuss
the Component Selection and Smoothing Operator or COSSO for short, which
does solve a data-defined optimization problem. The COSSO method (Lin and
Zhang 2003) is a predecessor to the SPAM method, and operates in the world
of reproducing kernel Hilbert spaces, with a special case being the smoothing
spline model.
We begin by recalling the traditional form of an additive smoothing-spline
model, obtained from the optimization of a penalized objective function:
minimize
fj2Hj , j=1,...,J
8<
:
1
N
XN
i=1
(yi −
XJ
j=1
fj(xij))2 + 
XJ
j=1
1

j kfjk2
Hj
9=
;. (4.42)
Here kfjkHj is an appropriate Hilbert-space norm for the jth coordinate.
Typically, the Hilbert space Hj is chosen to enforce some type of smoothness,
in which context the parameter   0 corresponds to overall smoothness,
and the parameters 
j  0 are coordinate specific modifiers. For example, a
roughness norm for a cubic smoothing spline on [0, 1] is
kgk2
H :=
Z 1
0
g(t)dt
2
+
Z 1
0
g0(t)dt
2
+
Z 1
0
g00(t)2dt. (4.43)
When this particular Hilbert norm is used in the objective function (4.42),
each component b fj of the optimal solution is a cubic spline with knots at the
unique sample values of Xj . The solution can be computed by the backfitting
updates (4.36), where each Sj is a type of cubic spline smoother with penalty
/
j .
Instead of the classical formulation (4.42), the COSSO method is based on
the objective function
minimize
fj2Hj , j=1,...,J
8<
:
1
N
XN
i=1
(yi −
XJ
j=1
fj(xij))2 + 
XJ
j=1 kfjkHj
9=
;. (4.44)
As before, the penalties are norms rather than squared norms, and as such
result in coordinate selection for sufficiently large  . Note that, unlike the
SPARSE ADDITIVE MODELS AND THE GROUP LASSO 73
usual penalty for a cubic smoothing spline, the norm in (4.43) includes a
linear component; this ensures that the entire function is zero when the term
is selected out of the model, rather than just its nonlinear component. Despite
the similarity with the additive spline problem (4.38), the structure of the
penalty kfjkHj means that the solution is not quite as simple as the sparse
backfitting equations (4.40).
Equipped with the norm (4.43), the space Hj of cubic splines is a particular
instance of a reproducing-kernel Hilbert space (RKHS) on the unit interval
[0, 1]. Any such space is characterized by a symmetric positive definite kernel
function Rj : [0, 1] × [0, 1] ! R with the so-called reproducing property. In
particular, we are guaranteed for each x 2 [0, 1], the function Rj(·, x) is a
member of Hj , and moreover that hR(·, x), fiHj = f(x) for all f 2 Hj . Here
h·, ·iHj denotes the inner product on the Hilbert space Hj .
Using the reproducing property, it can be shown (Exercise 4.17) that the
jth coordinate function b fj in any optimal COSSO solution can be written in
the form b fj(·) = PN
i=1
bijRj(·, xij ), for a suitably chosen weight vector bj 2
RN. Moreover, it can be shown that b fj has Hilbert norm k b fjk2
Hj = b
T
j Rjbj ,
where Rj 2 RN×N is a Gram matrix defined by the kernel—in particular,
with entries (Rj)ii0 = Rj(xij , xi0j ). Consequently, the COSSO problem (4.44)
can be rewritten as a more general version of the group lasso: in particular, it
is equivalent to the optimization problem
minimize
j2RN, j=1,...,J
8<
:
1
N ky −
XJ
j=1
Rjjk22
+ 
XJ
j=1
q
Tj
Rjj
9=
;, (4.45)
as verified in Exercise 4.17.
We are now back in a parametric setting, and the solution is a more general
version of the group lasso (4.14). It can be shown that any optimal solution
(b1, . . . , bJ ) is specified by the fixed point equations
bj =
8>>><
>>>:
0 if
q
rTj
Rjrj < 
0
@Rj + q 
b
T
j Rjbj
I
1
A
−1
rj otherwise,
(4.46)
where rj := y−
P
k6=j Rkbk corresponds to the jth partial residual. Although
bj appears in both sides of the Equation (4.46), it can be solved with a onetime
SVD of Rj and a simple one-dimensional search; see Exercise 4.7 for the
details.
Lin and Zhang (2003) propose an alternative approach, based on introducing
a vector 
 2 RJ of auxiliary variables, and then considering the joint
74 GENERALIZATIONS OF THE LASSO PENALTY
optimization problem
minimize

0
fj2Hj , j=1,...J
8<
:
1
N
XN
i=1
(yi −
XJ
j=1
fj(xij))2 +
XJ
j=1
1

j kfjk2
Hj + 
XJ
j=1

j
9=
;.
(4.47)
As shown in Exercise 4.18, if we set  =  4/4 in the lifted problem (4.47), then
the b component of any optimal solution coincides with an optimal solution
of the original COSSO (4.44).
The reformulation (4.47) is useful, because it naturally leads to a convenient
algorithm that alternates between two steps:
• For 
j fixed, the problem is a version of our earlier objective (4.42), and
results in an additive-spline fit.
• With the fitted additive spline fixed, updating the vector of coefficients

 = (
1, . . . , 
J ) amounts to a nonnegative lasso problem. More precisely,
for each j = 1, . . . , J, define the vector gj = Rjj/
j 2 RN, where fj =
Rjj is the fitted vector for the jth function using the current value of 
j .
Then we update the vector 
 = (
1, . . . , 
J ) by solving
min

0
 1
N ky −G
k22
+ k
k1

, (4.48)
where G is the N×J matrix with columns {gj , j = 1, . . . , J}. These updates
are a slightly different form than that given in Lin and Zhang (2003); full
details are mapped out in Exercise 4.19.
When applied with the cubic smoothing-spline norm (4.43), the COSSO is
aimed at setting component functions fj to zero. There are many extensions
to this basic idea. For instance, given a univariate function g, we might instead
represent each univariate function in the form g(t) = 0+1t+h(t), and focus
the penalty on departures from linearity using the norm
khk2
H :=
Z 1
0
h00(t)2dt, (4.49)
In this setting, a variant of COSSO can select between nonlinear and linear
forms for each component function.
We discuss penalties for additive models further in Section 4.4.4, in particular
the benefits of using more than one penalty in this context.
4.4.4 Multiple Penalization for Sparse Additive Models
As we have seen thus far, there are multiple ways of enforcing sparsity for a
nonparametric problem. Some methods, such as the SPAM back-fitting proSPARSE
ADDITIVE MODELS AND THE GROUP LASSO 75
cedure, are based on a combination of the `1-norm with the empirical L2-
norm—namely, the quantity
kfkN,1 :=
XJ
j=1 kfjkN, (4.50)
where kfjk2
N := 1
N
PN
i=1 f2
j (xij) is the squared empirical L2-norm for the
univariate function fj .7 Other methods, such as the COSSO method, enforce
sparsity using a combination of the `1-norm with the Hilbert norm
kfkH,1 :=
XJ
j=1 kfjkHj . (4.51)
Which of these two different regularizers is to be preferred for enforcing sparsity
in the nonparametric setting?
Instead of focusing on only one regularizer, one might consider the more
general family of estimators
min
fj2Hj
j=1,...,J
8<
:
1
N
XN
i=1
(yi −
XJ
j=1
fj(xij))2 + H
XJ
j=1 kfjkHj + N
XJ
j=1 kfjkN
9=
;,
(4.52)
parametrized by the pair of nonnegative regularization weights (H, N). If we
set N = 0, then the optimization problem (4.52) reduces to the COSSO estimator,
whereas for H = 0, we obtain a method closely related to the SPAM
estimator. For any nonnegative (H, N), the optimization problem (4.52)
is convex. When the underlying univariate Hilbert spaces Hj are described
by a reproducing kernel, then the problem (4.52) can be re-formulated as a
second-order cone program, and is closely related to the group lasso. Whenever
the Hilbert space Hj is defined by a reproducing kernel Rj , then the
jth coordinate function b fj in any optimal solution again takes the form
b fj(·) = PN
i=1
bijRj(·, xij) for a vector of weights bj 2 RN. This fact allows
us to reduce the solution of the infinite-dimensional problem (4.52) to the
simpler problem
min
j2R
N
j=1,...,J
8<
:
1
N ky −
XJ
j=1
Rjjk22
+ H
XJ
j=1
q
Tj
Rjj + N
XJ
j=1
q
Tj
R2
j j
9=
;.
(4.53)
As before, for each coordinate j 2 {1, . . . , J}, the matrix Rj 2 RN×N is the
kernel Gram matrix, with entries [Rj ]ii0 = Rj(xij , xi0j ). See Exercise 4.20 for
more details on this reduction.
7kfjkN,1 is the same as the kfjk2 used in Section 4.4.2; here we are using a more generalizable
notation.
76 GENERALIZATIONS OF THE LASSO PENALTY
0 200 400 600 800 1000
−2 0 2 4
Genome order
log2 ratio
Figure 4.8 Fused lasso applied to CGH data. Each spike represents the copy number
of a gene in a tumor sample, relative to that of a control (on the log base-2 scale).
The piecewise-constant green curve is the fused lasso estimate.
The optimization problem (4.53) is an instance of a second-order cone
program, and can be solved efficiently by a variant of the methods previously
described. But why it is useful to impose two forms of regularization? As
shown by Raskutti, Wainwright and Yu (2012), the combination of these two
regularizers yields an estimator that is minimax-optimal, in that its convergence
rate—as a function of sample size, problem dimension, and sparsity—is
the fastest possible.
4.5 The Fused Lasso
Consider the gray spikes in Figure 4.8, the results of a comparative genomic
hybridization (CGH) experiment. Each of these represents the (log base 2) relative
copy number of a gene in a cancer sample relative to a control sample;
these copy numbers are plotted against the chromosome order of the gene.
These data are very noisy, so that some kind of smoothing is essential. Biological
considerations dictate that it is typically segments of a chromosome—
rather than individual genes—that are replicated, Consequently, we might expect
that the underlying vector of true copy numbers to be piecewise-constant
over contiguous regions of a chromosome. The fused lasso signal approximator
exploits such structure within a signal, and is the solution of the following
optimization problem
minimize
2RN
(
12
XN
i=1
(yi − i)2 + 1
XN
i=1 |i| + 2
XN
i=2 |i − i−1|
)
. (4.54)
THE FUSED LASSO 77
The first penalty is the familiar `1-norm, and serves to shrink the i toward
zero. Since the observation index i orders the data (in this case along the
chromosome), the second penalty encourages neighboring coefficients i to be
similar, and will cause some to be identical (also known as total-variation denoising).
Notice that (4.54) does not include a constant term 0; the coefficient
i represents the response yi directly, and for these kinds of problems zero is
a natural origin. (See Exercise 4.21 for further exploration of this intercept
issue.) The green curve in Figure 4.8 is fit to these data using the fused lasso.
There are more general forms of the fused lasso; we mention two here.
• We can generalize the notion of neighbors from a linear ordering to more
general neighborhoods, for examples adjacent pixels in an image. This leads
to a penalty of the form
2
X
ii0 |i − i0 |, (4.55)
where we sum over all neighboring pairs i  i0.
• In (4.54) every observation is associated with a coefficient. More generally
we can solve
minimize
(0,)2R×Rp
8<
:
1
2
XN
i=1
(yi − 0 −
Xp
j=1
xijj)2
+1
Xp
j=1 |j | + 2
Xp
j=2 |j − j−1|
9=
;. (4.56)
Here the covariates xij and their coefficients j are indexed along some
sequence j for which neighborhood clumping makes sense; (4.54) is clearly
a special case.
4.5.1 Fitting the Fused Lasso
Problem (4.54) and its relatives are all convex optimization problems, and
so all have well-defined solutions. As in other problems of this kind, here we
seek efficient path algorithms for finding solutions for a range of values for
the tuning parameters. Although coordinate descent is one of our favorite
algorithms for lasso-like problems, it need not work for the fused lasso (4.54),
because the difference penalty is not a separable function of the coordinates.
Consequently, coordinate descent can become “stuck” at a nonoptimal point as
illustrated in Figure 5.8 on page 111. This separability condition is discussed
in more detail in Section 5.4.
We begin by considering the structure of the optimal solution b(1, 2) of
the fused lasso problem (4.54) as a function of the two regularization parameters
1 and 2. The following result due to Friedman et al. (2007) provides
some useful insight into the behavior of this optimum:
78 GENERALIZATIONS OF THE LASSO PENALTY
Lemma 4.1. For any 0
1 > 1, we have
bi(0
1, 2) = S0
1−1
􀀀bi(1, 2)

for each i = 1, . . . ,N, (4.57)
where S is the soft-thresholding operator S
􀀀
z

:= sign(z)(|z| − )+.
One important special case of Lemma 4.1 is the equality
bi(1, 2) = S1
􀀀bi(0, 2)

for each i = 1, . . . ,N. (4.58)
Consequently, if we solve the fused lasso with 1 = 0, all other solutions
can be obtained immediately by soft thresholding. This useful reduction also
applies to the more general versions of the fused lasso (4.55). On the basis of
Lemma 4.1, it suffices to focus our attention on solving the problem8
minimize
2RN
(
1
2
XN
i=1
(yi − i)2 + 
XN
i=2 |i − i−1|
)
. (4.59)
We consider several approaches to solving (4.59).
4.5.1.1 Reparametrization
One simple approach is to reparametrize problem (4.59) so that the penalty
is additive. In detail, suppose that we consider a linear transformation of the
form 
 = M for an invertible matrix M 2 RN×N such that

1 = 1, and 
i = i − i−1 for i = 2, . . . ,N. (4.60)
In these transformed coordinates, the problem (4.59) is equivalent to the ordinary
lasso problem
minimize

2RN
1
2ky − X
k2 + k
k1

, with X = M−1. (4.61)
In principle, the reparametrize problem (4.61) can be solved using any efficient
algorithm for the lasso, including coordinate descent, projected gradient
descent or the LARS procedure. However, X is a lower-triangular matrix with
all nonzero entries equal to 1, and hence has large correlations among the
“variables.” Neither coordinate-descent nor LARS performs well under these
circumstances (see Exercise 4.22). So despite the fact that reparametrization
appears to solve the problem, it is not recommended, and more efficient algorithms
exist, as we now discuss.
8Here we have adopted the notation  (as opposed to 2) for the regularization parameter,
since we now have only one penalty.
THE FUSED LASSO 79
4.5.1.2 A Path Algorithm
The one-dimensional fused lasso (4.59) has an interesting property, namely
that as the regularization parameter  increases, pieces of the optimal solution
can only be joined together, not split apart. More precisely, letting b() denote
the optimal solution to the convex program (4.59) as a function of , we have:
Lemma 4.2. Monotone fusion. Suppose that for some value of  and some
index i 2 {1, . . . ,N − 1}, the optimal solution satisfies bi() = bi+1(). Then
for all 0 > , we also have bi(0) = bi+1(0).
Friedman et al. (2007) observed that this fact greatly simplifies the construction
of the fused lasso solution path. One starts with  = 0, for which
there are no fused groups, and then computes the smallest value of  that
causes a fused group to form. The parameter estimates for this group are then
fused together (i.e., constrained to be equal) for the remainder of the path.
Along the way, a simple formula is available for the estimate within each fused
group, so that the resulting procedure is quite fast, requiring O(N) operations.
However, we note that the monotone-fusion property in Lemma 4.2 is special
to the one-dimensional fused lasso (4.59). For example, it does not hold for the
general fused lasso (4.56) with a model matrix X, nor for the two-dimensional
fused lasso (4.55). See Friedman et al. (2007) and Hoefling (2010) for more
details on this approach.
4.5.1.3 A Dual Path Algorithm
Tibshirani2 and Taylor (2011) take a different approach, and develop path
algorithms for the convex duals of fused lasso problems. Here we illustrate
their approach on the problem (4.59), but note that their methodology applies
to the general problem (4.56) as well.
We begin by observing that problem (4.59) can be written in an equivalent
lifted form
minimize
(,z)2RN×RN−1
1
2ky − k22
+ kzk2

subject to D = z, (4.62)
where we have introduced a vector z 2 RN−1 of auxiliary variables, and D
is a (N − 1) × N matrix of first differences. Now consider the Lagrangian
associated with the lifted problem, namely
L(, z; u) := 12
ky − k22
+ kzk + uT (D − z), (4.63)
where u 2 RN−1 is a vector of Lagrange multipliers. A straightforward computation
shows that the Lagrangian dual function Q takes form
Q(u) := inf
(,z)2RN×RN−1
L(, z; u) =
(
−1
2ky − DTuk2 if kuk1  ,
−1 otherwise.
(4.64)
80 GENERALIZATIONS OF THE LASSO PENALTY
The Lagrangian dual problem is to maximize Q(u), and given an optimal
solution bu = bu(), we can recover an optimal solution b = b() to the original
problem by setting b = y − DT bu. See Exercise 4.23 for the details of these
duality calculations.
0.0 0.5 1.0 1.5
−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5
l
Dual Coordinates
0.0 0.5 1.0 1.5
−1.0 −0.5 0.0 0.5 1.0 1.5
l
Primal Coordinates
Figure 4.9 The dual path algorithm in action on a small example. The left panel
shows the progress of bu(), while the right panel shows b
(). We see that in the
dual coordinates, as a parameter hits the boundary, an unfusing occurs in the primal
coordinates.
When the regularization parameter  is sufficiently large, the dual maximization,
or equivalently the problem of minimizing −Q(u), reduces to an
unrestricted linear regression problem, with optimal solution
u := (DDT )−1Dy. (4.65)
The restrictions kick in when  decreases to the critical level kuk1.
Tibshirani2 and Taylor (2011) show that as we decrease , once elements
buj() of the optimal solution hit the bound , then they are guaranteed to
never leave the bound. This property leads to a very straightforward path
algorithm, similar in spirit to LARS in Section 5.6; see Figure 4.9 for an illustration
of the dual path algorithm in action. Exercise 4.23 explores some of
the details.
4.5.1.4 Dynamic Programming for the Fused Lasso
Dynamic programming is a computational method for solving difficult problems
by breaking them down into simpler subproblems. In the case of the
one-dimensional fused lasso, the linear ordering of the variables means that
THE FUSED LASSO 81
fixing any variable breaks down the problem into two separate subproblems
to the left and right of the fixed variable. In the “forward pass,” we move from
left to right, fixing one variable and solving for the variable to its left, as a
function of this fixed variable. When we reach the right end, a backward pass
then gives the complete solution.
Johnson (2013) proposed this dynamic programming approach to the fused
lasso. In more detail, we begin by separating off terms in (4.59) that depend
on 1, and rewrite the objective function (4.59) in the form
f() = 12
(y1 − 1)2 + |2 − 1| | {z }
g(1,2)
+
(
1
2
XN
i=2
(yi − i)2 + 
XN
i=3 |i − i−1|
)
.
(4.66)
This decomposition shows the subproblem to be solved in the first step of
the forward pass: we compute b1(2) := arg min12R g(1, 2), We have thus
eliminated the first variable, and can now focus on the reduced objective
function f2 : RN−1 ! R given by
f2(2, . . . N) = f(b1(2), 2, . . . N). (4.67)
We can then iterate the procedure, maximizing over 2 to obtain b2(3), and so
on until we obtain bN. Then we back-substitute to obtain bN−1 = bN−1(bN),
and so on for the sequences bN−2, . . . , b2, b1.
If each parameter i can take only one of K distinct values, then each of the
minimizers bj(j+1) can be easily computed and stored as a K × K matrix.
In the continuous case, the functions to be minimized are piecewise linear
and quadratic, and care must be taken to compute and store the relevant
information in an efficient manner; see Johnson (2013) for the details. The
resulting algorithm is the fastest that we are aware of, requiring just O(N)
operations, and considerably faster than the path algorithm described above.
Interestingly, if we change the `1 difference penalty to an `0, this approach
can still be applied, despite the fact that the problem is no longer convex.
Exercise 4.24 asks the reader to implement the discrete case.
4.5.2 Trend Filtering
The first-order absolute difference penalty in the fused lasso can be generalized
to use a higher-order difference, leading to the problem
minimize
2RN
(
1
2
XN
i=1
(yi − i)2 +  · kD(k+1)k1
)
. (4.68)
This is known as trend filtering. Here D(k+1) is a matrix of dimension
(N − k − 1) × N that computes discrete differences of order k + 1. The fused
82 GENERALIZATIONS OF THE LASSO PENALTY
lasso uses first-order differences (k = 0), while higher-order differences encourage
higher-order smoothness. In general, trend filtering of order k results
in solutions that are piecewise polynomials of degree k. Linear trend filtering
(k = 1) is especially attractive, leading to piecewise-linear solutions. The
60 70 80 90
20 40 60 80 100
Temperature
Ozone
Smoothing Spline
Trend Filter
Figure 4.10 A piecewise-linear function fit to some air-pollution data using trend
filtering. For comparison, a smoothing spline with the same degrees of freedom is
included.
knots in the solution need not be specified but fall out of the convex optimization
procedure. Kim, Koh, Boyd and Gorinevsky (2009) propose an efficient
interior point algorithm for this problem. Tibshirani2 (2014) proves that the
trend filtering estimate adapts to the local level of smoothness much better
than smoothing splines, and displays a surprising similarity to locally-adaptive
regression splines. Further, he shows that the estimate converges to the true
underlying function at the minimax rate for functions whose kth derivative is of
bounded variation (a property not shared by linear estimators such as smoothing
splines). Furthermore, Tibshirani2 and Taylor (2011) show that a solution
with m knots has estimated degrees of freedom given by df = m + k + 1.9
Figure 4.10 shows a piecewise-linear function fit by trend filtering to some
air-pollution data. As a comparison, we include the fit of a smoothing spline,
with the same effective df = 4. While the fits are similar, it appears that trend
filtering has found natural changepoints in the data.
In (4.68) it is assumed that the observations occur at evenly spaced positions.
The penalty can be modified (Tibshirani2 2014) to accommodate arbitrary
(ordered) positions xi as follows:
minimize
2RN
(
1
2
XN
i=1
(yi − i)2 +  ·
NX−2
i=1

i+2 − i+1
xi+2 − xi+1 −
i+1 − i
xi+1 − xi

)
(4.69)
9This is an unbiased estimate of the degrees of freedom; see Section 2.5.
THE FUSED LASSO 83
1850 1900 1950 2000
−0.6 −0.4 −0.2 0.0 0.2 0.4
Year
Temperature Anomalies
Near Isotonic
Isotonic
Figure 4.11 Near isotonic fit to global-warming data, showing annual temperature
anomalies. The value of  was chosen by cross-validation, and the fit appears to
support the evidence of nonmonotone behavior seen in the data.
It compares the empirical slopes for adjacent pairs, and encourages them to
be the same. This is the penalty that was used in Figure 4.10, since the
Temperature values are not uniformly spaced.
4.5.3 Nearly Isotonic Regression
Tibshirani2, Hoefling and Tibshirani (2011) suggest a simple modification of
the one-dimensional fused lasso that encourages the solution to be monotone.
It is based on a relaxation of isotonic regression. In the classical form of isotonic
regression, we estimate  2 RN by solving the constrained minimization
problem
minimize
2RN
(
XN
i=1
(yi − i)2
)
subject to 1  2  . . .  N. (4.70)
The resulting solution gives the best monotone (nondecreasing) fit to the
data. Monotone nonincreasing solutions can be obtaining by first flipping the
signs of the data. There is a unique solution to problem (4.70), and it can be
obtained using the pool adjacent violators algorithm (Barlow, Bartholomew,
Bremner and Brunk 1972), or PAVA for short.
Nearly isotonic regression is a natural relaxation, in which we introduce a
regularization parameter   0, and instead solve the penalized problem
minimize
2RN
(
12
XN
i=1
(yi − i)2 + 
NX−1
i=1
(i − i+1)+
)
. (4.71)
The penalty term penalizes adjacent pairs that violate the monotonicity property,
that is, having i > i+1. When  = 0, the solution interpolates the data,
84 GENERALIZATIONS OF THE LASSO PENALTY
and letting  ! 1, we recover the solution to the classical isotonic regression
problem (4.70). Intermediate value of  yield nonmonotone solutions that
trade off monotonicity with goodness-of-fit; this trade-off allows one to assess
the validity of the monotonicity assumption for the given data sequence. Figure
4.11 illustrates the method on data on annual temperature anomalies from
1856 to 1999, relative to the 1961–1990 mean. The solution to the nearly isotonic
problem (4.71) can be obtained from a simple modification of the path
algorithm discussed previously, a procedure that is analogous to the PAVA
algorithm for problem (4.70); see Tibshirani2 et al. (2011) for details.
4.6 Nonconvex Penalties
1
3
2
1
1
2
3
1
3
1
2
1
Figure 4.12 The `q unit balls in R3 for q = 2 (left), q = 1 (middle), and q = 0.8
(right). For q < 1 the constraint regions are nonconvex. Smaller q will correspond
to fewer nonzero coefficients, and less shrinkage. The nonconvexity leads to combinatorially
hard optimization problems.
By moving from an `2 penalty to `1, we have seen that for the same
effective df the lasso selects a subset of variables to have nonzero coefficients,
and shrinks their coefficients less. When p is large and the number of relevant
variables is small, this may not be enough; in order to reduce the set of chosen
variables sufficiently, lasso may end up over-shrinking the retained variables.
For this reason there has been interest in nonconvex penalties.
The natural choice might be the `q penalty, for 0  q  1, with the
limiting `0 corresponding to best-subset selection. Figure 4.12 compares the
`q unit balls for q 2 {2, 1, 0.8}. The spiky nonconvex nature of the ball on
the right implies edges and coordinate axes will be favored in selection under
such constraints. Unfortunately, along with nonconvexity comes combinatorial
computational complexity; even the simplest case of `0 can be solved exactly
only for p  40 or less. For this and related statistical reasons alternative
nonconvex penalties have been proposed. These include the SCAD (Fan and
Li 2001, smoothly clipped absolute deviation) and MC+ (Zhang 2010, minimax
concave) penalties. Figure 4.13 shows four members of the MC+ penalty
family in R1, indexed by the nonconvexity parameter 
 2 (1,1); this family
NONCONVEX PENALTIES 85
−4 −2 0 2 4
0 1 2 3 4
MC+ Penalty
0 1 2 3 4
0 1 2 3 4
MC+ Threshold Function
 

 = 1 lasso

 = 3

 = 1.7

 = 1+ subset
Figure 4.13 Left: The MC+ family of nonconvex sparsity penalties, indexed by
a sparsity parameter 
 2 (1,1). Right: piecewise-linear and continuous threshold
functions associated with MC+ (only the north-east quadrant is shown), making this
penalty family suitable for coordinate descent algorithms.
bridges the gap between lasso (
 = 1) and best-subset (
 = 1+). The penalty
functions are piecewise quadratic (see Exercise 4.25), and importantly the corresponding
threshold functions are piecewise linear and continuous. In detail,
for squared-error loss we pose the (nonconvex) optimization problem
minimize
2Rp
8<
:
1
2ky − Xk22
+
Xp
j=1
P,
(j)
9=
;, (4.72)
with the MC+ penalty on each coordinate defined by
P,
() :=
Z ||
0

1 −
x



+
dx. (4.73)
With coordinate descent in mind, we consider solving a one-dimensional version
of (4.72) (in standardized form)
minimize
2R1
(
1
2( − ˜ )2 + 
Z ||
0

1 −
x



+
dx
)
. (4.74)
The solution is unique10 for 
 > 1 and is given by
S,
( ˜ ) =
8><
>:
0 if |˜ |  
sign( ˜ )

| ˜|−
1−1



if  < |˜ |  

˜  if |˜ | > 

(4.75)
10Despite the nonconvexity, there is a unique solution in R1; this is not necessarily the
case for the p-dimensional problem (4.72).
86 GENERALIZATIONS OF THE LASSO PENALTY
The right panel in Figure 4.13 shows examples of (4.75). Large values of ˜  are
left alone, small values are set to zero, and intermediate values are shrunk. As 

gets smaller, the intermediate zone gets narrower, until eventually it becomes
the hard-thresholding function of best subset (orange curve in figure). By
contrast, the threshold functions for the `q family (q < 1) are discontinuous
in ˜ .
Mazumder, Friedman and Hastie (2011) exploit the continuity of S,
 (in
both  and 
) in a coordinate-descent scheme for fitting solution paths for
the entire MC+ family. Starting with the lasso solution, their R package
sparsenet (Mazumder, Hastie and Friedman 2012) moves down a sequence
in 
 toward sparser models, and for each fits a regularization path in . Although
it cannot claim to solve the nonconvex problem (4.72), this approach
is both very fast and appears to find good solutions.
Zou (2006) proposed the adaptive lasso as a means for fitting models
sparser than lasso. Using a pilot estimate ˜ , the adaptive lasso solves
minimize
2Rp
8<
:
1
2ky − Xk22
+ 
Xp
j=1
wj |j |
9=
;, (4.76)
where wj = 1/|˜ j |. The adaptive lasso penalty can be seen as an approximation
to the `q penalties with q = 1 − . One advantage of the adaptive lasso
is that given the pilot estimates, the criterion (4.76) is convex in . Furthermore,
if the pilot estimates are pN consistent, Zou (2006) showed that the
method recovers the true model under more general conditions than does the
lasso. If p < N one can use the least-squares solutions as the pilot estimates.
When p  N, the least-squares estimates are not defined, but the univariate
regression coefficients can be used for the pilot estimates and result in good
recovery properties under certain conditions (Huang, Ma and Zhang 2008).
Exercise 4.26 explores the close connections between the adaptive lasso and
the nonnegative garrote of Section 2.8.
We end this section by mentioning a practical alternative to nonconvex optimization
for sparse model-path building. Forward-stepwise methods (Hastie
et al. 2009, Chapter 3) are very efficient, and are hard to beat in terms of finding
good, sparse subsets of variables. Forward stepwise is a greedy algorithm—
at each step fixing the identity of the terms already in the model, and finding
the best variable to include among those remaining. The theoretical properties
of forward-stepwise model paths are less well understood, partly because of
the algorithmic definition of the procedure, as opposed to being a solution to
an optimization problem.
Bibliographic Notes
The elastic net was proposed by Zou and Hastie (2005), who also distinguished
between the naive version, similar to the one presented here, and a debiased
BIBLIOGRAPHIC NOTES 87
version that attempts to undo the biasing effect of the ridge shrinkage. Friedman
et al. (2015) build a system of coordinate-descent algorithms for fitting
elastic-net penalized generalized linear models, implemented in the R package
glmnet. Yuan and Lin (2006) introduced the group lasso, and their paper has
stimulated much research. Meier et al. (2008) extended the group lasso to logistic
regression problems, whereas Zhao, Rocha and Yu (2009) describe a more
general family of structured penalties, including the group lasso as a special
case. A line of theoretical work has sought to understand when the group lasso
estimator has lower statistical error than the ordinary lasso. Huang and Zhang
(2010) and Lounici, Pontil, Tsybakov and van de Geer (2009) establish error
bounds for the group lasso, which show how it outperforms the ordinary lasso
in certain settings. Negahban, Ravikumar, Wainwright and Yu (2012) provide
a general framework for analysis of M-estimators, including the group lasso
as a particular case as well as more general structured penalties. Obozinski,
Wainwright and Jordan (2011) characterize multivariate regression problems
for which the group lasso does (or does not) yield better variable selection
performance than the ordinary lasso.
The overlap group lasso was introduced by Jacob et al. (2009), and the
sparse group lasso by Puig, Wiesel and Hero (2009) and Simon, Friedman,
Hastie and Tibshirani (2013). Various algorithms have been developed for
solving the group and overlap group lassos, as well as a variety of structured
generalizations; see Bach, Jenatton, Mairal and Obozinski (2012) for a good
review.
Additive models were proposed by Stone (1985) as a means of side-stepping
the curse of dimensionality in nonparametric regression; see Hastie and Tibshirani
(1990) for further background on (generalized) additive models. The
COSSO model was developed by Lin and Zhang (2003) in the context of
reproducing kernel Hilbert spaces, and ANOVA spline decompositions. The
books by Wahba (1990) and Gu (2002) provide further background on splines
and RKHSs. Ravikumar et al. (2009) followed up with the SPAM model,
which is somewhat simpler and more general, and established certain forms
of high-dimensional consistency for their estimator. Meier, van de Geer and
B¨uhlmann (2009) studied a related family of estimators, based on explicit
penalization with the empirical L2-norm, corresponding to the doubly penalized
estimator with H = 0. Koltchinski and Yuan (2008, 2010) analyzed the
COSSO estimator, as well as the doubly penalized estimator (4.52). Raskutti
et al. (2009, 2012) derived minimax bounds for sparse additive models, and
also show that the doubly penalized estimator (4.52) can achieve these bounds
for various RKHS families, including splines as a special case.
The fused lasso was introduced by Tibshirani, Saunders, Rosset, Zhu and
Knight (2005). Various algorithms have been proposed for versions of the
fused lasso, including the methods of Hoefling (2010), Johnson (2013), and
Tibshirani2 and Taylor (2011).
The MC+ threshold function was first described in Gao and Bruce (1997)
in the context of wavelet shrinkage. There has been a lot of activity in non88
GENERALIZATIONS OF THE LASSO PENALTY
convex penalties for sparse modeling. Zou and Li (2008) develop local linear
approximation algorithms for tackling the nonconvex optimization problems.
These and other approaches are discussed in Mazumder et al. (2011).
Exercises
Ex. 4.1 Suppose we have two identical variables X1 = X2, and a response
Y , and we perform a ridge regression (see (2.7) in Section 2.2) with penalty
 > 0. Characterize the coefficient estimates bj().
Ex. 4.2 Consider a slightly noisy version of the identical twins example in
the beginning of Section 4.2, where the two variables are strongly positively
correlated. Draw a schematic of the contours of the loss function and the
penalty function, and demonstrate why the elastic net encourages coefficient
sharing more than does the lasso.
Ex. 4.3 Consider the elastic-net problem (4.2).
(a) Show how to simplify the calculation of b0 by centering each of the predictors,
leading to b0 = ¯y (for all values of ). How does one convert back
to the estimate of b0 for uncentered predictors?
(b) Verify the soft-thesholding expression (4.4) for the update of bj by coordinate
descent.
Ex. 4.4 Consider the solution to the group lasso problem (4.5) when some of
the variables are factors. Show that when there is an intercept in the model,
the optimal coefficients for each factor sum to zero.
Ex. 4.5 This exercise investigates the penalty modifier for the group lasso.
Consider the entry criterion kZTj
rjk2 <  for the group lasso (Section 4.3.1).
Suppose rj is i.i.d noise with mean 0 and covariance 2I—a null situation.
Show that
EkZTj
rjk22
= 2kZk2
F . (4.77)
Hence argue that to make comparisons fair among the penalty terms in the
group lasso, one should replace 
PJ
j=1 kjk2 in Equation (4.5) with

XJ
j=1
jkjk2, (4.78)
where j = kZjkF . Show that when Zj is orthonormal, this results in j =
ppj .
Ex. 4.6 Show that under the orthonormality condition ZTj
Zj = I, the update
(4.15) solves the fixed point Equation (4.13).
EXERCISES 89
Ex. 4.7 Consider the block-wise solution vector (4.14) for the group lasso. If
kˆjk is known, we can write the solution in closed form. Let Zj = UDVT
be the singular value decomposition of Zj . Let r = UT rj 2 Rpj . Show that
 = kˆjk solves
Xpj
`=1
r
`
2d2`
(d2`  + )2 = 1, (4.79)
where d` is the `th diagonal element of D. Show how to use a golden search
strategy to solve for .Write an R function to implement this algorithm, along
with the golden search.
Ex. 4.8 Discuss the impact of the normalization ZTj
Zj = I in the context of a
matrix of dummy variables representing a factor with pj levels. Does the use
of contrasts rather than dummy variables alleviate the situation?
Ex. 4.9 Using the approach outlined in Section 5.3.3, derive the generalized
gradient update (4.16a) for the group lasso. Write a R function to implement
this algorithm (for a single group). Include an option to implement Nesterov
acceleration.
Ex. 4.10 Using the approach outlined in Section 5.3.3, derive the generalized
gradient update (4.23) for the sparse group lasso.
Ex. 4.11 Run a series of examples of increasing dimension to compare the
performance of your algorithms in Exercises 4.7 and 4.9. Make sure they are
producing the same solutions. Compare their computational speed—for instance,
the command system.time() can be used in R.
Ex. 4.12 Consider the condition (4.19) for ˆj to be zero for the sparse group
lasso. Define
J(t) = 1
(1 − )kZTj
rj −  · tk2 (4.80)
= ksk2.
Now solve
min
t:tk2[−1,1]
J(t), (4.81)
and show that this leads to the condition ˆj = 0 if and only if kˆgjk2  (1−)
with ˆgj = S(ZTj
rj ).
Ex. 4.13 Show that if ZTj
Zj = I, then (4.21) solves (4.12).
90 GENERALIZATIONS OF THE LASSO PENALTY
Ex. 4.14 Consider the hierarchical interaction formulation in Example 4.3, and
the optimization problem (4.29)–(4.31).
(a) Give an argument why the multipliers p1 and p2 make sense in the third
penalty.
(b) Suppose we augment the third matrix in (4.29) with a vector of ones
[1 Z1 Z2 Z1:2], and augment the parameter vector with ˜μ. We now replace
the third group penalty term with
q
p1p2 ˜μ2 + p2k˜1k22
+ p1k˜2k22
+ k1:2k22
.
Show that for any  > 0, b˜μ = 0.
(c) Show that the solution to (4.29)–(4.31) is equivalent to the solution to
(4.32) for any  > 0. Show how to map the solution to the latter to the
solution to the former.
Ex. 4.15 Consider a criterion for sparse additive models:
minimize
2RJ , {fj2Fj}J1
E(Y −
XJ
j=1
jfj(Xj))2
subject to kfjk2 = 1 8j (4.82)
XJ
j=1 |j |  t.
Although evocative, this criterion is not convex, but rather biconvex in  and
{fj}J1
. Show that one can absorb the j into fj and that solving (4.82) is
equivalent to solving the convex (4.38):
minimize
fj2Fj , j=1,...,J
8<
:E
h
Y −
XJ
j=1
fj(Xj)
2i
+ 
XJ
j=1 kfjk2
9=
;.
(Ravikumar et al. 2009)
Ex. 4.16 The SPAM backfitting equations (4.40) are in terms of function
updates, where ˆ fj is a fitted function returned by a smoothing operator Sj ,
and the N-vector form fj is fj evaluated at the N samples values of Xj .
Suppose that the smoothing operator Sj fits a linear expansion of the form
fj(·) =
Xpj
`=1
j`  j`(·), (4.83)
where j =

j1 j2 · · · jpj

is the coefficient vector.
EXERCISES 91
(a) Suppose that the basis matrices are orthonormal: 	Tj
	j = Ipj . Show that
the SPAM backfitting equations are equivalent to the ordinary group-lasso
estimating equations in terms of the parameters j .
(b) What changes if 	j is not orthonormal?
Ex. 4.17 In this exercise, we show that any optimal solution to the COSSO
problem (4.44) is a member of H0, the linear span of the kernel functions
{R(·, xi), i = 1, . . . ,N}. We use the fact that any function f 2 H has a decomposition
of the form g + h, where g 2 H0 and h is orthogonal to H0,
meaning that hh, f0iH for all f0 2 H0.
(a) For a function of the form f = g + h as above, show that the term
1
N
PN
i=1(y−f(xi))2 depends only on g. (Hint: The kernel reproducing property
could be useful here.)
(b) Show that the penalty term is only increased by including a component
h 6= 0. Conclude that any optimal solution b f must belong to H0.
Ex. 4.18 Verify that the solutions for fj in (4.47) with  =  4/4 coincide with
the solutions in (4.44).
Ex. 4.19 Consider the additive model criterion (4.42), and assume associated
with each function fj is a reproducing kernel Rj , leading to a data criterion
minimize
j2R
N
j=1,...J
8<
:



y −
XJ
j=1
Rjj



2 + 
XJ
j=1
1

j
Tj
Rjj
9=
; (4.84)
(The 1/N has been absorbed into ).
(a) Define ˜Rj = 
jRj and ˜j = j/
j . In this new parametrization, show
that the estimating equations for ˜j are
−˜Rj(y − f+) + ˜Rj ˜j = 0, j = 1, . . . , J, (4.85)
where f+ = PJ
j=1 fj , and fj = ˜Rj ˜j .
(b) Show that these can be rewritten as
˜
j = (˜Rj + I)−1rj , and (4.86a)
˜f
j = ˜Rj(˜Rj + I)−1rj , (4.86b)
where rj = y − f+ + fj .
(c) Define ˜R+ = PJ
j=1 ˜Rj = PJ
j=1 
jRj . Show that
f+ = ˜R+(˜R+ + I)−1y = ˜R+c (4.87a)
c = (˜R+ + I)−1y. (4.87b)
Compare with the previous item.
92 GENERALIZATIONS OF THE LASSO PENALTY
(d) Show that ˜ j = c 8 j. So even though there are J N-dimensional parameters
˜
j in this representation, their estimates are all the same.
This shows that given 
j , fj = 
jRjc = 
jgj , and justifies the second
step (4.46) in the alternating algorithm for fitting the COSSO model (see
Section 4.4).
Ex. 4.20 Show that any optimal solution to the doubly regularized estimator
(4.52) takes the form b fj(·) = PN
i=1
bijR(·, xij ), where the optimal weights
(bj , j = 1, . . . , J) are obtained by solving the convex program (4.53).
Ex. 4.21 Consider the fused lasso problem (4.56). Characterize b0. Show that if
we center the predictors and the response by subtracting their sample means,
we can omit the term 0 and the estimates bj are unaffected. Now consider a
version of the fused-lasso signal approximator (4.54) with a constant term 0
included:
minimize
0,
XN
i=1
(yi − 0 − i)2 + 1
XN
i=1 |i| + 2
XN
i=2 |i − i−1|. (4.88)
Characterize ˆ0, and show that median(ˆi) = 0.
Ex. 4.22 Consider the matrix M corresponding to the linear transformation
(4.60).
(a) Show that its inverse M−1 is lower triangular with all ones on and below
the diagonal.
(b) Explore the pairwise correlations between the columns of such a matrix
for the CGH data of Figure 4.8.
(c) Using glmnet with maxdf=200, and type="naive", fit model (4.61), and
show that the fitted values correspond to the parameters of interest. Compare
the performance of lars for the same task. Using a soft-thresholding
post-processor, try to match Figure 4.8.
Ex. 4.23 Derive the dual optimization problem (4.64) in Section 4.5.1.3. Suppose
the kth element of ˆu() has reached the bound at  = k, and let the
set B hold their indices, and s a vector of their signs. Show that the solution
to (4.64) at k also solves
minimize
u−B
1
2ky − kDT
Bs − DT
−Bu−Bk2, (4.89)
with solution ˆuB() = s and ˆu−B() = (D−BDT
−B)−1D−B(y − DT
Bs) and
 = k. By definition each of the elements of ˆu−B() has absolute value less
than k. Show that the solution is piecewise-linear in  < k, and remains
the solution until the next element of ˆu−B() hits the boundary. Show that
one can determine exactly for which element and value of  this will be.
EXERCISES 93
Ex. 4.24 Here we use dynamic programming to fit the fused lasso.
(a) Implement the dynamic programming approach to the fused lasso, in the
simple case where each i can take one of K distinct values.
(b) Do the same as in (a), replacing the `1 difference penalty with an `0
difference penalty. Compare the two procedures on the CGH data.
Ex. 4.25 Derive the threshold function (4.75) for the uni-dimensional MC+
criterion (4.74) in Section 4.6.
Ex. 4.26 Show that with  = 1 in (4.76), the adaptive-lasso solutions are
similar to those of the nonnegative garrote (2.19). In particular, if we constrain
the adaptive lasso solutions to have the same sign as the pilot estimates,
then they are the same as the solutions to the garrote with a suitably chosen
regularization parameter.

Chapter 5
Optimization Methods
5.1 Introduction
In this chapter, we present an overview of some basic optimization concepts
and algorithms for convex problems, with an emphasis on aspects of particular
relevance to regularized estimators such as the lasso. At the algorithmic level,
we focus primarily on first-order methods, since they are especially useful for
large-scale optimization problems. We begin with an overview of some basic
optimality theory for convex programs, and then move on to consider various
types of iterative algorithms. Although we limit our focus mainly to convex
problems, we do touch upon algorithms for biconvex problems later in the
chapter.
5.2 Convex Optimality Conditions
An important class of optimization problems involves convex cost functions
and convex constraints. A set C  Rp is convex if for all , 0 2 C and all
scalars s 2 [0, 1], all vectors of the form (s) = s + (1 − s)0 also belong to
C. A function f : Rp ! R is convex means that for any two vectors , 0 in
the domain of f and any scalar s 2 (0, 1), we have
f ((s)) = f (s + (1 − s)0)  sf() + (1 − s)f(0). (5.1)
In geometric terms, this inequality implies that the chord joining the f() and
f(0) lies above the graph of f, as illustrated in Figure 5.1(a). This inequality
guarantees that a convex function cannot have any local minima that are not
also globally minimal, as illustrated Figure 5.1(b).
5.2.1 Optimality for Differentiable Problems
Consider the constrained optimization problem
minimize
2Rp
f() such that  2 C, (5.2)
where f : Rp ! R is a convex objective function to be minimized, and C  Rp
is a convex constraint set. When the cost function f is differentiable, then a
95
96 OPTIMIZATION METHODS
f()
f(′)
f(s + (1 − s)′)
sf() + (1 − s)f(′)
 (s) ′  (s) ′
(a) (b)
Figure 5.1 (a) For a convex function, the line sf() + (1 − s)f(0) always lies
above the function value f(s+(1−s)0). (b) A nonconvex function that violates the
inequality (5.1). Without convexity, there may be local minima that are not globally
minima, as shown by the point 0.
necessary and sufficient condition for a vector  2 C to be a global optimum
is that
hrf(),  − i  0 (5.3)
for all  2 C. The sufficiency of this condition is easy to see; for any  2 C,
we have
f()
(i)
 f() + hrf(),  − i
(ii)
 f(), (5.4)
where inequality (i) follows from the convexity of f, 1 and inequality (ii) follows
from the optimality condition (5.3). As a special case, when C = Rp so that the
problem (5.2) is actually unconstrained, then the first-order condition (5.3)
reduces to the classical zero-gradient condition rf() = 0.
Frequently, it is the case that the constraint set C can be described in
terms of the sublevel sets of some convex constraint functions. For any convex
function g : Rp ! R, it follows from the definition (5.1) that the sublevel set
{ 2 Rp | g()  0} is a convex set. On this basis, the convex optimization
problem
minimize
2Rp
f() such that gj()  0 for j = 1, . . . ,m, (5.5)
1Inequality (i) is an equivalent definition of convexity for a differentiable function f; the
first-order Taylor approximation centered at any point ˜ 2 C gives a tangent lower bound
to f.
CONVEX OPTIMALITY CONDITIONS 97
where gj , j = 1, . . . ,m are convex functions that express constraints to be
satisfied, is an instance of the general program (5.2). We let f denote the
optimal value of the optimization problem (5.5).
An important function associated with the problem (5.5) is the Lagrangian
L : Rp × Rm+
! R, defined by
L(; ) = f() +
Xm
j=1
jgj(). (5.6)
The nonnegative weights   0 are known as Lagrange multipliers; the purpose
of the multiplier j is to impose a penalty whenever the constraint
gj()  0 is violated. Indeed, if we allow the multipliers to be chosen optimally,
then we recover the original program (5.5), since
sup
0
L(; ) =
(
f() if gj()  0 for all j = 1, . . . ,m, and
+1 otherwise,
(5.7)
and thus f = inf2Rp sup0 L(; ). See Exercise 5.2 for further details on
this equivalence.
For convex programs, the Lagrangian allows for the constrained problem
(5.5) to be solved by reduction to an equivalent unconstrained problem.
More specifically, under some technical conditions on f and {gj}, the theory
of Lagrange duality guarantees that there exists an optimal vector   0
of Lagrange multipliers such that f = min2Rp L(; ). As a result, any
optimum  of the problem (5.5), in addition to satisfying the feasibility constraints
gj()  0, must also be a zero-gradient point of the Lagrangian, and
hence satisfy the equation
0 = rL(; ) = rf() +
Xm
j=1

j rgj(). (5.8)
When there is only a single constraint function g, this condition reduces to
rf() = −rg(), and has an intuitive geometric interpretation, as shown
in Figure 5.2. In particular, at the optimal solution , the normal vector
rf() to the contour line of f points in the opposite direction to the normal
vector to the constraint curve g() = 0. Equivalently, the normal vector to
the contour f lies at right angles to the tangent vector of the constraint.
Consequently, if we start at the optimum  and travel along the tangent at
g() = 0, we cannot decrease the value of f() up to first order.
In general, the Karush–Kuhn–Tucker conditions relate the optimal Lagrange
multiplier vector   0, also known as the dual vector, to the optimal
primal vector  2 Rp:
(a) Primal feasibility: gj()  0 for all j = 1, . . . ,m.
(b) Complementary slackness: j gj() = 0 for all j = 1, . . . ,m.
98 OPTIMIZATION METHODS
f() = c1
f() = c2 < c1 g() = 0

Figure 5.2 Illustration of the method of Lagrange multipliers. We are minimizing
a function f subject to a single constraint g()  0. At an optimal solution , the
normal vector rf() to the level sets of the cost function f points in the opposite
direction to the normal vector rg() of the constraint boundary g() = 0. Consequently,
up to first order, the value of f() cannot be decreased by moving along
the contour g() = 0.
(c) Lagrangian condition: The pair (, ) satisfies condition (5.8).
These KKT conditions are necessary and sufficient for  to be a global
optimum whenever the optimization problem satisfies a regularity condition
known as strong duality. (See Exercise 5.4 for more details.) The complementary
slackness condition asserts that the multiplier j must be zero if
the constraint gj()  0 is inactive at the optimum—that is, if gj() < 0.
Consequently, under complementary slackness, the Lagrangian gradient condition
(5.8) guarantees that the normal vector −rf() lies in the positive
linear span of the gradient vectors {rgj() | j > 0}.
5.2.2 Nondifferentiable Functions and Subgradients
In practice, many optimization problems arising in statistics involve
convex but nondifferentiable cost functions. For instance, the `1-norm
g() = Pp
j=1 |j | is a convex function, but it fails to be differentiable at any
point where at least one coordinate j is equal to zero. For such problems,
the optimality conditions that we have developed—in particular, the firstorder
condition (5.3) and the Lagrangian condition (5.8)—are not directly
applicable, since they involve gradients of the cost and constraint functions.
Nonetheless, for convex functions, there is a natural generalization of the notion
of gradient that allows for a more general optimality theory.
A basic property of differentiable convex functions is that the first-order
tangent approximation always provides a lower bound. The notion of subgraCONVEX
OPTIMALITY CONDITIONS 99
1 2
f()
f(2) + zc( − 2)
f(2) + zb( − 2)
f(1) + za( − 1)
Figure 5.3 A convex function f : R ! R, along with some examples of subgradients
at 1 and 2.
dient is based on a natural generalization of this idea. In particular, given a
convex function f : Rp ! R, a vector z 2 Rp is said to be a subgradient of f
at  if
f(0)  f() + hz, 0 − i for all 0 2 Rp. (5.9)
In geometric terms, the subgradient vector z is the normal to a (nonvertical)
hyperplane that supports the epigraph of f. The set of all subgradients
of f at  is called the subdifferential, denoted by @f(). Whenever f is differentiable
at , then the sub-differential reduces to a single vector—namely
@f() = {rf()}. At points of nondifferentiability, the subdifferential is a
convex set containing all possible subgradients. For example, for the absolute
value function f() = ||, we have
@f() =
8><
>:
{+1} if  > 0
{−1} if  < 0
[−1, +1] if  = 0.
(5.10)
We frequently write z 2 sign() to mean that z belongs to sub-differential of
the absolute value function at .
Figure 5.3 shows a function f : R ! R, and some examples of subgradients
at the two points 1 and 2. At the point 1, the function is differentiable and
hence there is only one subgradient—namely, f0(1). At the point 2, it is
not differentiable, and there are multiple subgradients; each one specifies a
tangent plane that provides a lower bound on f.
How is this useful? Recall the convex optimization problem (5.5), and
assume that one or more of the functions {f, gj} are convex but nondifferentiable.
In this case, the zero-gradient Lagrangian condition (5.8) no longer
makes sense. Nonetheless, again under mild conditions on the functions, the
generalized KKT theory can still be applied using the modified condition
0 2 @f() +
Xm
j=1

j @gj(), (5.11)
100 OPTIMIZATION METHODS
in which we replace the gradients in the KKT condition (5.8) with subdifferentials.
Since the subdifferential is a set, Equation (5.11) means that the
all-zeros vector belongs to the sum of the subdifferentials.2
Example 5.1. Lasso and subgradients. As an example, suppose that we want to
solve a minimization problem of the form (5.5) with a convex and differentiable
cost function f, and a single constraint specified by g() = Pp
j=1 |j | − R for
some positive constant R. Thus, the constraint g()  0 is equivalent to
requiring that  belongs to an `1-ball of radius R. Recalling the form of the
subdifferential (5.10) for the absolute value function, condition (5.11) becomes
rf() + z = 0, (5.12)
where the subgradient vector satisfies z
j 2 sign(
j ) for each j = 1, . . . , p.
When the cost function f is the squared error f() = 1
2N ky − Xk22
, this
condition is equivalent to Equation (2.6) from Chapter 2. }
Example 5.2. Nuclear norm and subgradients. The nuclear norm is a convex
function on the space of matrices. Given a matrix  2 Rm×n (where we assume
m  n), it can always be decomposed in the form  = Pm
j=1 jujvT
j .
where {uj}mj
=1 and {vj}mj
=1 are the (left and right) singular vectors, chosen
to be orthonormal in Rm and Rn, respectively, and the nonnegative numbers
j  0 are the singular values. This is known as the singular-value decomposition
(SVD) of . The nuclear norm is the sum of the singular values—that
is, kk? = Pm
j=1 j(). Note that it is a natural generalization of the vector
`1-norm, since for any (square) diagonal matrix, the nuclear norm reduces to
the `1-norm of its diagonal entries. As we discuss in Chapter 7, the nuclear
norm is useful for various types of matrix approximation and decomposition.
The subdifferential @kk? of the nuclear norm at  consists of all matrices
of the form Z = Pm
j=1 zjujvT
j , where each for j = 1, . . . ,m, the scalar
zj 2 sign(j()). We leave it as an exercise for the reader to verify this claim
using the definition (5.9). }
5.3 Gradient Descent
Thus far, we have seen various types of optimality conditions for different types
of convex programs. We now turn to various classes of iterative algorithms
for solving optimization problems. In this section, we focus on first-order algorithms,
meaning methods that exploit only gradient (or subgradient) information,
as opposed to information from higher-order gradients. First-order
methods are particularly attractive for large-scale problems that arise in much
of modern statistics.
2Here we define the sum of two subsets A and B of Rp as A+B := {+ |  2 A,  2
B}.
GRADIENT DESCENT 101
5.3.1 Unconstrained Gradient Descent
We begin with the simplest case —namely, unconstrained minimization of
a convex differentiable function f : Rp ! R. In this case, assuming that
the global minimum is achieved, then a necessary and sufficient condition for
optimality of  2 Rp is provided by the zero-gradient condition rf() = 0.
Gradient descent is an iterative algorithm for solving this fixed point equation:
it generates a sequence of iterates {t}1
t=0 via the update
t+1 = t − strf(t), for t = 0, 1, 2, . . ., (5.13)
where st > 0 is a stepsize parameter. This update has a natural geometric
interpretation: by computing the gradient, we determine the direction of
steepest descent −rf(t), and then walk in this direction for a certain amount
determined by the stepsize st.
More generally, the class of descent methods is based on choosing a direction
t 2 Rp such that hrf(t), ti < 0, and then performing the update
t+1 = t + stt for t = 0, 1, 2, . . .. (5.14)
In geometric terms, the inner product condition hrf(t), ti < 0 means
that the chosen direction t forms an angle of less than 90 with the direction
of steepest descent. The gradient descent update (5.13) is a special
case with t = −rf(t). Other interesting choices include diagonally-scaled
gradient descent: given a diagonal matrix Dt  0, it uses the descent direction
t = −(Dt)−1rf(t). This type of diagonal scaling is helpful when the
function varies more rapidly along some coordinates than others. More generally,
Newton’s method is applicable to functions that are twice continuously
differentiable, and is based on the descent direction
t = −
􀀀
r2f(t)
−1
rf(t), (5.15)
where r2f(t) is the Hessian of f, assumed to be invertible. Newton’s method
is a second-order method, since it involves first and second derivatives. In
particular, a Newton step (with stepsize one) amounts to exactly minimizing
the second-order Taylor approximation to f at t. Under some regularity
conditions, it enjoys a quadratic rate of convergence; however, computation
of the Newton direction (5.15) is more expensive than first-order methods.
An important issue for all iterative algorithms, among them the gradient
descent update (5.13), is how to choose the stepsize st. For certain problems
with special structure, it can be shown that a constant stepsize (meaning st =
s for all iterations t = 0, 1, . . .) will guarantee convergence; see Exercise 5.1
for an illustration. In general, it is not sufficient to simply choose a stepsize
for which f(t+1) < f(t); without some care, this choice may cause the
algorithm to converge to a nonstationary point. Fortunately, there are various
kinds of stepsize selection rules that are relatively simple, and have associated
convergence guarantees:
102 OPTIMIZATION METHODS
s = 0 s1 s0 = 1
f() f( + s)
f() + s f() + s1h∇f(), i 0h∇f(), i
Figure 5.4 Armijo rule or backtracking line search. Starting with stepsize
s0 = 1, we repeatedly reduce s by a fraction 
 until the condition
f( + s)  f() + shrf(), i is satisfied. This is achieved here at s1.
• Limited minimization rule: choose the stepsize st = arg min
s2[0,1]
f (t + st).
Although this choice is very intuitive, it does require solving a onedimensional
optimization problem at each step.
• Armijo or backtracking rule: Given parameters  2 (0, 1) and 
 2 (0, 1) and
an initial stepsize s = 1, perform the reduction s   
s until the descent
condition
f
􀀀
t + st
 f(t) + s hrf(t), ti (5.16)
is met. In practice, the choices  = 0.5 and 
 = 0.8 are reasonable. The
condition (5.16) can be interpreted as saying that we will accept a fraction 
of the decrease in f() that is predicted by linear extrapolation (Figure 5.4).
For convex functions, both of these stepsize choices, when combined with
suitable choices of the descent directions {t}1
t=0, yield algorithms that are
guaranteed to converge to a global minimum of the convex function f. See the
bibliographic section on page 131 for further discussion.
5.3.2 Projected Gradient Methods
We now turn to gradient methods for problems that involve additional side
constraints. In order to provide some geometric intuition for these methods,
it is useful to observe that the gradient step (5.13) has the alternative representation
t+1 = arg min
2Rp

f(t) + hrf(t),  − ti + 1
2st k − tk22

. (5.17)
GRADIENT DESCENT 103
Thus, it can be viewed as minimizing the linearization of f around the current
iterate, combined with a smoothing penalty that penalizes according to
Euclidean distance.
This view of gradient descent—an algorithm tailored specifically for unconstrained
minimization—leads naturally to the method of projected gradient
descent, suitable for minimization subject to a constraint  2 C:
t+1 = arg min
2C

f(t) + hrf(t),  − ti + 1
2st k − tk22

. (5.18)
Equivalently, as illustrated in Figure 5.5, this method corresponds to taking
a gradient step t − srf(t), and then projecting the result back onto the
convex constraint set C. It is an efficient algorithm as long as this projection
can be computed relatively easily. For instance, given an `1-ball constraint
C = { 2 Rp | kk1  R}, this projection can be computed easily by a
variant of soft thresholding, as we discuss in more detail later.
t
t+1
t − st∇f(t)
Figure 5.5 Geometry of projected gradient descent. Starting from the current iterate
t, it moves in the negative gradient direction to t − strf(t), and then performs
a Euclidean projection of the result back onto the convex constraint set C in order to
obtain the next iterate t+1.
5.3.3 Proximal Gradient Methods
Here we discuss a general class of methods that include projected gradient
descent as a special case. As discussed previously, many objective functions f
can be decomposed as a sum f = g + h, where g is convex and differentiable,
and h is convex but nondifferentiable. Suppose that we would like to minimize
such an objective function by a gradient-type algorithm. How do we deal with
the nondifferentiability of the component h?
In order to see how this difficulty can be finessed, recall that an ordinary
gradient step can be viewed as minimizing the combination of a local linear
approximation to f combined with a quadratic smoothness term—in particular,
see Equation (5.17). This perspective suggests the following strategy: form
104 OPTIMIZATION METHODS
a local approximation to f by linearizing the differentiable component g, but
leaving the nondifferentiable component fixed. This leads to the generalized
gradient update, defined by
t+1 = arg min
2Rp

g(t) + hrg(t),  − ti + 1
2st k − tk22
+ h()

, (5.19)
where we have approximated the differentiable part g, but retained an exact
form of the nondifferentiable component h.
The update (5.19) is closely related to the projected gradient descent update
(5.18); in fact, it can be viewed as a Lagrangian analog. In order to make
this connection explicit, we define the proximal map of a convex function h, a
type of generalized projection operator:
proxh(z) := arg min
2Rp
1
2kz − k22
+ h()

. (5.20)
From this definition we immediately have the following relations:
(a) proxsh(z) = arg min2Rp
 1
2skz − k22
+ h()
	
.
(b) When
h() = IC() =
(
0 if  2 C, and
+1 otherwise
we have proxh(z) = arg min2C kz − k22
, corresponding to the usual Euclidean
projection onto the set C.
(c) If h() = kk1, then proxh(z) = S(z), the element-wise softthresholded
version of z. See Example 5.3 below.
As we show in Exercise 5.7, it follows that the update (5.19) has the equivalent
representation
t+1 = proxsth
􀀀
t − strg(t)

. (5.21)
Similarly, it is easy to see that the proximal-gradient update
t+1 = proxIC
􀀀
t − strg(t)

(5.22)
is exactly the projected gradient step (5.18).
The updates (5.21) will be computationally efficient as long as the proximal
map is relatively easy to compute. For many problems that arise in statistics—
among them the `1-norm, group-lasso `2 norm, and nuclear norms—the proximal
map (5.20) can be computed quite cheaply. Typically the update (5.21) is
better suited to statistical problems that impose regularization via a penalty,
as opposed to a constraint of the form h()  R.
Example 5.3. Proximal gradient descent for `1-penalty. Suppose that the
nondifferentiable component is a (scaled) `1 penalty, say h() = kk1. With
this choice of h, proximal gradient descent with stepsize st at iteration t consists
of two very simple steps:
GRADIENT DESCENT 105
1. First, take a gradient step z = t − strg(t).
2. Second, perform elementwise soft-thresholding t+1 = Sst(z).
In detail, the proximal map (5.21) is given by
proxsh(z) = arg min
2Rp
 1
2skz − k22
+ kk1

= arg min
2Rp
1
2kz − k22
+ skk1

.
(5.23)
This optimization problem has an explicit closed-form solution; in particular,
since the objective function decouples across coordinates as
1
2kz − k22
+ skk1 =
Xp
j=1
1
2(zj − j)2 + s|j |

, (5.24)
we can solve the p-dimensional problem by solving each of the univariate
problems separately. We leave it as an exercise for the reader to verify the
solution is obtained by applying the soft thresholding operator S : Rp ! Rp
with coordinates
[S (z)]j = sign(zj)(|zj | −  )+, (5.25)
with the threshold choice  = s. (Here we use (x)+ as a shorthand for
max{x, 0}.) }
Example 5.4. Proximal gradient descent for nuclear norm penalty. As a second
illustration, suppose that h is  times the nuclear norm. As previously
introduced in Example 5.2, the nuclear norm is a real-valued function on the
space of m × n matrices, given by kk? = Pm
j=1 j(), where {j()} are
the singular values of . With this choice of h, the generalized projection
operator (5.20) takes the form
proxsh(Z) = arg min
2Rm×n
 1
2skZ −k2
F + kk?

. (5.26)
Here the Frobenius norm kZ −k2
F = Pm
j=1
Pn
k=1(Zjk − jk)2 is simply the
usual Euclidean norm applied to the entries of the matrices. Although this
proximal map (5.26) is no longer separable, it still has a relatively simple solution.
Indeed, as we explore in Exercise 5.8, the update s,h(Z) is obtained by
computing the singular value decomposition of Z, and then soft-thresholding
its singular values. }
Nesterov (2007) provides sufficient conditions for the convergence of the
updates (5.21) when applied to a composite objective function f = g + h.
Suppose that the component g is continuously differentiable with a Lipschitz
gradient, meaning that there is some constant L such that
krg() − rg(0)k2  Lk − 0k2 for all , 0 2 Rp. (5.27)
106 OPTIMIZATION METHODS
Under this condition and with a constant stepsize st = s 2 (0, 1/L], it can be
shown that there is a constant C, independent of the iteration number, such
that the updates (5.21) satisfy
f(t) − f() 
C
t + 1 kt − k2 for all t = 1, 2, . . ., (5.28)
where  is an optimal solution. In words, the difference between the value
f(t) of the tth iterate and the optimal value f() decreases at the rate
O(1/t). This rate is known as sublinear convergence, and is guaranteed for
any fixed stepsize in the interval (0, 1/L]. Such a choice requires an upper
bound on the Lipschitz constant L, which may or may not be available. In
practice, the Armijo rule also yields the same rate (5.28). (See Figure 5.6.)
0 10 20 30 40 50
−8
−7
−6
−5
−4
−3
−2
−1
0
Iteration
Log |f(bt) − f(b*)|
Linear versus sublinear convergence
 
 
Sublinear
Linear
Figure 5.6 Plot of log |f(t) − f()| versus the iteration number t, comparing a
sublinear convergence rate (5.28) with a linear or geometric convergence rate (5.30).
For an algorithm with geometric convergence, the error decay on this logarithmic
scale is linear with a negative slope.
Significantly faster rates are possible if the objective function has additional
structure. For instance, suppose that in addition to having a Lipschitz
continuous gradient (5.27), the differentiable component g is strongly convex,
meaning that there exists some 
 > 0 such that
g( + ) − g() − hrg(), i  
2kk22
for all , 2 Rp. (5.29)
This condition guarantees that g has at least as much curvature as the
quadratic function  7! 
2kk22
in all directions. Under conditions (5.27)
and (5.29), it can be shown that with a constant stepsize s 2 (0, 1/L], the
GRADIENT DESCENT 107
updates (5.21) will achieve a linear or geometric rate of convergence, meaning
that there exists a positive constant C and contraction factor  2 (0, 1) such
that
f(t) − f()  C tk0 − k2 for all t = 1, 2, . . ., (5.30)
Thus, under the additional strong convexity condition, the error f(t)−f()
is guaranteed to contract at a geometric rate specified by  2 (0, 1). See
Figure 5.6 for an illustration of the difference between this linear rate and the
earlier sublinear rate (5.28).
Example 5.5. Proximal gradient for lasso. For the lasso, we have
g() = 1
2N ky − Xk22
and h() = kk1,
so that the proximal gradient update (5.21) takes the form
t+1 = Sst 

t + st 1
N
XT (y − Xt)

. (5.31)
Note that this has a very similar form to the coordinate descent update (see
Section 5.4), especially if we take the stepsize s = 1 and assume that the
predictors are standardized. Then both procedures operate on the same quantities,
one in a cyclical manner and the other (proximal gradients) in a simultaneous
manner on all coordinates. It is not clear which is a more effective
approach. The coordinate descent procedure can exploit sparsity of the coefficient
vector and doesn’t need to worry about step-size optimization, while the
proximal gradient may gain efficiency by moving all parameters at the same
time. It may also have speed advantages in problems where the multiplication
of a vector by both X and XT can be done quickly, for example by a fast
Fourier transform. The Lipschitz constant L here is the maximum eigenvalue
of XTX/N; one can use a fixed stepsize in (0, 1/L] or a form of backtracking
step selection. We compare these in a numerical example in Section 5.5. }
5.3.4 Accelerated Gradient Methods
In this section, we discuss a class of accelerated gradient methods due to
Nesterov (2007). Suppose that we have a convex differentiable function f, and
recall the standard gradient step (5.13). For certain objective functions, this
update may exhibit an undesirable type of “zig-zagging” behavior from step
to step, which could conceivably slow down convergence. With the motivation
of alleviating this drawback, Nesterov (2007) proposed the class of accelerated
gradient methods that use weighted combinations of the current and previous
gradient directions.
In more detail, the accelerated gradient method involves a pair of sequences
{t}1
t=0 and {t}1
t=0, and some initialization 0 = 0. For iterations
108 OPTIMIZATION METHODS
t = 0, 1, 2, . . ., the pair is then updated according to the recursions
t+1 = t − strf(t), and (5.32a)
t+1 = t+1 + t
t + 3(t+1 − t). (5.32b)
For non-smooth functions f that have the “smooth plus non-smooth” decomposition
g + h, Nesterov’s acceleration scheme can be combined with
the proximal gradient update: in particular, we replace the ordinary gradient
step (5.32a) with the update
t+1 = proxsth
􀀀
t − strg(t)

. (5.33)
In either case, the stepsize st is either fixed to some value, or chosen according
to some type of backtracking line search.
Example 5.6. Proximal gradient descent with momentum. Let us consider the
combination of proximal gradient steps with the acceleration scheme in application
to the `1-regularized lasso program. Recalling the form (5.31) of the
composite gradient update, we see that the accelerated scheme consists of the
updates
t+1 = Sst
􀀀
t + st 1
NXT (y − Xt)

t+1 = t+1 + t
t + 3
􀀀
t+1 − t
. (5.34a)
This algorithm for the lasso is essentially equivalent, modulo some minor differences
in the acceleration weights, to the Fast Iterative Soft-thresholding
Algorithm (FISTA) of Beck and Teboulle (2009).
To investigate how well this works, we generated data from a regression
problem with N = 1000 observations and p = 500 features. The features xij
are standard Gaussian having pairwise correlation 0.5. Twenty of the 500 coefficients
j were nonzero, each distributed as standard Gaussian variates and
chosen at random locations between 1 and p. Figure 5.7 shows the performance
of the generalized gradient and Nesterov’s method, for two different values of
the regularization parameter . We tried the algorithms using a fixed value of
the step-size st (equal to the reciprocal of the largest eigenvalue of 1
NXTX).
We also tried the approximate backtracking line search for st 2 [0, 0.5]. We
see that Nesterov’s momentum method yields substantial speedups, over the
generalized gradient, and backtracking is faster than the fixed stepsize choice.
In the latter comparison this does not even take into account the cost of
computing the largest eigenvalue of 1
NXTX: backtracking can speed up the
computation by allowing a larger stepsize to be used when it is appropriate.
Note that we are simply counting the number of iterations, rather than
measuring the total elapsed time; however the Nesterov momentum steps are
only slightly more costly than the generalized gradient steps. We also note
that the relative error and hence the iterates f(t) are not strictly monotone
decreasing for Nesterov’s momentum method.
}
COORDINATE DESCENT 109
5 10 15 20
1e−08 1e−06 1e−04 1e−02
Number of Steps k
Relative Error
Proximal gradient
   with backtrack
Nesterov momentum
   with backtrack
0 10 20 30 40 50
1e−07 1e−05 1e−03 1e−01
Number of Steps k
Relative Error
Sparse —  = 0.7 Dense —  = 0.05
Figure 5.7 Performance of the generalized gradient and Nesterov momentum methods
for a sample lasso problem described in the text. The vertical axis shows the error
measure [f(t) − f()]/f(), where  is the minimizer, and t is the solution
after t steps. On the left, the solution  is sparse with just 20 of the 500 coefficients
not equal to zero; on the right, 237 of the coefficients are nonzero.
In computational terms, the momentum updates (5.32) and (5.33) only involve
slightly more work than an ordinary gradient update. Nonetheless, Nesterov
(2007) proves that the change yields a significant improvement in convergence
rates: in particular, whenever g satisfies the Lipschitz condition (5.27),
then there is a constant C > 0 such that the iterates satisfy
f(t) − f() 
C
(t + 1)2 k0 − k2. (5.35)
Consequently, the error f(t)−f() decreases at the rate O(1/t2), as opposed
to the slower O(1/t) rate of a nonaccelerated method (see Equation (5.28)).
When g is strongly convex (5.29), the accelerated gradient method again enjoys
a geometric rate of convergence (5.30), although with a smaller contraction
factor . More precisely, the nonaccelerated method converges with
a contraction factor determined by the condition number of g, whereas the
accelerated variant converges according to the square root of this condition
number.
5.4 Coordinate Descent
Certain classes of problems, among them the lasso and variants, have an additional
separability property that lends itself naturally to a coordinate minimization
algorithm. Coordinate descent is an iterative algorithm that updates
110 OPTIMIZATION METHODS
from t to t+1 by choosing a single coordinate to update, and then performing
a univariate minimization over this coordinate. More precisely, if coordinate
k is chosen at iteration t, then the update is given by
t+1
k = arg min
k
f
􀀀
t1
, t2
, . . . , tk
−1, k, tk
+1, . . . , tp

, (5.36)
and t+1
j = t
j for j 6= k. A typical choice would be to cycle through the
coordinates in some fixed order. This approach can also be generalized to block
coordinate descent, in which the variables are partitioned into non-overlapping
blocks (as in the group lasso), and we perform minimization over a single block
at each round.
5.4.1 Separability and Coordinate Descent
When does this procedure converge to the global minimum of a convex function?
One sufficient (but somewhat restrictive) condition is that f be continuously
differentiable and strictly convex in each coordinate. However, the use
of various statistical regularizers leads to optimization problems that need not
be differentiable. For such cases, more care is required when using coordinate
minimization, because, as we discuss below, it can become “stuck” at nonoptimal
points. One form of problem structure that ensures good behavior
of coordinate minimization is a type of separability condition. In particular,
suppose that the cost function f has the additive decomposition
f(1, . . . p) = g(1, . . . p) +
Xp
j=1
hj(j), (5.37)
where g : Rp ! R is differentiable and convex, and the univariate functions
hj : R ! R are convex (but not necessarily differentiable). An important
example of this problem structure is the standard lasso program (2.5), with
g() = 1
2N ky − Xk22
and hj(j) =  · |j |. Tseng (1988, 2001) shows that
for any convex cost function f with the separable structure (5.37), the coordinate
descent Algorithm (5.36) is guaranteed to converge to the global
minimizer. The key property underlying this result is the separability of the
nondifferentiable component h() = Pp
j=1 hj(j ), as a sum of functions of
each individual parameter. This result implies that coordinate descent is a
suitable algorithm for the lasso as well as certain other problems discussed in
this book. In contrast, when the nondifferentiable component h is not separable,
coordinate descent is no longer guaranteed to converge. Instead, it is
possible to create problems for which it will become “stuck,” and fail to reach
the global minimum.
Example 5.7. Failure of coordinate descent. As an illustration, we consider
an instance of a problem that violates (5.37)—the fused lasso, discussed
in Section 4.5. Here the nondifferentiable component takes the form
h() = Pp
j=1 |j − j−1|. Figure 5.8 illustrates the difficulty. We created a
COORDINATE DESCENT 111
fused lasso problem with 100 parameters, with the solutions for two of the
parameters, 63 = 64  −1. The left and middle panels show slices of the
function f varying 63 and 64, with the other parameters set to the global
minimizers. We see that the coordinate-wise descent algorithm has got stuck
in a corner of the response surface, and is stationary under single-coordinate
moves. In order to advance to the minimum, we have to move both 63 and
64 together.
−1.0 −0.5 0.0
102.0 102.5 103.0 103.5 104.0
−1.0 −0.5 0.0
102.0 102.5 103.0 103.5 104.0
−1.0 −0.5 0.0
−1.0 −0.5 0.0
63 63
64
64
f()
f()
Figure 5.8 Failure of coordinate-wise descent in a fused lasso problem with 100
parameters. The optimal values for two of the parameters, 63 and 64, are both
−1.05, as shown by the dot in the right panel. The left and middle panels show
slices of the objective function f as a function of 63 and 64, with the other parameters
set to the global minimizers. The coordinate-wise minimizer over both 63
and 64 (separately) is -0.69, rather than −1.05. The right panel shows contours of
the two-dimensional surface. The coordinate-descent algorithm is stuck at the point
(−0.69,−0.69). Despite being strictly convex, the surface has corners, in which the
coordinate-wise procedure can get stuck. In order to travel to the minimum we have
to move both 63 and 64 together.
}
Tseng (2001) gives a more general and intuitive condition for convergence
of coordinate descent, one which depends on the behavior of the directional
derivatives of the cost function f. For a given direction  2 Rp, the lower
directional derivative at  is given by
f0(; ) := lim inf
s#0
f( + s) − f()
s
. (5.38)
In rough terms, a coordinate descent algorithm only gains information about
directions of the form ej =
􀀀
0, 0, . . . 0, ej , 0, . . . , 0

for some ej 2 R.
Therefore, suppose that the coordinate descent algorithm reaches a point 
for which
f0(; ej)  0 for all j = 1, . . . , p, and coordinate vectors ej . (5.39)
112 OPTIMIZATION METHODS
At any such point, there are no coordinate directions that will further reduce
the function value. Therefore, we require that any  satisfying the condition
(5.39) also satisfies f0(; )  0 for all directions  2 Rp. Tseng (2001)
calls this condition regularity. It rules out a situation like that of Figure 5.8,
in which moves along all coordinate directions fail to decrease the criterion,
but an oblique move does improve the criterion. As a side-note, it is worth
observing that separability of the nondifferentiable component of the objective
function implies regularity, but that there are nondifferentiable and nonseparable
functions that are still regular. An example is the function
h(1, . . . , p) = ||TP|| =
Xp
j,k=1 |j |Pjk|k|, (5.40)
where P is a symmetric positive definite matrix.
5.4.2 Linear Regression and the Lasso
Recall the optimization problem (2.5) that underlies the lasso estimator. As
discussed in Chapter 2, the optimality conditions for this problem are
−
1
N
XN
i=1
(yi − 0 −
Xp
k=1
xikk)xij + sj = 0, (5.41)
where sj 2 sign(j) for j = 1, 2, . . . , p. The coordinate descent procedure
simply solves these equations in a cyclical fashion, iterating over j =
1, 2, . . . , p, 1, 2, . . ..
Since the intercept 0 is typically not penalized, we can center both the
response yi and the covariate vectors xi by their means, and then omit the intercept
in the calculations of the other j . (Of course, as in OLS, the intercept
is calculated at the end using the b0 = ¯y −
Pp
k=1 ¯xk bk.) To simplify matters,
we define the partial residual r
(j)
i = yi −
P
k6=j xik bk, which removes from the
outcome the current fit from all but the jth predictor. Then the solution for
bj satisfies
bj = S

1
N
PN
i=1 r
(j)
i xij

1
N
PN
i=1 x2
ij
, (5.42)
whereas before S() = sign()(|| − )+ is the soft-thresholding operator. If
in addition to centering, the variables are standardized to have unit variance
(typically a good idea, especially if the variables are in different units), then
the update has the particularly succinct form
bj = S( ˜ j), (5.43)
where ˜ j is the simple linear regression coefficient of the partial residual on
COORDINATE DESCENT 113
variable j. If instead we have an elastic net penalty (1 − )2
j /2 + |j |, the
update (5.42) becomes
bj = S

1
N
PN
i=1 r
(j)
i xij

1
N
PN
i=1 x2
ij + (1 − )
, (5.44)
or in the standardized case
bj = S( ˜ j)
1 + (1 − )
. (5.45)
There are a number of strategies for making these operations efficient. For
ease of notation we assume that the predictors are standardized to have mean
zero and variance one; for nonstandardized data, the steps are similar.
Partial residuals. Note that we can write r
(j)
i = yi −
P
k6=j xik bk = ri +
xij bj , where ri denotes the current residual for observation i. Since the vectors
{xj}p
j=1 are standardized, we can write
1
N
XN
i=1
xijr
(j)
i = 1
N
XN
i=1
xijri + bj , (5.46)
a representation that reveals the computational efficiency of coordinate descent.
Many coefficients are zero and remain so after thresholding, and so
nothing needs to be changed. The primary cost arises from computing the
sum in Equation (5.46), which requires O(N) operations. On the other hand,
if a coefficient does change after the thresholding, ri is changed in O(N) and
the step costs O(2N). A full cycle through all p variables costs O(pN) operations.
Friedman et al. (2010b) refer to this as naive updating, since it works
directly with the inner products of the data.
Covariance updating. Naive updating is generally less efficient than covariance
updating when N  p and N is large. Up to a factor 1/N, we can write
the first term on the right of expression (5.46)
XN
i=1
xijri = hxj , yi −
X
k | |bk|>0
hxj , xkibk. (5.47)
In this approach, we compute inner products of each feature with y initially,
and then each time a new feature xk enters the model for the first time, we
compute and store its inner product with all the rest of the features, requiring
O(Np) operations. We also store the p gradient components (5.47). If one of
the coefficients currently in the model changes, we can update each gradient in
O(p) operations. Hence with k nonzero terms in the model, a complete cycle
costs O(pk) operations if no new variables become nonzero, and costs O(Np)
for each new variable entered. Importantly, each step does not require making
O(N) calculations.
114 OPTIMIZATION METHODS
Warm starts. Typically one wants a sequence of lasso solutions, say for a
decreasing sequence of values {`}L0
. It is easy to see that the largest value
that we need consider is
0 = 1
N max
j |hxj , yi|, (5.48)
since any value larger would yield an empty model. One strategy, as employed
by the R package glmnet, is to create a sequence of values {`}L
`=0 decreasing
from 0 down to L = 0  0 on a log scale. The solution b(`) is typically a
very good warm start for the solution b(`+1). Likewise the number of nonzero
elements tends to increase slowly with `, starting at zero at ` = 0. Doubling
the number L = 100 to say 2L does not double the compute time, since the
warm starts are much better, and fewer iterations are needed each time.
Active-set convergence. After a single iteration through the set of p variables
at a new value `, starting from the warm start b(`−1), we can define the
active set A to index those variables with nonzero coefficients at present.
The idea is to iterate the algorithm using only the variables in A. Upon
convergence, we do a pass through all the omitted variables. If they all pass
the simple exclusion test 1
N |hxj , ri| < `, where r is the current residual, we
have the solution for the entire set of p variables. Those that fail are included
in A and the process is repeated. In practice we maintain an ever-active set—
any variable that had a nonzero coefficient somewhere along the path until
present is kept in A.
Strong-set convergence. Similar to the above, we identify a subset of variables
likely to be candidates for the active set. Let r be the residual at b(`−1),
and we wish to compute the solution at `. Define the strong set S as
S = {j | | 1
N hxj , ri| > ` − (`−1 − `)}. (5.49)
We now compute the solution restricting attention to only the variables in
S. Apart from rare exceptions, the strong set will cover the optimal active
set. Strong rules are extremely useful, especially when p is very large (in the
100Ks or millions). We discuss them in some detail in Section 5.10.
Sparsity. The main computational operation in all the above is an innerproduct
of a pair of N-vectors, at least one of which is a column of the design
matrix X. If X is sparse, we can compute these inner products efficiently.
An example is document classification, where often the feature vector follows
the so-called “bag-of-words” model. Each document is scored for the presence/
absence of each of the words in the entire dictionary under consideration
(sometimes counts are used, or some transformation of counts). Since most
words are absent, the feature vector for each document is mostly zero, and
so the entire matrix is mostly zero. Such matrices can be stored efficiently in
sparse-column format, where we store only the nonzero entries and the coordinates
where they occur. Now when we compute inner products, we sum only
over the nonzero entries.
COORDINATE DESCENT 115
Penalty strength. The default formulation applies the same penalty parameter
 to each term in the model. It is a simple matter to include a relative
penalty strength 
j  0 per variable, making the overall penalty

Xp
j=1

jP(j). (5.50)
This allows for some 
j to be zero, which means those variables are always in
the model, unpenalized.
Parameter bounds. Coordinate descent also makes it easy to set upper and
lower bounds on each parameter:
Lj  j  Uj , (5.51)
where typically −1  Lj  0  Uj  1. For example, we sometimes want
to constrain all coefficients to be nonnegative. One simply computes the coordinate
update, and if the parameter violates the bound, it is set to the closest
boundary.
5.4.3 Logistic Regression and Generalized Linear Models
Here we move from squared-error loss to other members of the exponential
family—the so-called generalized linear models. For simplicity, we focus on the
most prominent (nonlinear) member of this class—namely, logistic regression.
In logistic regression, the response is binary, and can be modeled as a class
label G taking the values −1 or 1. The standard logistic model represents the
class probabilities as a linear model in the log-odds
log Pr(G = −1 | x)
Pr(G = 1 | x) = 0 + xT . (5.52)
See Section 3.2 for more detail.
We consider fitting this model by regularized maximum (binomial) likelihood.
Introducing the shorthand notation p(xi; 0, ) = Pr(G = 1|xi) for the
probability (5.52) of observation i, we maximize the penalized log-likelihood
1
N
XN
i=1

I(gi = 1) log p(xi; 0, ) + I(gi = −1) log(1 − p(xi; 0, ))
	
− P().
(5.53)
Denoting yi = I(gi = −1), the log-likelihood part of (5.53) can be written in
the more explicit form
`(0, ) = 1
N
XN
i=1
h
yi · (0 + xTi
) − log(1 + e0+xT
i )
i
, (5.54)
which corresponds to a concave function of the parameters. By way of
116 OPTIMIZATION METHODS
background, the Newton algorithm for maximizing the (unpenalized) loglikelihood
(5.54) amounts to iteratively reweighted least squares. Hence,
if the current estimates of the parameters are (e0, e), we form a secondorder
Taylor expansion about current estimates. In terms of the shorthand
˜p(xi) = p(xi; e0, e), and wi = ˜p(xi)(1 − ˜p(xi)), this Taylor expansion leads to
the quadratic objective function
`Q(0, ) = −
1
2N
XN
i=1
wi(zi − 0 − xTi
)2 + C(f0, e)2. (5.55)
where zi = e0 + xTi
e + yi−˜p(xi)
˜p(xi)(1−˜p(xi)) is the current working response. The
Newton update is obtained by minimizing `Q, which is a simple weightedleast-
squares problem. In order to solve the regularized problem, one could
apply coordinate descent directly to the criterion (5.53). A disadvantage of
this approach is that the optimizing values along each coordinate are not
explicitly available and require a line search. In our experience, it is better to
apply coordinate descent to the quadratic approximation, resulting in a nested
algorithm. For each value of , we create an outer loop which computes the
quadratic approximation `Q about the current parameters ( ˜ 0, ˜ ). Then we
use coordinate descent to solve the penalized weighted least-squares problem
minimize
(0,)2Rp+1 {−`Q(0, ) + P()} . (5.56)
By analogy with Section 5.3.3, this is known as a generalized Newton algorithm,
and the solution to the minimization problem (5.56)) defines a proximal
Newton map (see the paper (Lee et al. 2014) for details). Overall, the procedure
consists of a sequence of nested loops:
outer loop: Decrement .
middle loop: Update the quadratic approximation `Q using the current parameters
( ˜ 0, ˜ ).
inner loop: Run the coordinate descent algorithm on the penalized
weighted-least-squares problem (5.56).
When p  N, one cannot run  all the way to zero, because the saturated
logistic regression fit is undefined (parameters wander off to ±1 in
order to achieve probabilities of 0 or 1). Also, the Newton algorithm is not
guaranteed to converge without step-size optimization (Lee, Lee, Abneel and
Ng 2006). The glmnet program does not implement any checks for divergence;
this would slow it down, and when used as recommended, it does not seem to
be necessary. We have a closed form expression for the starting solutions, and
each subsequent solution is warm-started from the previous close-by solution,
which generally makes the quadratic approximations very accurate. We have
not encountered any divergence problems so far.
The glmnet package generalizes this procedure to other GLMs, such as
A SIMULATION STUDY 117
multiclass logistic regression, the Poisson log-linear model and Cox’s proportional
hazards model for survival data. More details are given in Chapter 3.
The speed of this procedure is studied in Section 5.5.
5.5 A Simulation Study
Both the coordinate descent algorithm and Nesterov’s composite gradient
method are simple and computationally efficient approaches for solving the
lasso. How do they compare in terms of computational cost per iteration? If
(at a given iteration) the current iterate t has k nonzero coefficients, each
pass of coordinate descent over all p predictors (using naive updating) takes
O(pN + kN) operations. On the other hand, the generalized gradient update
(5.31) requires O(kN) operations to compute the matrix-vector product
X, and then O(pN) to compute the product XT (y − X), again a total of
O(pN + kN) operations.
In order to examine more closely the relative efficiency of coordinate descent,
proximal gradient descent, and Nesterov’s momentum method, we carried
out a small simulation study.3 We generated an N × p predictor matrix
X with standard Gaussian entries and pairwise correlation 0 or 0.5 between
the features. Coefficients j were defined by |j | = exp[−.5(u(j − 1))2] with
u =
p
/20 and alternating signs +1,−1, +1, . . .. Then the outcome yi was
generated as
yi =
Xp
j=1
xijj + "i (5.57)
with  chosen so that the signal to noise ratio Sd[E(yi)]/ equals 3. Table 5.1
shows the average (standard error) of CPU times for coordinate descent, generalized
gradient and Nesterov’s momentum methods, for a scenario with N > p
and another with N < p. Shown is the total time over a path of 20 values
of the regularization parameter. Warm starts were used in each case, with
Table 5.1 Lasso for linear regression: Average (standard error) of CPU times over
ten realizations, for coordinate descent, generalized gradient, and Nesterov’s momentum
methods. In each case, time shown is the total time over a path of 20  values.
N = 10000, p = 100 N = 200, p = 10000
Correlation 0 0.5 0 0.5
Coordinate descent 0.110 (0.001) 0.127 (0.002) 0.298 (0.003) 0.513 (0.014)
Proximal gradient 0.218 (0.008) 0.671 (0.007) 1.207 (0.026) 2.912 (0.167)
Nesterov 0.251 (0.007) 0.604 (0.011) 1.555 (0.049) 2.914 (0.119)
convergence defined as the maximum change in the parameter vector being
less than 10−4. An approximate backtracking line search was used for the
3We thank Jerome Friedman for the programs used in this section.
118 OPTIMIZATION METHODS
Table 5.2 Lasso for logistic regression: average (standard error) of CPU times over
ten realizations, for coordinate descent, generalized gradient, and Nesterov’s momentum
methods. In each case, time shown is the total time over a path of 20  values.
N = 10000, p = 100 N = 200, p = 10000
Correlation 0 0.5 0 0.5
Coordinate descent 0.309 (0.086) 0.306 (0.086) 0.646 (0.006) 0.882 (0.026)
Proximal gradient 2.023 (0.018) 6.955 (0.090) 2.434 (0.095) 4.350 (0.133)
Nesterov 1.482 (0.020) 2.867 (0.045) 2.910 (0.106) 8.292 (0.480)
latter two methods. We see that coordinate descent is 2–6 times faster than
the other methods, with a greater speedup in the p > N case. Interestingly,
momentum does not provide a consistent speedup over proximal gradient descent,
as the aforementioned theory would suggest. Our investigation into this
suggests that the warm starts are the reason: by starting close to the solution,
the “zig-zagging”, that is ameliorated by the momentum term, is not nearly
as much of a problem as it is when starting far from the solution.
Table 5.2 shows the corresponding results for logistic regression. The predictors
were generated as before, but now there are 15 nonzero j with alternating
signs, and |j | = 15−j+1. Then defining pi = 1/(1+exp(−
P
xijj))
we generate 0/1 yi with Prob(yi = 1) = pi.
We see that coordinate descent is 5–10 times faster than the other methods,
with a greater speedup in the p > N case. Again, momentum does not provide
a consistent speedup over proximal gradient descent.
The reader should take comparisons like those above with a grain of salt, as
the performance of a method will depend on the details of its implementation.
Further suspicion should arise, since two of the authors of this text are coauthors
of the method (coordinate descent) that performs best. For our part,
we can only say that we have tried to be fair to all methods and have coded all
methods as efficiently as we could. More importantly, we have made available
all of the scripts and programs to generate these results on the book website,
so that the reader can investigate the comparisons further.
5.6 Least Angle Regression
Least angle regression, also known as the homotopy approach, is a procedure
for solving the lasso with squared-error loss that delivers the entire solution
path as a function of the regularization parameter . It is a fairly efficient
algorithm, but does not scale up to large problems as well as some of the other
methods in this chapter. However it has an interesting statistical motivation
and can be viewed as a kind of “democratic” version of forward stepwise
regression.
Forward stepwise regression builds a model sequentially, adding one variable
at a time. At each step, it identifies the best variable to include in the
active set, and then updates the least-squares fit to include all the active variLEAST
ANGLE REGRESSION 119
ables. Least angle regression (LAR) uses a similar strategy, but only enters “as
much” of a predictor as it deserves. At the first step it identifies the variable
most correlated with the response. Rather than fit this variable completely,
the LAR method moves the coefficient of this variable continuously toward
its least-squares value (causing its correlation with the evolving residual to
decrease in absolute value). As soon as another variable catches up in terms
of correlation with the residual, the process is paused. The second variable
then joins the active set, and their coefficients are moved together in a way
that keeps their correlations tied and decreasing. This process is continued
until all the variables are in the model, and ends at the full least-squares fit.
The details are given in Algorithm 5.1. Although the LAR algorithm is stated
in terms of correlations, since the input features are standardized, it is equivalent
and easier to work with inner products. The number of terms K at step 3
requires some explanation. If p > N − 1, the LAR algorithm reaches a zero
residual solution after N − 1 steps (the −1 is because there is an intercept in
the model, and we have centered the data to take care of this).
Algorithm 5.1 Least Angle Regression.
1. Standardize the predictors to have mean zero and unit `2 norm. Start with
the residual r0 = y − ¯y, 0 = (1, 2, . . . , p) = 0.
2. Find the predictor xj most correlated with r0; i.e., with largest value for
|hxj , r0i|. Call this value 0, define the active set A = {j}, and XA, the
matrix consisting of this single variable.
3. For k = 1, 2, . . . ,K = min(N − 1, p) do:
(a) Define the least-squares direction  = 1
k−1 (XT
AXA)−1XT
Ark−1, and define
the p-vector  such that A = , and the remaining elements are
zero.
(b) Move the coefficients  from k−1 in the direction  toward their leastsquares
solution on XA: () = k−1 + (k−1 − ) for 0 <   k−1,
keeping track of the evolving residuals r() = y − X() = rk−1 ( − k−1 − )X.
(c) Keeping track of |hx`, r()i| for ` /2 A, identify the largest value of 
at which a variable “catches up” with the active set; if the variable has
index j, that means |hxj , r()i| = . This defines the next “knot” k.
(d) Set A = A[{j}, k = (k) = k−1+(k−1−k), and rk = y−Xk.
4. Return the sequence {k, k}K0
.
We make a few observations to clarify the steps in the algorithm. In step 3b,
it is easy to check that |hxj , r()i| = , 8j 2 A—that is, the correlations
remain tied along this path, and decrease to zero with . In fact 0 = k−1 +
k−1 is the least-squares coefficient vector corresponding to the subset A.
By construction the coefficients in LAR change in a piecewise linear fashion.
Figure 5.9 [left panel] shows the LAR coefficient profile evolving as a
120 OPTIMIZATION METHODS
0 5 10 15
−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5
Coefficients
Least Angle Regression
0 5 10 15 20
−1.5 −1.0 −0.5 0.0 0.5 1.0 1.5
Coefficients
Lasso
`1 Arc Length `1 Arc Length
Figure 5.9 Left panel shows the LAR coefficient profiles on the simulated data, as
a function of the L1 arc length. The right panel shows the lasso profile. They are
identical until the red coefficient crosses zero at an arc length of about 16.
function of their `1 arc length. 4 Note that we do not need to take small steps
and recheck the correlations in step 3c. Variable ` “catching up” means that
|hx`, r()i| = , a pair of equations linear in . We solve for  for each ` 2/ A and pick the largest (Exercise 5.9).
The right panel of Figure 5.9 shows the lasso coefficient profiles on the
same data. They are almost identical to those in the left panel, and differ
for the first time when the pink coefficient passes back through zero. These
observations lead to a simple modification in step 3c of the LAR algorithm
that gives the entire lasso path, which is also piecewise-linear:
3(c)+ lasso modification: If a nonzero coefficient crosses zero before the next
variable enters, drop it from A and recompute the current joint leastsquares
direction.
Notice in the figure that the pink coefficient remains zero for a while, and then
it becomes active again, but this time negative.
We can give a heuristic argument for why these procedures are so similar.
As observed, we have at any stage of the algorithm
xT
j (y − X()) =  · sj , 8j 2 A, (5.58)
where sj 2 {−1, 1} indicates the sign of the inner-product, and  is the com-
4The `1 arc-length of a differentiable curve {s 7! (s) | s 2 [0, S]} is given by
TV(, S) =
R S
0 k˙ (s)k1ds, where ˙(s) = @(s)/@s. For the piecewise-linear LAR coefficient
profile, this amounts to summing the `1-norms of the changes in coefficients from step
to step.
ALTERNATING DIRECTION METHOD OF MULTIPLIERS 121
mon value. Also by definition of the LAR active set, |xT
k (y−X())|   8k 62
A. Now consider the lasso criterion5
R() = 1
2ky − Xk22
+ kk1. (5.59)
Let B be the active set of variables in the solution for a given value of . For
these variables R() is differentiable, and the stationarity conditions give
xT
j (y − X) =  · sign(j), 8j 2 B. (5.60)
Comparing (5.60) with (5.58), we see that they are identical only if the sign
of j matches the sign of the inner product. That is why the LAR algorithm
and lasso start to differ when an active coefficient passes through zero; condition
(5.60) is violated for that variable, and it is removed from the active set
B in step 3(c)+. Exercise 5.9 shows that these equations imply a piecewiselinear
coefficient profile as  decreases, as was imposed in the LAR update.
The stationarity conditions for the nonactive variables require that
|xT
k (y − X)|  , 8k 62 B, (5.61)
which again agrees with the LAR algorithm.
The LAR algorithm exploits the fact that the coefficient paths for the lasso
are piecewise linear. This property holds for a more general class of problems;
see Rosset and Zhu (2007) for details.
5.7 Alternating Direction Method of Multipliers
The alternating direction method of multipliers (ADMM) is a Lagrangianbased
approach that has some attractive features for large-scale applications.
It is based on a marriage of different ideas that developed over a long period
of time. Here we provide a brief overview, referring the reader to Boyd et
al. (2011) for a comprehensive discussion.
Consider a problem of the form
minimize
2Rm,2Rn
f() + g() subject to A + B = c, (5.62)
where f : Rm ! R and g : Rn ! R are convex functions, and A 2 Rd×m
and B 2 Rd×n are (known) matrices of constraints, and c 2 Rd is a constraint
vector. To solve this problem we introduce a vector μ 2 Rd of Lagrange
multipliers associated with the constraint, and then consider the augmented
Lagrangian
L(, , μ) := f() + g() + hμ, A + B − ci + 
2 kA + B − ck22
, (5.63)
5We have omitted the factor 1
N , to stay faithful to the original LAR procedure; all values
of  are hence larger by a factor of N.
122 OPTIMIZATION METHODS
where  > 0 is a small fixed parameter. The quadratic term involving  is an
augmented Lagrangian that enforces the constraint in a smoother fashion. The
ADMM algorithm is based on minimizing the augmented Lagrangian (5.63)
successively over  and , and then applying a dual variable update to μ.
Doing so yields the updates
t+1 = arg min
2Rm
L(, t, μt) (5.64a)
t+1 = arg min
2Rn
L(t+1, , μt) (5.64b)
μt+1 = μt + 
􀀀
At+1 + Bt+1 − c

, (5.64c)
for iterations t = 0, 1, 2, . . .. The update (5.64c) can be shown to be a dual
ascent step for the Lagrange multiplier vector μ. Under relatively mild conditions,
one can show that this procedure converges to an optimal solution to
Problem (5.62).
The ADMM framework has several advantages. First, convex problems
with nondifferentiable constraints can be easily handled by the separation of
parameters into  and . We illustrate this procedure via application to the
lasso, as discussed in the example to follow. A second advantage of ADMM is
its ability to break up a large problem into smaller pieces. For datasets with
large number of observations we break up the data into blocks, and carry out
the optimization over each block. As discussed in more detail in Exercise 5.12,
constraints are included to ensure that the solution vectors delivered by the
optimization over each data block agree with one another at convergence. In
a similar way, the problem can be split up into feature blocks, and solved in
a coordinated blockwise fashion.
Example 5.8. ADMM for the lasso. The Lagrange form of the lasso can be
expressed in equivalent form as
minimize
2Rp,2Rp
1
2ky − Xk22
+ kk1

such that  −  = 0. (5.65)
When applied to this problem, the ADMM updates take the form
t+1 = (XTX + I)−1(XT y + t − μt)
t+1 = S/(t+1 + μt/)
μt+1 = μt + (t+1 − t+1).
(5.66)
Thus, the algorithm involves a ridge regression update for , a softthresholding
step for  and then a simple linear update for μ. The first step
is the main work, and after an initial singular value decomposition of X,
subsequent iterations can be done quickly. The initial SVD requires O(p3)
operations, but can be done off-line, whereas subsequent iterations have cost
O(Np). Consequently, after the start-up phase, the cost per iteration is similar
to coordinate descent or the composite gradient method. }
MINORIZATION-MAXIMIZATION ALGORITHMS 123
5.8 Minorization-Maximization Algorithms
In this section, we turn to a class of methods, known either as minorizationmaximization
or majorization-minimization (MM) algorithms, that are especially
useful for optimization of nonconvex functions. These belong to the class
of auxiliary-variable methods, in that they are based on introducing extra variables
and using them to majorize (or upper bound) the objective function to
be minimized. Although these methods apply more generally to constrained
problems, here we describe them in application to a simple unconstrained
problem of the form minimize2Rp f(), where f : Rp ! R is a (possibly)
nonconvex function.
A function 	 : Rp × Rp 7! R1 majorizes the function f at a point  2 Rp
if
f()  	(, ) for all  2 Rp (5.67)
with equality holding when  = . (Naturally, there is a corresponding definition
of minorization, with the inequality reversed in direction.) Figure 5.10
shows a schematic of a majorizing function.
 
f()
	(, )
Figure 5.10 Illustration of a majorizing function for use in an MM algorithm. The
function 	(, ) lies on or above f() for all  and is equal to f() when  = .
The MM algorithm seeks to minimize the target function f by solving a sequence of
subproblems involving the majorizing function 	 and the current iterate.
An MM algorithm for performing an unconstrained minimization of f involves
initializing 0, and then updating via the recursion
t+1 = arg min
2Rp
	
􀀀
, t
for t = 0, 1, 2, . . .. (5.68)
By the majorization property (5.67), this scheme generates a sequence for
which the cost f(t) is nonincreasing. In particular, we have
f(t) = 	(t, t)
(i)
 	(t+1, t)
(ii)
 f(t+1), (5.69)
124 OPTIMIZATION METHODS
where inequality (i) uses the fact that t+1 is a minimizer of the function
 7! 	(, t), and inequality (ii) uses the majorization property (5.67). If the
original function f is strictly convex, it can be shown the MM algorithm
converges to the global minimizer.
There are different classes of majorizing functions that are useful for different
problems. In general, a good majorization function is one for which
the update (5.68) is relatively easy to compute, at least relative to direct
minimization of f. See Lange (2004) for more details.
Example 5.9. Proximal gradient as an MM algorithm. Recall from Section
5.3.3 the proximal gradient algorithm that can be applied to cost functions
that decompose as a sum f = g +h, where g is convex and differentiable, and
h is convex and (potentially) nondifferentiable. By applying a second-order
Taylor series expansion (with remainder) to g, we obtain
f() = g() + h()
= g() + hrg(),  − i + 1
2


 − ,r2g
􀀀
0􀀀
 − 

+ h(),
where 0 = s + (1 − s) for some s 2 [0, 1]. It can be verified that Lipschitz
condition (5.27) on the gradient rg implies a uniform upper bound on the
Hessian, namely r2g(0)  L Ip×p, from which we obtain the inequality
f()  g() + hrg(),  − i + L2
k − k22+ h()
| {z }
	(,)
,
with equality holding when  = . Thus, we see that the proximal gradient
method can be viewed as an MM algorithm with a particular choice of
majorizing function. }
Apart from a direct bound on the Hessian, there are other ways of deriving
majorizing functions, For example, Jensen’s inequality can be used to derive
the usual EM algorithm as an instance of an MM algorithm (Hunter and
Lange 2004, Wu and Lange 2010). As we discuss in Chapter 8, MM algorithms
turn out to be useful in procedures for sparse multivariate analysis.
5.9 Biconvexity and Alternating Minimization
Recall the class of coordinate descent algorithms discussed in Section 5.4.
Algorithms of this form are also useful for optimizing a class of (potentially)
nonconvex functions known as biconvex functions. A function f : Rm×Rn ! R
is biconvex if for each  2 Rn, the function  7! f(, ) is convex, and for
each  2 Rm, the function  7! f(, ) is convex. Of course, any function
that is jointly convex in the pair (, ) is also biconvex. But a function can
be biconvex without being jointly convex. For instance, consider the biconvex
function
f(, ) = (1 − )2 for ||  2, ||  2. (5.70)
BICONVEXITY AND ALTERNATING MINIMIZATION 125
As illustrated in Figure 5.11, it is convex when sliced along lines parallel to
the axes, as required by the definition of biconvexity, but other slices can lead
to nonconvex functions.
−2 −1 0 1 2
0 5 10 15 20 25
−2 −1 0 1 2
0 2 4 6 8
−2 −1 0 1 2
0 2 4 6 8




f(, 2)
f(−1, )
f(t, t)
t
f(, )
Figure 5.11 Example of a biconvex function. Shown in the top left is the function
f(, ) = (1 − )2 over the range −2  ,   2. The top right and bottom left
panels show slices of the function for  = 2 and  = −1. The bottom right panel
shows the function along the line  =  = t.
More generally, let A  Rm and B  Rn be two nonempty and convex
sets, and let C  A × B. For each fixed  2 A and  2 B, the sets
C := { 2 B | (, ) 2 C}, and C := { 2 A | (, ) 2 C} (5.71)
are called the  and  sections of C. The set C  A × B is called a biconvex
set if the section C is convex for each  2 A, and the section C is convex
for every  2 B. Given a biconvex set C, a function f : C ! R is a biconvex
function if the function  7! f(, ) is convex in  for each fixed  2 B, and
the function  7! f(, ) is convex in  for each fixed  2 A.
Given these ingredients, a biconvex optimization problem has the form
minimize(,)2C f(, ), where the set C is biconvex on A×B, and the objective
function is biconvex on C.
The most obvious method for solving a biconvex optimization problem is
126 OPTIMIZATION METHODS
based on Alternate Convex Search (ACS), which is simply block coordinate
descent applied to the  and  blocks:
(a) Initialize (0, 0) at some point in C.
(b) For iterations t = 0, 1, 2, . . .:
1. Fix  = t, and perform the update t+1 2 arg min2Ct f(, t).
2. Fix  = t+1, and perform the update t+1 2 arg min2Ct+1 f(t+1, ).
Given the biconvex structure, each of the two updates involve solving a convex
optimization problem. The ACS procedure will be efficient as long as these
convex sub-problems can be solved relatively quickly.
By construction, the sequence of function values {f(t, t)}1
t=0 is nonincreasing.
Consequently, if f is bounded from below over C, then the function
values converge to some limiting value. We note that this form of convergence
is relatively weak, and only ensures that the function values converge. The solution
sequence {(t, t} may not converge, and in some cases may diverge to
infinity. Assuming convergence, to what does the solution sequence converge?
Since a biconvex function f need not be convex in general, we cannot expect
it to converge to the global minimum. All we can say in general is that if it
converges, it converges to a partial optimum.
More specifically, we say that (, ) 2 C is a partial optimum if
f(, )  f(, ) for all  2 C , and
f(, )  f(, ) for all  2 C .
Example 5.10. Alternating subspace algorithm. One biconvex problem in which
convergence of ACS can be fully characterized is the alternating subspace algorithm
for computing the maximal singular vectors/value of a matrix. Given
a matrix X 2 Rm×n, consider the problem of finding the best rank-one approximation
in the Frobenius norm.6 This approximation problem can be
formulated in terms of minimizing the objective function
f(, , s) = kX − s T k2
F (5.72)
over vectors  2 Rm and  2 Rn, with kk2 = kk2 = 1, and a scalar
s > 0. The ACS procedure for this problem starts with any random unitnorm
initialization for 0, and then for iterations t = 1, 2, . . ., it performs the
updates
t = Xt−1
kXt−1k2
, and t = XTt
kXTtk2
. (5.73)
The scalar s can be computed as s = kXtk2 at convergence. It can be shown
(see Exercise 5.13 that as long as 0 is not orthogonal to the largest right
6The Frobenius norm of a matrix is the Euclidean norm applied to its vectorized version.
SCREENING RULES 127
singular vector, the iterates (t, t) converge to the left and right singular
vectors of X corresponding to the largest singular value of X.
The procedure is related to the power method for finding the largest eigenvector
of a symmetric positive semi-definite matrix. The t iterates for the
right singular vector have the form
t+1 = XTXt
kXTXtk2
, (5.74)
with similar updates for t in terms of XXT . Consequently, the procedure
simply “powers up” the operator XTX, with the normalization driving all
but the largest eigenvalue to zero. See De Leeuw (1994) and Golub and Loan
(1996, §7.3) for further details on the power method. }
In Chapter 7, we present Algorithm 7.2 on page 189 as another example
of an ACS procedure.
5.10 Screening Rules
As seen in Section 5.6, inner products play an important role in the lasso
problem. For simplicity we assume all variables are mean centered (so we can
ignore the intercept), and we consider solving the lasso problem7
minimize
2Rp
1
2ky − Xk22
+ kk1 (5.75)
with a decreasing sequence of values for . The first variable to enter the
model has largest absolute inner-product max = maxj |hxj , yi|, which also
defines the entry value for . Also, at any stage, all variables xj in the active
set have |hxj , y−ˆyi| = , and all those out have smaller inner-products with
the residuals. Hence one might expect a priori that predictors having small
inner products with the response are not as likely to have a nonzero coefficient
as compared to those with larger inner products. Based on this intuition, one
might be able to eliminate predictors from the problem, and thereby reduce
the computational load. For example, in some genomic applications we might
have millions of variables (SNPs), and anticipate fitting models with only a
handful of terms. In this section, we discuss screening rules that exploit this
intuition, and have the potential to speed up the computation substantially
while still delivering the exact numerical solution.
We begin our discussion with the “dual polytope projection” (DPP) rule
(Wang, Lin, Gong, Wonka and Ye 2013). Suppose we wish to compute a lasso
solution at  < max. The DPP rule discards the jth variable if
|xT
j y| < max − kxjk2kyk2
max − 

(5.76)
7In this section we have omitted the 1
N in the first part of the objective (to match the
referenced formulas); this increases the scale of  by a factor N.
128 OPTIMIZATION METHODS
It may come as a surprise that such a rule can work, as it surprised us
when we first saw it. We know that in a linear regression, a predictor can
be insignificant on its own, but can become significant when included in the
model with other predictors. It seems that the same phenomenon should occur
with the lasso.
In fact, there is no contradiction, and a similar rule applies at any stage of
the regularization path (not just the start). Suppose we have the lasso solution
ˆ (0) at 0, and we wish to screen variables for the solution at  < 0. Then if

xT
j
􀀀
y − Xˆ (0)

< 0 − kxjk2kyk2
0 − 

, (5.77)
variable j is not part of the active set at . We refer to this as the sequential
DPP rule.
Figure 5.12 shows the performance of this rule on a simulated example
with 5000 predictors (details in caption). The global DPP applies rule (5.76)
for all values of , and we can see it quickly runs out of steam. By the time
 is small enough to admit 8 predictors into the model, all 5000 predictors
survive the screen. But the sequential DPP rule is much more aggressive, and
even with 250 predictors in the model, only 1200 need to be considered. So
the sequential screening rule (5.77) works much better if 0 and  are close
together. We derive the lasso dual and the DPP rules in Appendix B on
Page 132.
In order to achieve even better performance, it is natural to consider screening
rules that are less conservative, and allow for occasional failures. Such rules
can be incorporated as part of an overall strategy that still yields the exact solution
upon termination. A variant of the global DPP rule (5.76) is the global
strong rule, which discards predictor j whenever
|xT
j y| <  − (max − ) = 2 − max. (5.78)
This tends to discard more predictors than the global DPP rule (compare
blue with orange points in Figure 5.12.) Similarly the sequential strong rule
discards the jth predictor from the optimization problem at  if

xT
j
􀀀
y − Xˆ (0)

< 2 − 0. (5.79)
Intuitively, the active set will include predictors that can achieve inner-product
 with the residuals. So we include all those that achieve inner product close
to  using the current residuals at 0 > , where close is defined by the gap
0 − .
As with the sequential DPP rule, the sequential strong rule is based on
solving the lasso over a grid of decreasing  values. Figure 5.12 includes the
global and sequential strong rules. In both cases they dominate the DPP counterparts.
Neither of the strong rules make any errors in this example, where an
error means that it discards some predictor with a nonzero coefficient in the
SCREENING RULES 129
0 50 100 150 200 250
0 1000 2000 3000 4000 5000
Number of Predictors in Model
Number of Predictors after Filtering
global DPP
global STRONG
sequential DPP
sequential STRONG
Percent Variance Explained
0 0.15 0.3 0.49 0.67 0.75 0.82 0.89 0.96 0.97 0.99 1 1 1
Figure 5.12 Lasso regression: Results of different rules applied to a simulated
dataset. There are N = 200 observations and p = 5000 uncorrelated Gaussian predictors;
one-quarter of the true coefficients are nonzero. Shown are the number of
predictors left after screening at each stage, plotted against the number of predictors
in the model for a given value of . The value of  is decreasing as we move from left
to right. In the plots, we are fitting along a path of 100 decreasing  values equally
spaced on the log-scale, A broken line with unit slope is added for reference. The
proportion of variance explained by the model is shown along the top of the plot.
There were no violations for either of the strong rules.
130 OPTIMIZATION METHODS
actual solution. The sequential strong rule (5.79) has remarkable performance,
discarding almost all of the redundant predictors.
We now give further motivation for the strong rules (Tibshirani, Bien,
Friedman, Hastie, Simon, Taylor and Tibshirani2 2012). Suppose that predictor
j is not in the model at  = max. The KKT conditions for the lasso then
ensure that |xT
j y| < max, so that the global rule (5.78) can be interpreted as
dictating that as we move from max to , the inner product |xT
j (y−Xˆ ()) can increase by at most  | max −. Consequently, if the inner product is below
the strong bound  − (max − ), it cannot reach the necessary level  for
inclusion in the model, where we have again used the KKT conditions in our
reasoning. If we define cj() := xT
j (y − Xˆ ()), then for either the global or
sequential strong rules to hold, it would be sufficient to have

dcj()
d

 1, (5.80)
assuming that this derivative exists.8 Now the KKT conditions at  are
cj() =  sj(), for j = 1, 2, . . . , p, (5.81)
where sj() = sign( ˆ j()) if ˆ j() 6= 0 and sj() 2 [−1, 1] if ˆ j() = 0. By
the chain rule
dcj()
d
= sj() +  ·
dsj()
d
.
If we ignore the second term, then we have |dcj ()
d |  1. Now the second term
equals zero when a variable has a nonzero coefficient in an interval of  values,
for then sj() is constant (equaling ±1). In addition, the slope condition (5.80)
always holds if (XTX)−1 is diagonally dominant (Tibshirani et al. 2012), a
condition meaning that the predictors are nearly uncorrelated. In general,
however, the slope condition can fail over short stretches of , and in these
instances, the strong rules can fail (i.e., discard predictors in error). However
these failures are rare, and are virtually nonexistent when p  N.
In summary, we have found empirically that the strong rules, and especially
the sequential strong rule (5.79) seem to be very good heuristics for discarding
variables. This is the case in the lasso, lasso-penalized logistic regression, and
the elastic net.
One can use the sequential strong rule to save computation time, without
sacrificing the exact solution, as follows. We compute the solution along a fine
grid of decreasing  values. For each value of , the screening rule is applied,
yielding a subset of the predictors. Then the problem is solved using only this
subset. The KKT conditions (5.81) for all predictors are then checked. If they
are satisfied, we are done. Otherwise the predictors that violate the conditions
8The arguments here are only heuristic, because dcj ()/d and dsj ()/d discussed
below it do not exist at ˆj () = 0.
BIBLIOGRAPHIC NOTES 131
are added to the active set and the problem is solved again. In principle this
must be iterated until no violations occur.
This approach is effective computationally because violations of the strong
rule turn out to be rare, especially when p  N. Tibshirani et al. (2012)
implement these rules for the coordinate descent approach in glmnet and the
generalized gradient and Nesterov first-order methods. They report speedup
factors in the range from 2 to 80, depending on the setting.
Finally, suppose instead that we are interested in a more general convex
problem of the form
minimize


f() + 
Xr
j=1
cjkjkpj
	
. (5.82)
Here f is a convex and differentiable function, and  = (1, 2, . . . r) with
each j being a scalar or a vector. Also   0, and cj  0, pj  1 for
each j = 1, . . . r. Then given 0 > , the sequential strong rule for discarding
predictor j takes the form



rjf
􀀀 ˆ (0)



qj
< cj(2 − 0), (5.83)
where rjf( ˆ ) = (@f( ˆ )/@j1 , . . . @f( ˆ )/@jm) where 1/pj + 1/qj = 1 (i.e.,
k · kpj and k · kqj are dual norms). The rule (5.83) can be applied to a wide
variety of problems, including logistic regression and other generalized linear
models, the group lasso and the graphical lasso.
Bibliographic Notes
The behavior of descent algorithms, including convergence proofs for methods
based on appropriate stepsize selection rules, such as limited minimization
or the Armijo rule, is a classical subject in optimization; see Chapters 1 and
2 of Bertsekas (1999) for more details. Further background on Lagrangian
methods and duality can be found in Bertsekas (1999), as well as Boyd and
Vandenberghe (2004). Rockafellar (1996) provides a more advanced treatment
of convex duality and convex analysis. Nesterov (2007) derives and analyzes
the generalized gradient method (5.21) for composite objectives; see
also Nesterov’s book (2004) for related analysis of projected gradient methods.
Minorization-maximization procedures, also known as auxiliary function
methods, are discussed in Lange (2004) and Hunter and Lange (2004).
Gorski, Pfeuffer and Klamroth (2007) provide an overview of biconvex
functions, and alternating algorithms for optimizing them. El Ghaoui, Viallon
and Rabbani (2010) introduced the use of screening rules such as (5.76);
inspired by this work, we derived a very similar formula, and which led to
our development of the strong rules in Section 5.10. However, the more recent
DPP rules of Wang, Lin, Gong, Wonka and Ye (2013) dominate these earlier
safe rules, and provide a simple sequential formula. Fu (1998) was an early
proponent of coordinate descent for the lasso.
132 OPTIMIZATION METHODS
Appendix A: The Lasso Dual
In this appendix, we derive a useful dual of the lasso primal problem (2.5),
which we write in a slightly more convenient form
Lasso Primal: minimize
2Rp
1
2ky − Xk22
+ kk1. (5.84)
Introducing the residual vector r = y−X, we can rewrite the primal Equation
(5.84) as
minimize
2Rp
1
2krk22
+ kk1 subject to r = y − X. (5.85)
Letting  2 RN denote a Lagrange multiplier vector, the Lagrangian of this
problem can be written as
L(, r, ) := 1
2krk22
+ kk1 − T (r − y + X). (5.86)
The dual objective is derived by minimizing this expression (5.86) with respect
to  and r. Isolating those terms involving , we find
min
2Rp −TX + kk1 =
(
0 if kXT k1  
−1 otherwise
(5.87)
where kXT k1 = maxj |xT
j |. Next we isolate terms involving r and find
min
r
1
2krk22
− T r = −
1
2T , (5.88)
with r = . Substituting relations (5.87) and (5.88) into the Lagrangian representation
(5.86), we obtain
Lasso Dual: maximize

1
2{kyk22 − ky − k22
} subject to kXT k1  . (5.89)
Overall, this form of the lasso dual amounts to projecting y onto the feasible
set F = { 2 RN | kXT k1  }. F is the intersection of the 2p halfspaces
defined by {|xT
j |  }p
j=1, a convex-polytope in RN. In the language
of Section 5.3.3, the solution is given by the proximal map  = proxI(F)(y).
Figure 5.13 provides an illustration of this geometric interpretation.
Appendix B: Derivation of the DPP Rule
Here we derive the sequential DPP screening rule (5.77); our proof follows
that in Wang, Lin, Gong, Wonka and Ye (2013). We first modify the lasso
dual via a change of variables  = /, leading to
maximize

1
2

kyk22
− 2ky/ − k22
	
subject to kXTk1  1. (5.90)
APPENDIX 133
|xT1
| = 
|xT2
| = 
|xT5
| = 
|xT4
| = 
|xT3
| = 

0 = y
G() = G()
Dual feasible set |xTj
|   8j
Figure 5.13 The Lagrange dual of the lasso, with G() = 1
2 (kyk22
−ky−k22
). The
blue shaded region is the feasible set F. The unconstrained dual solution is 0 = y,
the null residual. The dual solution  = proxI(F)(y), the projection of y onto the
convex set F.
Theorem 5.1. Suppose we are given a solution ˆ(0) to the lasso dual (5.90)
for a specific max  0 > 0. Let  be a nonnegative value different from 0.
If the following holds:
|xT
j
ˆ
(0)| < 1 − kxjk2kyk2

1
0 −
1


, (5.91)
then ˆ j() = 0.
Since ˆ(0) = (y − Xˆ (0))/0, simple algebra leads to (5.77).
Proof: We know from the stationarity conditions for the lasso that
|xT
j
ˆ
(

)| <
1
=
)
bj
(

)
=
0. (
5.92)
From the dual (5.90), ˆ() is the projection of y/ into the feasible set F.
By the projection theorem (Bertsekas 2003) for closed convex sets, ˆ() is
continuous and nonexpansive, which implies
kˆ() −ˆ(0)k2 




y
 −
y
0




2
(5.93)
= kyk2

1
 −
1
0

.
134 OPTIMIZATION METHODS
Then
|xT
j
ˆ
(

)| 
|
xT
j
ˆ
(

)
−
xT
j
ˆ
(

0
)| +
|
xT
j
ˆ
(

0
)| (
5.94)
< kxjk2kˆ() −ˆ(0)k2 + 1 − kxjk2kyk2

1
0 −
1


 kxjk2kyk2

1
0 −
1


+ 1 − kxjk2kyk2

1
0 −
1


= 1.
Exercises
Ex. 5.1 Consider the unconstrained minimization of the quadratic function
f() = 12
TQ − h, bi, where Q  0 is a symmetric positive definite matrix,
and b 2 Rp.
(a) Show that the optimal solution  exists and is unique, and specify its
form in terms of (Q, b).
(b) Write out the gradient descent updates with constant stepsize s for this
problem.
(c) Show that there exists some constant c > 0, depending only on Q, such
that gradient descent converges for any fixed stepsize s 2 (0, c).
Ex. 5.2 Consider the constrained program minimize f() subject to gj()  0
for j = 1, . . . ,m, and let f be its optimal value.
Define the Lagrangian function
L(; ) = f() +
Xm
j=1
jgj(). (5.95)
(a) Show that
sup
0
L(; ) =
(
f() if gj()  0 for j = 1, . . . ,m
+1 otherwise.
(b) Use part (a) to show that f = inf sup0 L(; ).
(c) How is f related to the quantity sup0 inf L(, )?
Ex. 5.3 Let f : Rp ! R be a convex and differentiable function, and consider
a subspace constraint of the form C = { 2 Rp | M = c}, where M 2 Rm×p
is a fixed matrix, and c 2 Rm is a fixed vector.
(a) Suppose that  2 C satisfies the first-order optimality condition (5.4).
Show that there must exist a vector  2 Rm such that
rf() +MT  = 0 (5.96)
EXERCISES 135
(b) Conversely, suppose that condition (5.96) holds for some  2 Rm. Show
that the first-order optimality condition (5.4) must be satisfied.
Ex. 5.4 Consider the Lagrangian L(, ) = f() + Pm
j=1 jgj() associated
with the constrained problem (5.5), and assume that the optimal value f is
finite. Suppose that there exist vectors  2 Rp and  2 Rm+
such that
L(, )
(i)
 L(, )
(ii)
 L(, ) (5.97)
for all  2 Rp and  2 Rm+
. Show that  is optimal for the constrained
program.
Ex. 5.5 Subgradient of Euclidean norm. Consider the Euclidean or `2 norm
kk2 =
qPp
j=1 2
j , which is used in the group lasso. Show that:
(a) For any  6= 0, the norm g() := kk2 is differentiable with rg() =

kk2 .
(b) For  = 0, any vector bs 2 Rp with kbsk2  1 is an element of the subdifferential
of g at 0.
Ex. 5.6 Show that the function
h(1, . . . , p) = ||TP||
in Equation (5.40) satisfies the regularity conditions below Equation (5.39) on
page 111. (As a consequence, coordinate descent will still work even though
this function is not separable).
Ex. 5.7 Show that the proximal-gradient update step (5.21) is equal to the
step (5.19)
Ex. 5.8 Show that when h is given by the nuclear norm, the composite gradient
update (5.26) can be obtained by the following procedure:
(a) Compute the singular value decomposition of the input matrix Z, that
is Z = UDVT where D = diag{j(Z)} is a diagonal matrix of the singular
values.
(b) Apply the soft-thresholding operator (5.25) to compute the “shrunken”
singular values

j := Ss(j(Z)), for j = 1, . . . , p.
(c) Return the matrix bZ = Udiag{
1, . . . , 
p}VT .
136 OPTIMIZATION METHODS
Ex. 5.9 Consider a regression problem with all variables and response having
mean zero and standard deviation one in the dataset. Suppose also that each
variable has identical absolute correlation with the response—that is
1
N |hxj , yi| = , for all j = 1, . . . , p.
Let b be the least-squares coefficient vector of y on X, assumed to be unique
for this exercise. Let u() = Xˆ  for  2 [0, 1] be the vector that moves a
fraction  toward the least-squares fit u. Let RSS = ky −Xbk22
, the residual
sum-of-squares from the full least-squares fit.
(a) Show that
1
N |hxj , y − u()i| = (1 − ) for j = 1, . . . , p,
and hence the correlations of each xj with the residuals remain equal in
magnitude as we progress toward u.
(b) Show that these correlations are all equal to
() = (1 − ) q
(1 − )2 + (2−)
N · RSS · ,
and hence they decrease monotonically to zero.
(c) Use these results to show that the LAR algorithm in Section 5.6 keeps
the correlations tied and monotonically decreasing.
Ex. 5.10 Consider step 3c of the LAR Algorithm 5.1. Define c` = hx`, rk−1 and a i ` = hx`,XAi, ` /2 A. Define
` = min+

k−1 − c`
1 − a`
,
k−1 + c`
1 + a`

,
where min+ only considers positive entries. Show that the variable to enter at
step k has index j = arg min`/2A `, with value k = k−1 − j .
Ex. 5.11 Strong rules
(a) Show that if the slope condition (5.80) holds, then the global and sequential
strong rules (5.78) and (5.79) are guaranteed to work.
(b) In the case of orthogonal design XTX = I, show that the slope condition
(5.80) always holds.
(c) Design a simulation study to investigate the accuracy of the DPP and
strong rules for the lasso, in the cases (N, p) = (100, 20), (N, p) = (100, 100),
and (N, p) = (100, 1000).
EXERCISES 137
Ex. 5.12 ADMM for consensus optimization: Suppose that we have a dataset
{xi, yi}N
i=1, and that our goal is to minimize an objective function L(X − y)
that decomposes additively as a sum of N terms, one for each sample. A
natural approach is to divide the dataset into B blocks, and denote by
Lb(Xbb − yb) the objective function over the bth block of data, where Xb
and yb are the corresponding blocks of X and y. We thus arrive at the problem
minimize
2Rp
(
XB
b=1
Lb(Xbb − yb) + r()
)
such that b =  for all b = 1, . . .B.
(5.98)
(a) Show that the ADMM algorithm for this problem takes the form
t+1
b   arg min
b
􀀀
Lb(Xbb − yb) + (/2)kb − t + μt
bk22

(5.99a)
t+1   arg min

􀀀
r(z) + (N/2)k − ¯ t+1 − ¯μtk22

(5.99b)
μt+1
b   μt
b + (t+1
b − t+1) (5.99c)
where the ¯μk and ¯ k+1 denote averages over blocks. Interpret it as consensus
optimization.
(b) Now consider the lasso, which uses the regularizer r() = kk1. Show
that the algorithm has the form
t+1
b   (XTb
Xb + I)−1(Xbyb + (t − μt
b)) (5.100a)
t+1   S/(N)( ¯ t+1 + ¯μt) (5.100b)
μt+1
b   μt
b + (t+1
b − t+1) (5.100c)
(c) Implement the updates (5.100) in software and demonstrate it on a numerical
example.
Ex. 5.13
(a) Derive the alternating convex minimization (ACS) for problem (5.72), and
show that it has the form of a power iteration (Equations (5.73) and (5.74)).
(b) Show that it converges to the eigenvector corresponding to the largest
eigenvalue of XTX, provided that the starting vector v0 is not orthogonal
to this largest eigenvector.

Chapter 6
Statistical Inference
An attractive feature of `1-regularized procedures is their ability to combine
variable selection with parameter fitting. We often select a model based on
cross-validation—as an estimate for prediction or generalization error—and
then do further validation on a held-out test set.
It is sometimes of interest to determine the statistical strength of the included
variables, as in “p-values” in traditional models. The adaptive nature of
the estimation procedure makes this problem difficult—both conceptually and
analytically. We describe some useful approaches to the inference problem in
this chapter. We begin by discussing two “traditional” approaches—Bayesian
methods and the bootstrap, and then present some newer approaches to this
problem.
6.1 The Bayesian Lasso
The Bayesian paradigm treats the parameters as random quantities, along
with a prior distribution that characterizes our belief in what their values
might be. Here we adopt the approach of Park and Casella (2008), involving
a model of the form
y | , ,   N(X, 2IN×N) (6.1a)
 | ,  
Yp
j=1

2
e−
 |j |, (6.1b)
using the i.i.d. Laplacian prior (6.1b). Under this model, it is easy to show
that the negative log posterior density for  | y, ,  is given by
1
22 ky − Xk22
+ 
 kk1, (6.2)
where we have dropped an additive constant independent of . Consequently,
for any fixed values of  and , the posterior mode coincides with the lasso
estimate (with regularization parameter ). Park and Casella (2008) include
2 in the prior specification (6.1b) for technical reasons. Here we have assumed
there is no constant in the model, and that the columns of X are
139
140 STATISTICAL INFERENCE
Posterior Density
−1.0 −0.5 0.0 0.5 1.0
0.0 0.5 1.0 1.5 2.0 2.5 3.0 3.5
7
Figure 6.1 Prior and posterior distribution for the seventh variable in the diabetes
example, with  held fixed. The prior in the figure is a double exponential (Laplace)
distribution with density proportional to exp(−.0065|7|). The prior rate .0065 is a
representative value just for illustration.
mean-centered, as is y.1 The posterior distribution provides more than point
estimates: it provides an entire joint distribution.
The red curve in Figure 6.1 is the Laplace prior used in the Bayesian
lasso, applied to variable 7 in the “diabetes data.” These data consist of
observations on 442 patients, with the response of interest being a quantitative
measure of disease progression one year after baseline. There are ten baseline
variables—age, sex, body-mass index, average blood pressure, and six blood
serum measurements—plus quadratic terms, giving a total of 64 features. The
prior has a sharp peak at zero, which captures our belief that some parameters
are zero. Given a probability distribution (likelihood) for the observed data
given the parameters, we update our prior by conditioning on the observed
data, yielding the posterior distribution of the parameters. The histogram in
Figure 6.1 characterizes the posterior distribution for 7 for the diabetes data.
The prior distribution has a variance parameter that characterizes the strength
of our belief in zero as a special value. The posterior mode is slightly away
from zero, although a 95% posterior credible interval comfortably covers zero.
Exact Bayesian calculations are typically intractable, except for the simplest
of models. Fortunately, modern computation allows us to use Markov chain
Monte Carlo (MCMC) to efficiently sample realizations from the posterior
distributions of the parameters of interest. Figure 6.2 [left panel] shows a
summary of MCMC samples from the posterior distribution of  | ; the
median of 10, 000 posterior samples is shown at each of 100 values of . Here
1This is not a real restriction on the model, and is equivalent to assuming an improper
flat prior on 0, which is rarely of interest.
THE BAYESIAN LASSO 141
0.0 0.5 1.0 1.5 2.0
−0.4 −0.2 0.0 0.2 0.4
Posterior Medians
Coefficients
1
2
3
4
5
6
7
8
9
10
0.0 0.5 1.0 1.5 2.0
−0.4 −0.2 0.0 0.2 0.4
Lasso
Coefficients
1
2
3
4
5
6
7
8
9
10
kk1 kk1
Figure 6.2 Bayesian lasso on the diabetes data. The left plot shows the posterior
medians from MCMC runs (conditional on ). The right plot shows the lasso profile.
In the left plot, the vertical line is at the posterior median of kk1 (from an
unconditional model), while for the right plot the vertical line was found by N-fold
cross-validation.
2 is allowed to vary (with (2)  1
2 ). This, and the fact that we have
displayed medians, accounts for the slight discrepancies with the right plot
(the lasso), which shows the posterior mode for fixed values of . A complete
Bayesian model will also specify a prior distribution for ; in this case, a
diffuse Gamma distribution is conjugate and hence convenient for the MCMC
sampling. This is where the Bayesian approach can be worth the considerable
extra effort and leap of faith. The full posterior distribution includes  as well
as , so that model selection is performed automatically. Furthermore, the
posterior credible intervals for  take into account the posterior variability in
. Figure 6.3 shows a summary of 10, 000 MCMC samples from the posterior
distribution for the diabetes data. While the posterior mode has nine nonzero
coefficients, the posterior distributions suggest that only 5–8 of these are well
separated from zero.
Specifying the Bayesian model is technically challenging, and there are
several choices to be made along the way. These include priors for  and 2,
which themselves have hyperparameters that have to be set. Our examples
were fit in R using the function blasso in the package monomvn (Gramacy
2011), and for the most part we used the default parameter settings. For
142 STATISTICAL INFERENCE
||||||||||||| ||||||| ||
|||||||||| ||||||| |
|||||||||||| |||||||||
||||||||||| ||||||
| | | || || |||||| ||||||||||||||||||||||||||||||||||| ||||||| || |
| || ||||||||||||||||||||| |||||||||||||||||||||||||||||||| | |
||||||||||||||| |||||||||||||| || || |
|| ||| ||||||||| ||||||||||||||||||||| |
| ||||||||||||| |||||||||||||||| | |
|||||| ||||||||||||||| |
−0.6 −0.4 −0.2 0.0 0.2 0.4 0.6
Bayesian Posterior Samples
Coefficients
Density
0.0 0.5 1.0 1.5 2.0
0.0 0.5 1.0 1.5 2.0 2.5 3.0
1 2 3 4 5 6 7 8 9 10
kk1
Figure 6.3 Posterior distributions for the j and kk1 for the diabetes data. Summary
of 10, 000 MCMC samples, with the first 1000 “burn-in” samples discarded.
this 442×10 problem it took 5 seconds on a 2.3 GHz Macbook Pro. However,
Bayesian computations do not scale well; experiments in the next section show
that the computational cost scales roughly as O(p2).
6.2 The Bootstrap
The bootstrap is a popular nonparametric tool for assessing the statistical
properties of complex estimators (Efron 1979, Efron and Tibshirani 1993). To
motivate its use, suppose that we have obtained an estimate b(ˆCV ) for a
lasso problem according to the following procedure:
1. Fit a lasso path to (X, y) over a dense grid of values  = {`}L
`=1.
2. Divide the training samples into 10 groups at random.
3. With the kth group left out, fit a lasso path to the remaining 9/10ths, using
the same grid .
4. For each  2  compute the mean-squared prediction error for the left-out
group.
5. Average these errors to obtain a prediction error curve over the grid .
6. Find the value b
CV that minimizes this curve, and then return the coefficient
vector from our original fit in step (1) at that value of .
THE BOOTSTRAP 143
|| |||||||| |||||||||||| |||
| ||
||| | |
| | |
||||||||||||||||||||||||||||||||||||||||||||||| |||
||| |||||||||||||||||||||||||||||||||| | || |||| || |||||||||||||||||| |||||||||||||||||||| ||||||||||||||||||||||||||||||||||||||||||||||||||| |||||||||||||||| |||||
||||||||||||||||||| | ||||| | | | | |
|||| || | |
|| |||||||||||||||||||||||||||||||||
| || ||
−0.6 −0.4 −0.2 0.0 0.2 0.4 0.6
Bootstrap Samples
Coefficients
Bootstrap Probability of 0
0.0 0.2 0.4 0.6 0.8 1.0
1
1
2
2
3
3
4
4
5
5
6
6
7
7
8
8
9
9
10
10
Figure 6.4 [Left] Boxplots of 1000 bootstrap realizations of b(ˆCV ) obtained by the
nonparametric bootstrap, which corresponds to re-sampling from the empirical CDF
b FN. Comparing with the corresponding Bayesian posterior distribution in Figure 6.3,
we see a close correspondence in this case. [Right] Proportion of times each coefficient
is zero in the bootstrap distribution.
How do we assess the sampling distribution of b(b
CV )? That is, we are interested
in the distribution of the random estimate b(b
CV ) as a function of the
N i.i.d. samples {(xi, yi)}Ni
=1. The nonparametric bootstrap is one method
for approximating this sampling distribution: in order to do so, it approximates
the cumulative distribution function F of the random pair (X, Y ) by
the empirical CDF b FN defined by the N samples. We then draw N samples
from b FN, which amounts to drawing N samples with replacement from
the given dataset. Figure 6.4[left] shows boxplots of 1000 bootstrap realizations
b(ˆCV ) obtained in this way, by repeating steps 1–6 on each bootstrap
sample.2 There is a reasonable correspondence between this figure, and the
corresponding Bayesian results in Figure 6.3. The right plot shows the proportion
of times that each variable was exactly zero in the bootstrap distribution.
None of the Bayesian posterior realizations are exactly zero, although often
some are close to zero. (The blasso function has an argument that allows
for variable selection via “reversible jump” MCMC, but this was not used
here.) Similar to the right-hand plot, Meinshausen and B¨uhlmann (2010) pro-
2On a technical note, we implement the bootstrap with observation weights w
i = k/N,
with k = 0, 1, 2, . . .. In cross-validation, the units are again the original N observations,
which carry along with them their weights w
i .
144 STATISTICAL INFERENCE
−8 −6 −4 −2
0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1
Mean−Squared Error
10 10 9 10 8 8 7 7 6 4 4 2
−8 −6 −4 −2
0.4 0.5 0.6 0.7 0.8 0.9 1.0 1.1
Bootstrapped CV Curves
Mean−Squared Error
log() log()
Figure 6.5 [Left] Cross-validation curve for lasso on the diabetes data, with onestandard-
error bands computed from the 10 realizations. The vertical line on the left
corresponds to the minimizing value for . The line on the right corresponds to the
one-standard-error rule; the biggest value of  for which the CV error is within one
standard error of the minimizing value. [Right] 1000 bootstrap CV curves, with the
average in red, and one-standard-error bands in blue. The rug-plot at the base shows
the locations of the minima.
duce a stability plot for lasso under bootstrap resampling; as a function of 
they display what fraction of times a variable is nonzero in the bootstrapped
coefficient paths.
Figure 6.5 shows the bootstrapped cross-validation curves, and their minima.
Not surprisingly, the bootstrapped minima have a wide spread, since
the original CV curve is flat over a broad region. Interestingly, the bootstrap
standard-error bands bear a close correspondence to those computed from the
original CV fit in the left plot. Figure 6.6 shows pairwise plots of the bootstrapped
coefficients. From such plots we can see, for example, how correlated
variables can trade off with each other, both in value and their propensity for
being zero.
In Table 6.1, we show comparative timings in seconds for problems with
N = 400 and different numbers of predictors. We generated 1000 bootstrap
samples; for the Bayesian lasso we generated 2000 posterior samples, with the
idea of discarding the first 1000 samples as a burn-in. While such comparisons
depend on implementation details, the relative growth with p is informative.
The Bayesian lasso is perhaps faster for small problems, but its complexity
THE BOOTSTRAP 145
−0.25 −0.10 0.10 0.25 −0.4 0.2 0.8 −0.1 0.2 −0.05 0.10
−0.10 0.05
−0.25 −0.10
0.20 0.35
0.10 0.25
−1.0 0.0
−0.4 0.2 0.8
−0.2 0.2
−0.1 0.2
0.2 0.4 0.6
−0.10 0.05
−0.05 0.10
0.20 0.35 −1.0 0.0 −0.2 0.2 0.2 0.4 0.6
1
2
3
4
5
6
7
8
9
10
Figure 6.6 Pairwise plots of the bootstrapped coefficients b(ˆCV ). The red points
correspond to values that are zero on at least one coordinate for that plot. The samples
x5 and x6 have high correlation (0.9); we see the corresponding negative correlation
in their coefficients, with zero playing a prominent role.
Table 6.1 Timings for Bayesian lasso and bootstrapped
lasso, for four different problem sizes. The
sample size is N = 400.
p Bayesian Lasso Lasso/Bootstrap
10 3.3 secs 163.8 secs
50 184.8 secs 374.6 secs
100 28.6 mins 14.7 mins
200 4.5 hours 18.1 mins
146 STATISTICAL INFERENCE
seems to scale as O(p2). In contrast, the scaling of the bootstrap seems to be
closer to O(p), because it exploits the sparseness and convexity of the lasso.
The above procedure used the nonparametric bootstrap, in which we estimate
the unknown population F by the empirical distribution function b FN,
the nonparametric maximum likelihood estimate of F. Sampling from b FN
corresponds to sampling with replacement from the data. In contrast, the
parametric bootstrap samples from a parametric estimate of F, or its corresponding
density function f. In this example, we would fix X and obtain
estimates b and b2 either from the full least-squares fit, or from the fitted
lasso with parameter . We would then sample y values from the Gaussian
model (6.1a), with  and 2 replaced by b and b2.
Using the full least-squares estimates for b and b2, the parametric bootstrap
results for our example are shown in Figure 6.7. They are similar to both
the nonparametric bootstrap results and those from the Bayesian lasso. In
general, we might expect that the parametric bootstrap would likely produce
results even closer to the Bayesian lasso as compared to the nonparametric
bootstrap, since the parametric bootstrap and Bayesian lasso both use the
assumed parametric form for data distribution (6.1a). Note also that the use
of the full least squares estimates for b and b2 would not work when p  N,
and we would need to generate a different dataset for each value of . This
would slow down the computations considerably.
| ||||||||| |||||||| ||
| | ||| |
|||| ||
|| |
|||||||||||||||||| | |
|| |
| |
−0.6 −0.4 −0.2 0.0 0.2 0.4 0.6
Bootstrap Samples
Coefficients
Bootstrap Probability of 0
0.0 0.2 0.4 0.6 0.8 1.0
1
1
2
2
3
3
4
4
5
5
6
6
7
7
8
8
9
9
10
10 Figure 6.7 [
Left] Boxplots of 1000 parametric bootstrap realizations of b
(
ˆ
CV ).
Comparing with the corresponding Bayesian posterior distribution in Figure 6.3, we
again see a close correspondence. [Right] Proportion of times each coefficient is zero
in the bootstrap distribution.
POST-SELECTION INFERENCE FOR THE LASSO 147
In summary, in this section we have compared the Bayesian and bootstrap
approach on a Gaussian linear-regression problem, for which Bayesian software
was available at the time of writing. As we move to GLMs and other models,
the Bayesian technical complexities grow. The bootstrap, on the other hand,
can be applied seamlessly in many situations. In a general sense, the similar
results for the Bayesian lasso and lasso/bootstrap are not surprising. The
histogram of values from the nonparametric bootstrap can be viewed as a kind
of posterior-Bayes estimate under a noninformative prior in the multinomial
model (Rubin 1981, Efron 1982).
Which approach is better? Both the Bayesian and bootstrap approaches
provide a way to assess variability of lasso estimates. The Bayesian approach
is more principled but leans more heavily on parametric assumptions, as compared
to the nonparametric bootstrap. The bootstrap procedure scales better
computationally for large problems. Some further discussion of the relationship
between Bayesian and bootstrap approaches is given in Efron (2011).
6.3 Post-Selection Inference for the Lasso
In this section we present some relatively recent ideas on making inference
after selection by adaptive methods such as the lasso and forward-stepwise
regression. The first method we discuss in Section 6.3.1 pioneered a particular
line of research, and has been followed in rapid succession by a series of
generalizations and improvements discussed in Section 6.3.2.
6.3.1 The Covariance Test
In this section we describe a method proposed for assigning p-values to predictors
as they are successively entered by the lasso. This method is based on the
LAR algorithm and its piecewise construction of the path of lasso solutions
(Section 5.6).
Suppose that we are in the usual linear regression setup, with an outcome
vector y 2 RN and matrix of predictor variables X 2 RN×p related by
y = X + ,   N(0, 2IN×N), (6.3)
where  2 Rp are unknown coefficients to be estimated.
To understand the motivation for the covariance test, let’s first consider
forward-stepwise regression. This procedure enters predictors one at a time,
choosing the predictor that most decreases the residual sum of squares at
each stage. Defining RSSk to be the residual sum of squares for the model
containing k predictors, we can use this change in residual sum-of-squares to
form a test statistic
Rk = 1
2 (RSSk−1 − RSSk) (6.4)
148 STATISTICAL INFERENCE
(with  assumed known for now), and compare it to a 21
distribution.
Figure 6.8(a) shows the quantiles of R1 from forward stepwise regression
(the chi-squared statistic for the first predictor to enter) versus those of a 21
variate, in the fully null case ( = 0). The observed quantiles are much larger
than those of the 21
distribution. A test at the 5% level, for example, using
the 21
cutoff of 3.84, would have an actual type I error of about 39%.
ooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo
oooo
o
o
o
o
o
o
0 2 4 6 8 10
0 2 4 6 8 10
21
R1
(a) Forward stepwise
oooooooooooooooooooooooooooooooooooooooooooooooo
o
o
o
o
o
o
0 1 2 3 4 5
0 1 2 3 4 5
Exp(1)
T1
(b) Lasso
Figure 6.8 A simulation example with N = 100 observations and p = 10 orthogonal
predictors and  = 0. (a) a quantile-quantile plot, constructed over 1000 simulations,
of the standard chi-squared statistic R1 in (6.4), measuring the drop in residual sumof-
squares for the first predictor to enter in forward stepwise regression, versus the 21
distribution. The dashed vertical line marks the 95% quantile of the 21
distribution.
(b) a quantile-quantile plot of the covariance test statistic T1 in (6.5) for the first
predictor to enter in the lasso path, versus its asymptotic null distribution Exp(1).
The covariance test explicitly accounts for the adaptive nature of lasso modeling,
whereas the chi-squared test is not appropriate for adaptively selected models as in
forward-stepwise regression.
The reason for this is clear: the chi-squared test assumes that the models
being compared are pre-specified, not chosen on the basis of the data. But the
forward stepwise procedure has deliberately chosen the strongest predictor
among all of the available choices, so it is not surprising that it yields a larger
drop in training error than expected.
It seems difficult to derive an appropriate p-value for forward stepwise
regression, one that properly accounts for the adaptive nature of the fitting.
For the first step and the test of the global null hypothesis, one can use a
permutation distribution. For subsequent steps, it is not clear how to correctly
carry out permutations. One can resort to sample splitting: we divide the data
in half, compute the sequence of models on one half and then evaluate their
significance on the other half. But this can lead to a significant loss of power,
unless the sample size is large.
POST-SELECTION INFERENCE FOR THE LASSO 149
Surprisingly, it turns out that for the lasso, a simple test can be derived
that properly accounts for the adaptivity. Denote the knots returned by the
LAR algorithm (Algorithm 5.1 on page 119) by 1 > 2 . . . > K. These are
the values of the regularization parameter  where there is a change in the set
of active predictors. Suppose that we wish to test significance of the predictor
entered by LAR at k. Let Ak−1 be the active set (the predictors with nonzero
coefficients) before this predictor was added and let the estimate at the end
of this step be ˆ (k+1). We refit the lasso, keeping  = k+1 but using just
the variables in Ak−1. This yields the estimate ˆ Ak−1 (k+1). The covariance
test statistic is defined by
Tk = 1
2 ·

hy,Xˆ (k+1)i − hy,Xˆ Ak−1 (k+1)i

. (6.5)
This statistic measures how much of the covariance between the outcome and
the fitted model can be attributed to the predictor that has just entered the
model; i.e., how much improvement there was over the interval (k, k+1) in
this measure. Interestingly, for forward-stepwise regression, the corresponding
covariance statistic is equal to Rk (6.4); however, for the lasso this is not the
case (Exercise 6.2).
Remarkably, under the null hypothesis that all k − 1 signal variables are
in the model, and under general conditions on the model matrix X, for the
predictor entered at the next step we have
Tk
d!
Exp(1) (6.6)
as N, p ! 1. Figure 6.8(b) shows the quantile-quantile plot for T1 versus
Exp(1). When 2 is unknown, we estimate it using the full model:
ˆ2 = 1
N−pRSSp. We then plug this into (6.5), and the exponential test becomes
an F2,N−p test.
Table 6.2 shows the results of forward stepwise regression and LAR/lasso
applied to the diabetes data. Only the first ten steps are shown in each case.
We see that forward stepwise regression enters eight terms at level 0.05, while
the covariance test enters only four. However as we argued above, the forward
stepwise p-values are biased downward, and hence they are not trustworthy. In
Exercise 6.3 we discuss a method for combining a set of sequential p-values to
control the false discovery rate of the list of selected predictors. When applied
to the covariance test at an FDR of 5%, it yields a model containing the first
four predictors. For comparison, cross-validation estimated the optimal model
size for prediction to be in the range of 7 to 14 predictors.
Why is the mean of the forward-stepwise statistic R1 much larger than one,
while the mean of T1 is approximately equal to one? The reason is shrinkage:
the lasso picks the best predictor available at each stage, but does not fit it
fully by least squares. It uses shrunken estimates of the coefficients, and this
shrinkage compensates exactly for the inflation due to the selection. This test
is also the natural analogue of the degrees of freedom result for the lasso and
150 STATISTICAL INFERENCE
Table 6.2 Results of forward stepwise regression and LAR/lasso applied to the diabetes
data introduced in Chapter 2. Only the first ten steps are shown in each case.
The p-values are based on (6.4), (6.5), and (6.11), respectively. Values marked as 0
are < 0.01.
Forward Stepwise LAR/lasso
Step Term p-value Term p-value
Covariance Spacing
1 bmi 0 bmi 0 0
2 ltg 0 ltg 0 0
3 map 0 map 0 0.01
4 age:sex 0 hdl 0.02 0.02
5 bmi:map 0 bmi:map 0.27 0.26
6 hdl 0 age:sex 0.72 0.67
7 sex 0 glu2 0.48 0.13
8 glu2 0.02 bmi2 0.97 0.86
9 age2 0.11 age:map 0.88 0.27
10 tc:tch 0.21 age:glu 0.95 0.44
LAR, discussed in Section 2.5. The lasso with k nonzero coefficients has k
degrees of freedom in expectation, and LAR spends one degree of freedom in
each segment (k+1, k) along the path. The covariance test has mean equal
to one, the degrees of freedom per step. In a sense, the Exp(1) distribution is
the analogue of the 21
distribution, for adaptive fitting.
The exponential limiting distribution for the covariance test (6.5) requires
certain conditions on the data matrix X, namely that the signal variables
(having nonzero true coefficients) are not too correlated with the noise variables.
These conditions are similar to those needed for support recovery for
the lasso (Chapter 11). In the next section we discuss a more general scheme
that gives the spacing test, whose null distribution holds exactly for finite N
and p, and works for any X.
6.3.2 A General Scheme for Post-Selection Inference
Here we discuss a general scheme for inference after selection—one that yields
exact p-values and confidence intervals in the Gaussian case. It can deal with
any procedure for which the selection events can be characterized by a set of
linear inequalities in y. In other words, the selection event can be written as
{Ay  b} for some matrix A and vector b. In particular, it can be applied to
successive steps of the LAR algorithm, where it gives an exact (finite sample)
form of the covariance test. Similarly, it can be applied to forward stepwise
regression, and to the lasso at a fixed choice of the regularization parameter .
Why can the selection events for these procedures be written in the form
{Ay  b}? This is easiest to see for forward-stepwise regression. In this case we
POST-SELECTION INFERENCE FOR THE LASSO 151
take b = 0. At the first step, forward-stepwise regression chooses the predictor
whose absolute inner product with y is the largest (see Figure 6.10 for an
illustration). This can be expressed by forming 2(p − 1) rows in the matrix
A, each computing a difference of inner products, once each for the positive
and negative directions. Similarly, at the next step we add 2(p − 2) rows
contrasting the inner product between the selected predictor and the other
p − 2 predictors, and so on.
The lasso solution at a fixed value of  is characterized by an active set of
variables A, along with the signs of their coefficients. Again, it turns out that
the selection event that led to this particular combination can be written in
the form {Ay  b} for some A and b. That is, the set {y|Ay  b} corresponds
to the values of the outcome vector y that would yield this same collection
of active variables and signs (with X fixed) (see Lee, Sun, Sun and Taylor
(2016), and Exercise 6.10). The same is true for the LAR algorithm after its
kth step.
Now suppose that y  N(μ, 2IN×N), and that we want to make inferences
conditional on the event {Ay  b}. In particular, we wish to make
inferences about Tμ, where  might depend on the selection event. With
lasso, LAR, or forward-stepwise regression having selected this set, we can
now make inference statements about the selected variables. For example,
we could be interested in the (ordinary) regression coefficients of y on XA,
namely ˆ = (XT
AXA)−1XT
Ay. These correspond to the population parameters
 = (XT
AXA)−1XT
Aμ, the coefficients in the projection of μ on XA. So here
Tμ could correspond to one of these coefficients, and hence  is one of the
columns of XA(XT
AXA)−1. We pursue this example in Section 6.3.2.1.
Lee et al. (2016) and Taylor, Lockhart, Tibshirani2 and Tibshirani (2014)
show that
{Ay  b} = {V−(y)  T y  V+(y), V0(y)  0}, (6.7)
and furthermore, T y and (V−(y), V+(y), V0(y)) are statistically independent.
See Figure 6.9 for a geometric view of this surprising result, known as
the polyhedral lemma. The three values on the right in (6.7) are computed via
 = A
kk22
V−(y) = max
j:j<0
bj − (Ay)j + jT y
j
V+(y) = min
j:j>0
bj − (Ay)j + jT y
j
V0(y) = min
j:j=0
(bj − (Ay)j)
(6.8)
(Exercise 6.7). Hence the selection event {Ay  b} is equivalent to the event
that T y falls into a certain range, a range depending on A and b. This
equivalence and the independence means that the conditional inference on
152 STATISTICAL INFERENCE
V−(y) V+(y)
P?y
Py
Ty
y

{Ay  b}
Figure 6.9 Schematic illustrating the polyhedral lemma (6.7), for the case N = 2
and kk2 = 1. The yellow region is the selection event {Ay  b}. We decompose y
as the sum of two terms: its projection Py onto  (with coordinate T y) and its
projection onto the (N −1)-dimensional subspace orthogonal to : y = Py+P?y.
Conditioning on P?y, we see that the event {Ay  b} is equivalent to the event
{V−(y)  T y  V+(y)}. Furthermore V+(y) and V−(y) are independent of T y
since they are functions of P?y only, which is independent of y.
Tμ can be made using the truncated distribution of T y, a truncated normal
distribution.
To use this fact, we define the cumulative distribution function (CDF) of
a truncated normal distribution with support confined to [c, d]:
Fc,d
μ,2 (x) = ((x − μ)/) − ((c − μ)/)
((d − μ)/) − ((c − μ)/) , (6.9)
with  the CDF of the standard Gaussian. Now the CDF of a random variable,
evaluated at the value of that random variable, has a uniform distribution.
Hence we can write
FV−,V+
Tμ, 2kk22 􀀀
T y

| {Ay  b}  U(0, 1). (6.10)
This result is used to make conditional inferences about any linear functional
Tμ. For example, we can compute a p-value for testing Tμ = 0. We can
also construct a 1 −  level selection interval for  = Tμ by inverting this
test, as follows. Let P() = FV−,V+
, 2kk22
􀀀
T y

| {Ay  b}. The lower boundary
of the interval is the largest value of  such that 1 − P()  /2, and the
upper boundary is the smallest value of  such that P()  /2.
Example 6.1. To help understand these results, we present an example. We
simulated N = 60 observations from the model Y = Pp
j=1 Xjj + Z, with
X1,X2, . . . ,Xp, Z  N(0, 1), and each standardized to have sample mean
zero and unit `2 norm. We considered the global null case with all j = 0, and
POST-SELECTION INFERENCE FOR THE LASSO 153
x1
x2 ∞
hx1, yi
V−(y)
y
V−(y)
x1
x2
x3
∞
hx1, yi
y
Figure 6.10 Selection regions in Example 6.1 for which 1 = hx1, yi. Left panel: two
orthogonal predictors; right panel: three correlated predictors. The red line indicates
the part of the set P?y + t inside the selection region. In the left panel, V−(y) =
hx2, yi, while in the right it is 2.
found the predictor j1 having largest absolute inner product with y. This is the
first variable to enter the LAR or lasso path. We wish to make inference on 1,
the value of the largest knot in LAR, under the global null hypothesis. Thus
 = xj1 and T y is the attained inner product (for simplicity we condition
on a positive sign for the inner-product). Note that with our standardization,
T y = xT
j1y is also the simple least-squares coefficient of y on the chosen xj1 ,
and so we are also making (conditional) inference on the population coefficient
in the simple regression of y on xj1. We chose five scenarios with number of
predictors p 2 {2, 5, 10, 20, 50}. We also considered two correlation patterns
for the predictors: uncorrelated and pairwise correlation 0.5. Figure 6.10 illustrates
the corresponding version of Figure 6.9 for the two situations. The
upper bound in all cases is V+ = 1, and the lower bound V− depends on y in
each simulation. In the orthogonal case (left panel), conditioning on P?y reduces
to conditioning on the values of |xT
k y|, for all predictors k not achieving
the maximum absolute inner product. Hence the lower bound on T y is the
second-largest among these. The right panel shows the nonorthogonal case,
with correlations between the Xj . Here the situation is slightly more complex,
but nevertheless a simple formula can be used to derive V−(y): it turns out
to be 2, the second knot in the LAR sequence (Exercise 6.11). Figure 6.11
shows the resulting truncated normal densities from (6.10), averaged over 100
simulations. We plotted the density for the average value of V− over the simulations.
The colored squares along the bottom show the average largest inner
product 1 = T y in each setting. In the lower panel, with larger p, the effective
number of variables is smaller due to the correlation, so the maximum is
smaller as well. We pursue this example further in Section 6.3.2.2. }
This general mechanism (6.10) allows one to make inferences about any
154 STATISTICAL INFERENCE
0 1 2 3 4
0.0 0.5 1.0 1.5 2.0
Density
p=2
p=5
p=10
p=20
p=50
Uncorrelated Predictors
0 1 2 3 4
0.0 0.5 1.0 1.5 2.0
Density
Pairwise Correlation 0.5
Figure 6.11 Simulation: N = 60 observations from the model with X1,X2, . . .Xp 
N(0, 1), Y =
P
j Xijj+Z with Z  N(0, 1), with all j = 0; two different predictorcorrelation
settings. The selection chooses the predictor j1 having largest absolute
inner product with y. Shown is the truncated density on the left-hand side of (6.10)
for p = 2, 5, 10, 20, 50. The colored squares along the bottom show the average largest
inner product in each setting.
linear functional Tμ; for example, inferences about any parameter Tμ at
a given step of the LAR algorithm, or at a lasso solution computed at .
The form of A and b is different depending on the setting, but otherwise
the construction is the same. We illustrate two applications in the next two
sections.
6.3.2.1 Fixed- Inference for the Lasso
Consider the solution to the lasso, at some fixed value of . We can apply
result (6.10) by constructing A and b so that the event {Ay  b} represents
the set of outcome vectors y that yield the observed active set and signs of the
predictors selected by the lasso at . These inequalities derive from the subgradient
conditions that characterize the solution (Exercise 6.10). This yields
an active set A of variables, and we can now make conditional inference on the
population regression coefficients of y on XA, for example. This means we will
perform a separate conditional analysis for  equal to each of the columns of
XA(XT
AXA)−1. Hence we can obtain exact p-values and confidence intervals
for the parameters of the active set in the lasso solution at . These quantities
POST-SELECTION INFERENCE FOR THE LASSO 155
have the correct type-I error and coverage conditional on the membership and
signs of the active set.3
−30 −10 0 10 20 30
Predictor
Coefficient
bmi map hdl ltg glu^2 age:sex bmi:map
OLS interval
Lasso interval
Figure 6.12 Lasso model fit to the diabetes data. The solution at  = 7 yields a
model with seven nonzero coefficients. Shown are the 95% confidence intervals for the
least-squares fit using the chosen variables. The OLS intervals ignore the selection,
while the lasso intervals are exact under a Gaussian assumption, and condition on
the selection event. Disclosure:  was selected by cross-validation (1 SE rule), and
2 in (6.10) was estimated using the residuals from the full regression on all 64
variables.
Figure 6.12 shows the result of fixed- lasso inference for the diabetes data
with  = 7; seven variables were selected. Notice that we now focus attention
on the OLS regression coefficients using the reduced model containing only
those seven predictors. The blue intervals are based on the usual multiple
regression normal theory, ignoring the fact that we used the data to select
the seven variables from the full set of 64. The red post-selection intervals
were constructed by inverting relationship (6.10), and take the selection into
account. We see that these two sets of intervals are similar for the larger
coefficients, but the selection-adjusted ones are (appropriately) longer for the
smaller coefficients.
How did we choose  = 7? Here we cheated a bit, and used ten-fold crossvalidation
(using the one-standard-error rule). In practice one would need to
condition on this selection event as well, which would add considerably more
complexity to the selection set. Simulations suggest this does not widen the
confidence intervals substantially. In the next section, we discuss conditional
inference at the LAR sequence {k}, which limits the set of s to the knots in
3Lee et al. (2016) also discuss inference without conditioning on the signs, by considering
the union of all regions with the same active set.
156 STATISTICAL INFERENCE
the lasso path. We also needed to estimate  in (6.10); since N > p, we used
the root mean-squared error from the full regression on all 64 predictors for
this purpose.
6.3.2.2 The Spacing Test for LAR
Here we apply the inference procedure (6.10) to successive steps of the LAR
algorithm. We already visited the first step in Example 6.1 on page 152, for
testing the global null hypothesis. There we set T1
y = 1 = maxj |hxj , yi|,
and the test amounts to testing if this maximum covariance exceeds what we
expect by chance. We saw that V− = 2, V+ = +1, and hence the resulting
test can be written in a very simple form:
R1 = 1 − FV−,V+
0,2 (1|{Ay  b}) = 1 − (1/)
1 − (2/)  U(0, 1). (6.11)
Remarkably, the uniform distribution above holds exactly for finite N and p,
and for any X. This is known as the spacing test (Taylor et al. 2014) for the
global null hypothesis: it is a nonasymptotic version of the covariance test,
and is asymptotically equivalent to it (Exercise 6.5). The spacing test is a
monotone function of 1 −2: the larger this spacing, the smaller the p-value.
Similarly, there is a more general form of the spacing test for testing that
the partial regression coefficient of the variable added at any given LAR step
is zero. These tests are based on the successive values for k, and result in
expressions more complex than Equation (6.11).
In detail, if variable xjk is chosen at the kth step in the LAR algorithm,
one can show that the corresponding knot k is given by k = Tk
y, with
k =
P?
Ak−1xjk
sk − xT
jkXAk−1 (XT
Ak−1XAk−1 )−1sAk−1
(6.12)
(Exercise 6.8). Here Ak−1 indexes the active set after k − 1 steps, and
P?
Ak−1 = IN − XAk−1 (XT
Ak−1XAk−1 )−1XAk−1
is the residual projection operator that “adjusts” xjk for XAk−1 . Finally, sk
and sAk−1 are the signs for the coefficients for variables k and those indexed by
Ak−1 (the latter being a (k−1)-vector). Using this value of , the spacing test
follows from the general inference procedure outlined above, culminating in
(6.10) on page 152. The matrix A at knot k has considerably more rows than
in the fixed- case, since we are conditioning on the entire sequence {`}k1
.
Nevertheless the computations are quite manageable, and one can compute
exact p-values as well as confidence intervals for the chosen variables, as in
the fixed- case.
Taylor et al. (2014) give some simplified versions of the general spacing
test—approximations to the exact case, that empirically are very close, and
POST-SELECTION INFERENCE FOR THE LASSO 157
asymptotically are equivalent (also with the covariance test). The most appealing
of these has the form
Rk =


k−1
kkk2

− 

k
kkk2



k−1
kkk2

− 

k+1
kkk2
, (6.13)
which is an exact generalization of (6.11), using V− = k−1 and V+ = k+1.
It is easy to see that the term of interest (top-right in (6.13)) is
˜k = k
kk2
= Tk
y
kk2
(6.14)
is the (absolute) standardized partial regression coefficient for xjk in the presence
of XAk−1 (Exercise 6.9); this view shows that testing for k amounts to
testing for this partial regression coefficient.
The rightmost column of Table 6.2 shows the result of this more general
spacing test applied to the diabetes data. Qualitatively the results look similar
to those from the covariance test.
Although the spacing test and fixed- approaches are similar in their construction,
and are both exact, they are different in an important way. In particular,
the spacing test applies to each step of the sequential LAR procedure,
and uses specific  values (the knots). In contrast, the fixed- inference can be
applied at any value of , but then treats this value as fixed. Hence it ignores
any additional variability caused by choosing  from the data.
6.3.3 What Hypothesis Is Being Tested?
In adaptive testing, this question is tricky. The covariance test uses a set of
conditional hypotheses: at each stage of LAR, we are testing whether the coefficients
of all other predictors not yet in the model are zero. This is sometimes
called the complete null hypothesis
It turns out that the spacing test has a different focus. At the first step, it
tests the global null hypothesis, as does the covariance test. But at subsequent
steps, it tests whether the partial correlation of the given predictor entered
at that step is zero, adjusting for other variables that are currently in the
model. This is sometimes called the incremental null hypothesis. Unlike the
covariance test, it does not try to assess the overall correctness of the current
model. The fixed- test is similar; it conditions on the current active set of
predictors and tests whether the coefficient of any given predictor is zero in the
projected model. In contrast, Section 6.4 below discusses a procedure which
forms confidence intervals for the population regression parameters in the full
model.
158 STATISTICAL INFERENCE
6.3.4 Back to Forward Stepwise Regression
At the beginning of this section, we complained that na¨ıve inference for
forward-stepwise regression ignores the effects of selection, as in Figure 6.8(a)
and the left side of Table 6.2. Coming full circle, we note that the general
inference procedure outlined in Section 6.3.2 can in fact be applied to forward
stepwise regression, providing proper selective inference for that procedure as
well. In that case, the constraint matrix A is somewhat complicated, containing
approximately 2pk rows at step k. However the resulting procedure is
computationally tractable: details are in Taylor et al. (2014) and Loftus and
Taylor (2014).
6.4 Inference via a Debiased Lasso
The aim of the method that we describe here is quite different from those
discussed in Section 6.3. It does not attempt to make inferences about the
partial regression coefficients in models derived by LAR or the lasso. Instead
it directly estimates confidence intervals for the full set of population regression
parameters, under an assumed linear model. To do so, it uses the lasso
estimate4 as a starting point and applies a debiasing operation to yield an
estimate that can be used for constructing confidence intervals.
Suppose we assume that the linear model y = X +  is correct, and we
want confidence intervals for the components {j}p1
. Then if N > p, we can
simply fit the full model by least squares and use standard intervals from
least-squares theory
bj ± z()vj ˆ, (6.15)
where b is the OLS estimate, v2
j =
􀀀
XTX
−1
jj , ˆ2 = P
i(yi − ˆyi)2/(N − p),
and z is the -percentile of the standard normal distribution. However this
approach does not work when N < p.
One proposal that has been suggested (Zhang and Zhang 2014, B¨uhlmann
2013, van de Geer, B¨uhlmann, Ritov and Dezeure 2013, Javanmard and
Montanari 2014), is to use a debiased version of the lasso estimator, namely
bd = b + 1
NXT (y − Xb), (6.16)
where b is the lasso estimate at , and  is an approximate inverse of
b = 1
NXTX.5 From this, we can write
bd =  + 1
NXT  + (Ip − 1
NXTX)(b − )
| {z }
ˆ
(6.17)
4Fit using a value of  based on consistency considerations.
5If N  p, then −1 = 1
N XTX and (6.16) would be exactly unbiased for . However
when N < p, XTX/N is not invertible and we try to find an approximate inverse.
INFERENCE VIA A DEBIASED LASSO 159
with   N(0, 2Ip). These authors provide (different) estimates of  so
that kˆ k1 ! 0. From Equation (6.17), one can use the approximation
bd  N(, 2
N bT ) to form confidence intervals for the components j .
The debiasing operation (6.16) can be viewed as an approximate Newton step
for optimizing the residual sum of squares, starting at the lasso estimate 
(Exercise 6.6). There have been different proposals for estimating :
• van de Geer et al. (2013) estimate  using neighborhood-based methods
to impose sparsity on the components (see Chapter 9 for details on sparse
graph estimation).
• Javanmard and Montanari (2014) use a different approach: for each j they
define mj to be the solution to the convex program
minimize
m2Rp
mT bm (6.18)
subject to kbm − ejk1  
, (6.19)
with ej being the jth unit vector. Then they set
b := (m1,m2, . . . ,mp). (6.20)
This tries to make both bb  I and the variances of bd
j small.
−20 −10 0 10 20 30
Predictors
Coefficients
ltg
bmi
map
sex
age:sex
hdl
Lasso estimate
Debiased estimate
95% CI
Figure 6.13 Diabetes data: Lasso estimates, debiased lasso estimates, and confidence
intervals from the debiasing approach. These intervals have not been adjusted
for multiple comparisons. The first 6 predictors have intervals not containing zero:
when Bonferroni-adjusted, this number drops to three.
Figure 6.13 shows the result of applying the debiasing procedure of Javanmard
and Montanari (2014) to the diabetes data. For six of the predictors, the
160 STATISTICAL INFERENCE
95% confidence intervals do not contain zero. However these intervals are not
corrected for multiple comparisons; if we instead use a Bonferroni-adjusted
level of 0.05/64, then the number of significant predictors drops to three. The
top three predictors agree with those from the covariance and spacing tests
of Table 6.2; the fourth predictor (sex) is not entered until step seven by the
forward stepwise algorithm of Table 6.2, and not in the first ten steps by the
other two procedures.
6.5 Other Proposals for Post-Selection Inference
The PoSI method (Berk, Brown, Buja, Zhang and Zhao 2013, “Post-Selection
Inference”) fits the selected submodel, and then adjusts the standard (nonadaptive)
confidence intervals by accounting for all possible models that might
have been delivered by the selection procedure. The adjustment is not a function
of the particular search method used to find the given model. This can
be both an advantage and a disadvantage. On the positive side, one can apply
the method to published results for which the search procedure is not specified
by the authors, or there is doubt as to whether the reported procedure is
an accurate account of what was actually done. On the negative side, it can
produce very wide (conservative) confidence intervals in order to achieve its
robustness property.
In detail, consider again the linear model y = X + , and suppose that
a model-selection procedure M chooses a submodel M, with estimate bM.
The authors of PoSI argue that inferences should most naturally be made not
about the true underlying parameter vector , but rather the parameters in
the projection of X onto XM:
M = (XT
MXM)−1XT
MX. (6.21)
This approach was also adopted with the conditional inference discussed in
Section 6.3.2. Consider a confidence interval for the jth component of M of
the form
CIj·M = bj·M ± Kˆvj·M, (6.22)
with v2
j·M = (XT
MXM)−1
jj . Then the PoSI procedure delivers a constant K so
that
Pr(j·M 2 CIj·M)  1 − 2 (6.23)
over all possible model selection proceduresM. The value of K is a function of
the data matrix X and the maximum number of nonzero components allowed
in p M, but not the outcome vector y. The authors show that K grows like
2 log(p) for orthogonal designs but can grow as quickly as pp for nonorthogonal
designs.
Note that any individual parameter in any projected submodel of the form
(6.21) can be written as aT , with least-squares estimate aT b, where b is the
BIBLIOGRAPHIC NOTES 161
least-squares estimate for the full model. Scheff´e (1953) provides a way to
obtain simultaneous inference for all such linear combinations:
Pr
"
sup
a
[aT (b − )]2
aT (XTX)−1a · ˆ2  K2S
ch
#
= 1 − 2. (6.24)
Assuming that the full model is correct, with Gaussian errors, it can be shown
that KSch =
p
pFp,N−p,1−2, which provides the pp upper bound referred to
above. The PoSI authors show that using numerical methods and direct search,
smaller values of K can be found for actual model matrices X, in particular
when the user limits the search to all models within a certain maximum size.
For the diabetes data, Andreas Buja computed for us the value of K for
submodels of size 5 (this took a little less than 2 hours of computing time).
The resulting values of K were 4.21 (90%), 4.42 (95%), and 4.85 (99%). At the
95% level, this yielded four significant predictors bmi, map, hdl, and ltg. This
is one more predictor than we obtain from the lasso method of Figure 6.12, if
the latter intervals were adjusted for multiplicity.
The PoSI intervals have advantages compared to the lasso method of Figure
6.12 in that they don’t require  to be known or  to be fixed. On the
other hand, the confidence intervals from PoSI can be very wide. In the diabetes
dataset there are four very strong predictors: their lasso intervals are
essentially unaffected by the selection and look much like the standard leastsquares
intervals. Even with a Bonferroni adjustment from 0.05 to 0.01, the
intervals have approximate length ±2.33·vj·M compared to ±4.42·vj·M for
PoSI. However the authors of PoSI make the point that their method provides
much stronger protection against all kinds of (unreported) things that people
actually do with their data, like fishing for models that have lots of significant
predictors.
A major limitation of PoSI at this time is computation. According to the
authors, with parallel computation the current problem could probably be
solved for models up to size 7 or 8 out of 64, but no larger.
Bibliographic Notes
Our discussion of the Bayesian Lasso is based on Park and Casella (2008). The
bootstrap is due to Efron (1979); the book by Efron and Tibshirani (1993) is a
comprehensive reference. The connection between Bayesian methods and the
bootstrap is explored in various papers (Rubin 1981, Efron 1982, Efron 2011).
The covariance test was introduced in Lockhart, Taylor, Tibshirani2 and
Tibshirani (2014); the discussion following that paper is a valuable resource on
model selection. This work was extended to general models and exact tests in
Taylor, Loftus and Tibshirani2 (2016). The spacing test is proposed in Taylor
et al. (2014), while Lee et al. (2016) derive the fixed  inference procedure
for the lasso. Taylor et al. (2014) and Loftus and Taylor (2014) propose tests
for forward stepwise regression, the latter including categorical variables via
the group lasso penalty. Grazier G’Sell, Wager, Chouldechova and Tibshirani
162 STATISTICAL INFERENCE
(2015) propose FDR-controlling procedures for sequential testing and apply
them to the model selection p-values described here. Grazier G’Sell, Taylor
and Tibshirani (2013) develop a covariance test for the graphical lasso while
Choi, Taylor and Tibshirani (2014) do the same for principal components.
Fithian, Sun and Taylor (2014) provide a general theoretical framework for
conditional inference after model selection, with particular emphasis on exponential
families.
The “debiasing approach” (Section 6.4) was proposed by a number of authors.
For example, Zhang and Zhang (2014) derive confidence intervals for
contrasts of high-dimensional regression coefficients, by replacing the usual
score vector with the residual from a relaxed projection (i.e., the residual
from sparse linear regression). B¨uhlmann (2013) constructs p-values for coefficients
in high-dimensional regression models, starting with ridge estimation
and then employing a bias-correction term that uses the lasso. This initial
work was followed by van de Geer et al. (2013), Javanmard and Montanari
(2014), and Javanmard and Montanari (2013), who all present approaches
for debiasing the lasso estimate based on estimates of the inverse covariance
matrix of the predictors. (The latter work focuses on the special case of a
predictor matrix X with i.i.d. Gaussian rows; the first two consider a general
matrix X.) These debiased lasso estimates are asymptotically normal, which
allows one to compute p-values both marginally for an individual coefficient,
and simultaneously for a group of coefficients. The PoSI (Post-Selection Inference)
method was proposed in Berk et al. (2013).
Exercises
Ex. 6.1
(a) Show that in the orthonormal design setting XTX = Ip×p, the covariance
test (6.5) reduces to the simple form
Tk = 1
2 · k(k − k+1). (6.25)
for all steps k.
(b) Show that for general X, the covariance test (6.5) reduces to (6.25) for
the first step (k = 1)
Ex. 6.2 Show that Rk in Equation (6.4) can be written as a covariance statistic
Rk = 1
2 ·

hy,Xˆ ki − hy,Xˆ k−1i

, (6.26)
where ˆ k is the coefficient vector after k steps of forward stepwise regression
(with the coefficients of those variables not included set to 0).
EXERCISES 163
Ex. 6.3 Sequential control of FDR. Suppose that we carry out tests of a set
of hypotheses H1
0 ,H2
0 , . . . ,Hm0 , using p-values p1, p2, . . . , pm. Let the ordered
p-values be p(1) < p(2) < . . . < p(m). If we apply a procedure that rejects R
of the hypotheses and there are V false positives among these, then the false
discovery rate of the procedure is defined to be E(V/R). Given a target FDR of
, the Benjamini–Hochberg (BH) procedure (Benjamini and Hochberg 1995)
rejects the R hypotheses with the smallest R p-values, where R is the largest
j such that p(j)  · j/m. If the p-values are independent, this procedure has
an FDR of at most .
(a) Compute the univariate regression coefficients bj and standard errors
b sej for each predictor in the diabetes data. Hence obtain approximate
normal scores zj = bj/ b sej and associated (two)-tailed p-values. Apply the
BH procedure to find a list of significant predictors at an FDR of 5%.
(b) Now suppose that our hypotheses have to be considered in order. That
is, we must reject a contiguous initial block of K of the hypotheses H1
0 , H2
0 ,
. . . ,HK0 (or we could reject none of them). The covariance or spacing test
are examples of this. The BH procedure cannot be applied in this setting, as
it does not respect the ordering. For example in Table 6.2, the BH procedure
might tell us to reject the null hypothesis for ltg, but not reject that for
bmi. This is not helpful, because we seek a model consisting of the first k
predictors that enter, for some k  0. There is a generalization of the BH
procedure that can be applied here. Let the p-values from the covariance or
spacing test be p1, p2, . . . pm and let rk = −
Pk
j=1 log(1 − pj)/k. Then the
so-called ForwardStop rule rejects p1, p2, . . . pˆk where ˆk is the largest k such
that rk   (Grazier G’Sell et al. 2015). Apply the ForwardStop rule to the
covariance or spacing test p-values with a target FDR of 5%.
Ex. 6.4 Here we derive a fact about the multivariate normal distribution, and
then in (c) we apply it to derive the spacing test for LAR in the global null case.
Suppose that the random vector Z = (Z1, . . . ,Zp) follows the multivariate
normal distribution N(0,) with jj = 1 for all j.
(a) Let
(j1, s1) = arg max
j2{1,2,...,p}, s2{−1,1}
(sZj)
and assume that these indices are uniquely attained. Define the random
variables
Mj = max
1ip, i6=j, s2{−1,1}

sZi − sijZj
1 − ssjij

. (6.27)
with sj = arg maxs2{−1,1}(sZj ). Show that Mj is independent of Zj , for
j = 1, 2, . . . p.
(b) Let (x) be the CDF of a standard Gaussian, and
U(z,m) = 1 − (z)
1 − (m) . (6.28)
164 STATISTICAL INFERENCE
Verify that j1 = j if and only if Zj  Mj , and prove that U(Zj1 ,Mj1 ) is
uniformly distributed on (0, 1).
(c) In the LAR procedure with standardized predictors, let  = 1
NXTX, and
Zj = 1
N xT
j y. Show that 1 = maxj,s(sZj) and 2 = Mj1 (difficult). Hence
derive the spacing test (6.11).
Ex. 6.5 Show that as N, p ! 1, the covariance test (6.5) and the spacing test
(6.11) are asymptotically equivalent. [Hint: send 2 ! 1 at a rate such that
1/2 ! 1 and apply Mill’s ratio.]
Ex. 6.6 Consider the residual sum of squares function J() = ky−Xk2 and
construct a Newton step for minimizing J() of the form
new    +
@J
@
−1 @J
@
(6.29)
where  is the lasso estimate at some . Show that this has the form (6.16)
with (XTX)−1 replaced by the estimate b from (6.20).
Ex. 6.7 General inference for the LAR algorithm and the lasso. Let y  N(μ, 2I), and consider the distribution of y conditional on the selection
event {Ay  b}.
(a) Show that
{Ay  b} = {V−(y)  T y  V+(y), V0(y)  0} (6.30)
with the variables above defined as follows:
 = A
kk2
V−(y) = max
j:j<0
bj − (Ay)j + jT y
j
V+(y) = min
j:j>0
bj − (Ay)j + jT y
j
V0(y) = min
j:j=0
(bj − (Ay)j) (6.31)
[Hint: subtract E(Ay|T y) from both sides of the inequality Ay  b. Simplify
and examine separately the cases j < 0, = 0 and > 0.]
(b) Let
Fc,d
μ,2 (x) = ((x − μ)/) − ((c − μ)/)
((d − μ)/) − ((c − μ)/) . (6.32)
This is the truncated normal distribution, with support on [c, d]. Show that
FV−,V+
Tμ, 2kk2 (T y) | {Ay  b}  U(0, 1). (6.33)
EXERCISES 165
This result can be used to make inferences about parameter Tμ at a given
step of the LAR algorithm, or for a lasso solution computed at a fixed value
of .
(c) Use result (6.33) to provide an alternate proof of the spacing test result
(6.11).
Ex. 6.8 The kth knot in the LAR algorithm is the value k at which the kth
variable enters the model. At k the coefficient of this variable is zero (about
to grow from zero). Using the KKT optimality conditions, verify expression
(6.12).
Ex. 6.9 With k defined in (6.12), show that ˜k in (6.14) is the absolute
standardized partial regression coefficient of y on xjk , adjusted for XAk−1 .
Ex. 6.10 Consider a solution to the lasso problem
minimize

1
2ky − Xk22
+ kk1,
and let E  {1, . . . , p} denote a candidate active set, and sE 2 {−1, 1}|E|
the signs of the active variables. The KKT conditions corresponding to any
solution bE with the same E and SE are given by
−XT
E(y − XE bE) + sE = 0 (6.34)
−XT
−E(y − XE bE) + s−E = 0, (6.35)
with sign(bE) = sE and ks−Ek1 < 1. Eliminate bE in these equations, and
show that the set of values of y with solution characterized by (E, sE) can be
defined by a set of linear inequalities
Ay  b.
Ex. 6.11 Consider the setup in Example 6.1, and assume xT
j1y is positive.
Using simple inequalities, derive an expression for V−(y). Show that this is
equal to 2, the second LAR knot.

Chapter 7
Matrix Decompositions,
Approximations, and Completion
7.1 Introduction
This chapter is devoted to problems of the following type: given data in the
form of an m×n matrix Z = {zij}, find a matrix bZ that approximates Z in a
suitable sense. One purpose might be to gain an understanding of the matrix
Z through an approximation bZ that has simple structure. Another goal might
be to impute or fill in any missing entries in Z, a problem known as matrix
completion.
Our general approach is to consider estimators based on optimization problems
of the form
bZ = arg min
M2Rm×n kZ −Mk2
F subject to (M)  c, (7.1)
where k · k2
F is the (squared) Frobenius norm of a matrix (defined as the
element-wise sum of squares), and (·) is a constraint function that encourages
bZ to be sparse in some general sense. The manner in which we impose sparsity
leads to a variety of useful procedures, many of which are discussed in this
chapter. One can regularize the overall approximating matrix bZ, or factor
it and regularize the components of its factorization. Of course, there are
variations: for instance, the observed matrix Z might have missing entries,
so that the squared Frobenius norm k · k2
F is modified accordingly. In other
settings, we might impose multiple constraints on the approximating matrix bZ.
Table 7.1 provides a summary of the methods discussed in this chapter.
Method (a) is based on a simple `1-norm constraint on all of the entries on
the matrix bZ; this constraint leads to a soft-thresholded version of the original
matrix—that is, the optimal solution to our general problem (7.1) takes
the form bzij = sign(zij)(|zij | − 
)+, where the scalar 
 > 0 is chosen so
that Pm
i=1
Pn
j=1 |bzij | = c. The resulting estimate bZ can be useful in the context
of sparse covariance estimation. Method (b) bounds the rank of bZ, or in
other words, the number of nonzero singular values in bZ. Although the matrix
approximation problem (7.1) with such a rank constraint is nonconvex,
167
168 MATRIX DECOMPOSITIONS
Table 7.1 Different formulations for the matrix approximation problem.
Constraint Resulting method
(a) kbZk`1  c Sparse matrix approximation
(b) rank(bZ)  k Singular value decomposition
(c) kbZk?  c Convex matrix approximation
(d) bZ = UDVT ,
1(uj)  c1, 2(vk)  c2 Penalized SVD
(e) bZ = LRT ,
1(L)  c1, 2(R)  c2 Max-margin matrix factorization
(f) bZ = L + S,
1(L)  c1, 2(S)  c2 Additive matrix decomposition
the optimal solution is easily found by computing the singular value decomposition
(SVD) and truncating it to its top k components. In method (c),
we relax the rank constraint to a nuclear norm constraint, namely an upper
bound on the sum of the singular values of the matrix. The nuclear norm is
a convex matrix function, so that the problem in (c) is convex and can be
solved by computing the SVD, and soft-thresholding its singular values. This
modification—from a rank constraint in (b) to the nuclear norm constraint in
(c)—becomes important when the methods are applied to matrices with missing
elements. In such settings, we can solve the corresponding problem (c)
exactly, whereas methods based on (b) are more difficult to solve in general.
The approach in (d) imposes penalties on the left and right singular vectors
of bZ. Examples of the penalty functions or regularizers 1 and 2 include the
usual `2 or `1 norms, the latter choice yielding sparsity in the elements of the
singular vectors. This property is useful for problems where interpretation of
the singular vectors is important. Approach (e) imposes penalties directly on
the components of the LR-matrix factorization; although ostensibly similar to
approach (d), we will see it is closer to (c) when 1 and 2 are the Frobenius
norm. Finally, approach (f) seeks an additive decomposition of the matrix,
imposing penalties on both components in the sum.
Matrix decompositions also provide an approach for constructing sparse
versions of popular multivariate statistical methods such as principal component
analysis, canonical correlation analysis and linear discriminant analysis.
In this case, the matrix Z is not the raw data, but is derived from the raw
data. For example, principal components are based on the sample covariance
matrix (or the column-centered data matrix), canonical correlation uses the
cross-products matrix from two sets of measurements, while clustering starts
with inter-point distances. We discuss these multivariate methods, and related
approaches to these problems, in Chapter 8.
THE SINGULAR VALUE DECOMPOSITION 169
7.2 The Singular Value Decomposition
Given an m× n matrix Z with m  n, its singular value decomposition takes
the form
Z = UDVT . (7.2)
This decomposition is standard in numerical linear algebra, and many algorithms
exist for computing it efficiently (see, for example, the book by Golub
and Loan (1996)). Here U is an m×n orthogonal matrix (UTU = In) whose
columns uj 2 Rm are called the left singular vectors. Similarly, the matrix
V is an n × n orthogonal matrix (VTV = In) whose columns vj 2 Rn are
called the right singular vectors. The n × n matrix D is diagonal, with diagonal
elements d1  d2  · · ·  dn  0 known as the singular values. If these
diagonal entries {d`}n
`=1 are unique, then so are U and V, up to column-wise
sign flips. If the columns of Z (the variables) are centered, then the right singular
vectors {vj}nj
=1 define the principal components of Z. Consequently, the
unit vector v1 yields the linear combination s1 = Zv1 with highest sample
variance among all possible choices of unit vectors. Here s1 is called the first
principal component of Z, and v1 is the corresponding direction or loading
vector. Similarly, s2 = Zv2 is the second principal component, with maximal
sample variance among all linear combinations uncorrelated with s1, and so
on. See Exercise 7.1 and Section 8.2.1 for further details.
The singular value decomposition provides a solution to the rank-q matrix
approximation problem. Suppose r  rank(Z), and let Dr be a diagonal matrix
with all but the first r diagonal entries of the diagonal matrix D set to
zero. Then the optimization problem
minimize
rank(M)=r kZ −MkF (7.3)
actually has a closed form solution bZr = UDrVT , a decomposition known
as the rank-r SVD (see Exercise 7.2). The estimate bZr is sparse in the sense
that all but r singular values are zero. A fuller discussion of the SVD—in the
context of principal components analysis—is given in Section 8.2.1.
7.3 Missing Data and Matrix Completion
What if some of the entries of Z are missing? In general, the problem of
filling in or imputing missing values in a matrix is known as matrix completion
(Laurent 2001). Of course, the matrix completion problem is ill-specified
unless we impose additional constraints on the unknown matrix Z, and one
common choice is a rank constraint. Low-rank forms of matrix completion
arise in the problem of collaborative filtering and can be used to build recommender
systems.
The SVD provides an effective method for matrix completion. Formally,
suppose that we observe all entries of the matrix Z indexed by the subset
170 MATRIX DECOMPOSITIONS

  {1, . . . ,m} × {1, . . . , n}. Given such observations, a natural approach is
to seek the lowest rank approximating matrix bZ that interpolates the observed
entries of Z—namely
minimize rank(M) subject to mij = zij for all (i, j) 2 
. (7.4)
Unlike its fully observed counterpart, this rank-minimization problem is computationally
intractable (NP-hard), and cannot be solved in general even for
moderately large matrices.
In addition, forcing the estimate M to interpolate each of the observed
entries zij will often be too harsh and can lead to overfitting; it is generally
better to allow M to make some errors on the observed data as well.
Accordingly, consider the optimization problem
minimize rank(M) subject to P
(i,j)2

(zij − mij)2  , (7.5)
or its equivalent form
minimize
rank(M)r
X
(i,j)2

(zij − mij)2. (7.6)
In words, we seek the matrix bZ = bZr of rank at most r that best approximates
the observed entries of our matrix Z, with the other entries of bZr serving to
fill in the missing values. The family of solutions generated by varying  in
optimization problem (7.5) is the same as that generated by varying r in
problem (7.6).
Unfortunately, both optimization problems (7.5) and (7.6) are nonconvex,
and so exact solutions are in general not available. However, there are useful
heuristic algorithms that can be used to find local minima. For instance, suppose
that we start with an initial guess for the missing values, and use them to
complete Z. We then compute the rank-r SVD approximation of the filled-in
matrix as in (7.3), and use it to provide new estimates for the missing values.
This process is repeated till convergence. The missing value imputation for a
missing entry xij is simply the (i, j)th entry of the final rank-r approximation
bZ. See Mazumder, Hastie and Tibshirani (2010) for further details. In Section
7.3.2, we discuss convex relaxations of these optimization problems based
on the nuclear norm, for which exact solutions are available.
7.3.1 The Netflix Movie Challenge
The Netflix movie-rating challenge has become one of the canonical examples
for matrix completion (Bennett and Lanning 2007). Netflix is a movie-rental
company that launched a competition in 2006 to try to improve their system
for recommending movies to their customers. The Netflix dataset has
n = 17, 770 movies (columns) and m = 480, 189 customers (rows). Customers
MISSING DATA AND MATRIX COMPLETION 171
Figure 7.1 The Netflix competition leaderboard at the close of the competition.
172 MATRIX DECOMPOSITIONS
have rated some of the movies on a scale from 1 to 5, where 1 is worst and
5 is best. The data matrix is very sparse with “only” 100 million (1%) of
the ratings present in the training set. The goal is to predict the ratings for
unrated movies, so as to better recommend movies to customers. In 2006,
the “Cinematch” algorithm used by Netflix had a root-mean-square error of
0.9525 over a large test set. A competition was held starting in 2006, with the
winner being the first algorithm that could improve this RMSE by at least
10%. The competition was finally won in 2009 by a large group of researchers
called “Bellkor’s Pragmatic Chaos,” which was the combined effort of three
individual groups. The winning algorithm used a combination of a large number
of statistical techniques, but as with many of the competing algorithms,
the SVD played a central role. Figure 7.1 shows the leaderboard at the close
of the competition.
Table 7.2 Excerpt of the Netflix movie rating data. The movies are rated from 1
(worst) to 5 (best). The symbol • represents a missing value: a movie that was not
rated by the corresponding customer.
Dirty Dancing
Meet the Parents
Top Gun
The Sixth Sense
Catch Me If You Can
The Royal Tenenbaums
Con Air
Big Fish
The Matrix
A Few Good Men
Customer 1 • • • • 4 • • • • •
Customer 2 • • 3 • • • 3 • • 3
Customer 3 • 2 • 4 • • • • 2 •
Customer 4 3 • • • • • • • • •
Customer 5 5 5 • • 4 • • • • •
Customer 6 • • • • • 2 4 • • •
Customer 7 • • 5 • • • • 3 • •
Customer 8 • • • • • 2 • • • 3
Customer 9 3 • • • 5 • • 5 • •
Customer 10 • • • • • • • • • •
A low rank model provides a good heuristic for rating movies: in particular,
suppose that we model the rating of user i on movie j by a model of the form
zij =
Xr
`=1
ci`gj` + wij , (7.7)
or in matrix form Z = CGT +W, where C 2 Rm×r and G 2 Rn×r. In this
model, there are r genres of movies, and corresponding to each is a clique
of viewers who like them. Here viewer i has a membership weight of ci` for
the `th clique, and the genre associated with this clique has a score gj` for
movie j. The overall user rating is obtained by summing these products over
MISSING DATA AND MATRIX COMPLETION 173
` (cliques/genres), and then adding some noise. Table 7.2 shows the data for
the ten customers and ten movies with the most ratings.
The competition identified a “probe set” of ratings, about 1.4 million of
the entries, for testing purposes. These were not a random draw, rather movies
that had appeared chronologically later than most. Figure 7.2 shows the rootmean-
squared error over the training and test sets as the rank of the SVD
was varied. Also shown are the results from an estimator based on nuclear
norm regularization, discussed in the next section. Here we double centered
the training data, by removing row and column means. This amounts to fitting
the model
zij = i + j +
Xr
`=1
ci`gj` + wij ; (7.8)
However, the row and column means can be estimated separately, using a
simple two-way ANOVA regression model (on unbalanced data).
0 50 100 150 200
0.7 0.8 0.9 1.0
Rank
RMSE
Train
Test
0.65 0.70 0.75 0.80 0.85 0.90
0.95 0.96 0.97 0.98 0.99 1.00
Training RMSE
Test RMSE
Hard−Impute
Soft−Impute
Netflix Competition Data
Figure 7.2 Left: Root-mean-squared error for the Netflix training and test data for
the iterated-SVD (Hard-Impute) and the convex spectral-regularization algorithm
(Soft-Impute). Each is plotted against the rank of the solution, an imperfect calibrator
for the regularized solution. Right: Test error only, plotted against training
error, for the two methods. The training error captures the amount of fitting that
each method performs. The dotted line represents the baseline “Cinematch” score.
While the iterated-SVD method is quite effective, it is not guaranteed to
find the optimal solution for each rank. It also tends to overfit in this example,
when compared to the regularized solution. In the next section, we present
a convex relaxation of this setup that leads to an algorithm with guaranteed
convergence properties.
174 MATRIX DECOMPOSITIONS
7.3.2 Matrix Completion Using Nuclear Norm
A convenient convex relaxation of the nonconvex objective function (7.4) is
given by
minimize kMk? subject to mij = zij for all (i, j) 2 
, (7.9)
where kMk? is the nuclear norm, or the sum of the singular values of M.
It is also sometimes called the trace norm.1 Figure 7.3 shows the level set
of the nuclear norm of a symmetric 2 × 2 matrix, and depicts the convex
problem (7.9).2
The nuclear norm is a convex relaxation of the rank of a matrix, and hence
problem (7.9) is convex (Fazel 2002). Specifically, as shown in Exercise 7.3,
it is a semi-definite program (SDP), a particular class of convex programs
for which special purpose solvers can be applied. The underlying convexity
is also theoretically useful, since one can characterize the properties of the
observed matrix and sample size under which the method succeeds in exactly
reconstructing the matrix, as discussed in Section 7.3.3.
M
Feasible set






x y
y z






 
Figure 7.3 The blue cylinder shows the level set of the nuclear norm unit-ball for
a symmetric 2×2 matrix. The tangent plane is the feasible set z = z0 for the matrix
imputation problem where we observe z and wish to impute x and y. The point
M is the solution that we seek, leading to the minimum value for . This figure is
analogous to the lasso estimation picture in Figure 2.2 of Chapter 2.
In practice, however, it is unrealistic to model the observed entries as
being noiseless. Accordingly, a more practical method is based on the following
1This terminology can be confusing: for symmetric, positive semi-definite matrices, the
trace is the sum of the eigenvalues. For general matrices, “trace norm” refers to trace
p
ATA,
which is the sum of the singular values.
2Thanks to Emmanuel Candes and Benjamin Recht for providing Figure 7.3.
MISSING DATA AND MATRIX COMPLETION 175
relaxed version of the program (7.9):
minimize
M
8<
:
12
X
(i,j)2

(zij − mij)2 + kMk?
9=
;, (7.10)
called spectral regularization. As in our relaxation from problem (7.4) to (7.6),
this modification allows for solutions bZ that do not fit the observed entries
exactly, thereby reducing potential overfitting in the case of noisy entries.
The parameter  is a tuning parameter that must be chosen from the data,
typically by cross-validation. As in the previous section, we do not necessarily
require the error P
(i,j)2
(zij − mij)2 to be zero, and this will only occur for
a sufficiently small value of .
There is a simple algorithm for solving (7.10), similar to the iterated SVD
for missing-data imputation in the previous section. First consider the case
where there is no missing data, so that the set 
 of observed entries includes
all m· n pairs (i, j) 2 {1, . . . ,m}×{1, . . . , n}. Then to solve (7.10), we simply
compute the SVD of Z, soft-threshold the singular values by , and reconstruct
the matrix. This observation leads to an obvious procedure for the setup with
missing data. We start with an initial guess for the missing values, compute
the (full rank) SVD, and then soft-threshold its singular values by an amount
. We reconstruct the corresponding SVD approximation and obtain new
estimates for the missing values. This process is repeated until convergence.
In order to describe this procedure more precisely, we require some more
notation. Given an observed subset 
 of matrix entries, we can define the
projection operator P
 : Rm×n 7! Rm×n as follows:
[P
(Z)]ij =
(
zij if (i, j) 2 

0 if (i, j) /2 
,
(7.11)
so that P
 replaces the missing entries in Z with zeros, and leaves the observed
entries alone. With this definition, we have the equivalence
X
(i,j)2

(zij − mij)2 = kP
(Z) − P
(M)k2
F. (7.12)
Given the singular value decomposition3 W= UDVT of a rank-r matrix W,
we define its soft-thresholded version as
S(W)  UDVT where D = diag [(d1 − )+, . . . , (dr − )+] (7.13)
(note that the soft-threshholding can reduce the rank even further). Using
this operator, the procedure for solving (7.10) is given in Algorithm 7.1.
This algorithm was proposed and studied by Mazumder et al. (2010), where
3If a matrix has rank r < min(m, n), we assume its SVD is represented in the truncated
form, discarding the singular values of zero, and the corresponding left and right vectors.
176 MATRIX DECOMPOSITIONS
Algorithm 7.1 Soft-Impute for matrix completion.
1. Initialize Zold = 0 and create a decreasing grid 1 > . . . > K.
2. For each k = 1, . . . ,K, set  = k and iterate until convergence:
Compute bZ   S
􀀀
P
(Z) + P?

 (Zold)

.
Update Zold   bZ
3. Output the sequence of solutions bZ1 , . . . , bZK.
its convergence to the global solution is established. In Exercise 7.4, the reader
is asked to verify that a fixed point of the algorithm satisfies the zero subgradient
equations associated with the objective function (7.10). It can also
be derived as a first-order Nesterov algorithm (see Exercise 7.5). Each iteration
requires an SVD computation of a (potentially large) dense matrix, even
though P
(Z) is sparse. For “Netflix-sized” problems, such large dense matrices
can typically not even be stored in memory (68Gb with 8 bytes per entry).
Note, however, that we can write
P
(Z) + P?

 (Zold) = P
(Z) − P
(Zold)
| {z }
sparse
+ Zold
|{z}
low rank
. (7.14)
The first component is sparse, with |
| nonmissing entries. The second component
is a soft-thresholded SVD, so can be represented using the corresponding
components. Moreover, for each component, we can exploit their special
structure to efficiently perform left and right multiplications by a vector, and
thereby apply iterative Lanczos methods to compute a (low rank) SVD efficiently.
It can be shown that this iterative algorithm converges to the solution
of the problem
minimize
M2Rm×n
1
2kP
(Z) − P
(M)k2
F + kMk?

, (7.15)
which is another way of writing the objective function in (7.10).
Figure 7.2 shows the results of Soft-Impute applied to the Netflix example.
We see that the regularization has paid off, since it outperforms the
iterated SVD algorithm Hard-Impute. It takes longer to overfit, and because
of the regularization, is able to use a higher rank solution. Taking advantage of
the warm starts in Algorithm 7.1, it took under 5 hours of computing to produce
the solution path in Figure 7.2, using the R package softImpute (Hastie
and Mazumder 2013). See also Figure 7.5 in Section 7.3.3, which illustrates
the performance of the Soft-Impute algorithm for noisy matrix completion
over a range of different ranks and sample sizes. We discuss this figure at more
length in that section.
In terms of convergence speed, Mazumder et al. (2010) show that the
Soft-Impute algorithm is guaranteed to converge at least sub-linearly, meaning
that O(1/) iterations are sufficient to compute a solution that is -close
MISSING DATA AND MATRIX COMPLETION 177
to the global optimum. In the absence of additional structure (such as strong
convexity), this is the fastest rate that can be expected from a first-order gradient
method (Nemirovski and Yudin 1983). Interestingly, in certain settings,
it can be shown that simple first-order methods converge at a much faster
geometric rate, meaning that O(log(1/)) iterations are sufficient to compute
a -optimum. For instance, Agarwal, Negahban and Wainwright (2012a) analyze
an algorithm closely related to the Soft-Impute algorithm; they show
that under the same conditions that guarantee good statistical performance
of the nuclear norm estimator, this first-order algorithm is guaranteed to converge
at the geometric rate.
7.3.3 Theoretical Results for Matrix Completion
There are a variety of theoretical results for matrix completion using nuclearnorm
regularization. Beginning with the simpler “no-noise” case, suppose that
we sample N entries of a p × p matrix uniformly at random. How large does
N need to be, as a function of the matrix dimension p and rank r, for the
nuclear norm relaxation (7.9) to recover the matrix exactly? Of course, this
is always possible if N  p2, so that our interest is in guarantees based on
N  p2 samples.
A first easy observation is that if there are no observed entries in some
row (or column) of the matrix, then it is impossible to recover the matrix
exactly, even if it is rank one. In Exercise 7.8, we show how this argument
implies that any method—not only nuclear norm relaxation—needs at least
N > p log p samples, even for a rank one matrix. This phenomenon is an
instance of the famous “coupon collector” problem (Erdos and Renyi 1961).
As for the effect of the rank, note that we need roughly O(rp) parameters
to specify an arbitrary p × p matrix with rank r, since it has O(r) singular
vectors, each with p components. As we will see, under certain restrictions
on the “coherence” of the matrices, nuclear norm relaxation succeeds in exact
recovery based on a sample size just a logarithmic factor larger. Coherence
measures the extent to which the singular vectors of a matrix are aligned with
the standard basis.
In order to appreciate the need for coherence constraints, consider the
rank-one matrix Z = e1eT1
, with a single one in its upper left corner, as shown
on the left side of Equation (7.16) below:
Z =
0
BB@ 1
0
0
0
0 0 0 0
0 0 0 0
0 0 0 0
1
CCA
and Z0 =
0
BB@
v1 v2 v3 v4
0 0 0 0
0 0 0 0
0 0 0 0
1
CCA
. (7.16)
If we are allowed to observe only N  p2 entries of this matrix, with the
entries chosen uniformly at random, then with high probability, we will not
observe the single nonzero entry, and hence have no hope of distinguishing
it from the all-zeroes matrix. Similar concerns apply to a matrix of the form
178 MATRIX DECOMPOSITIONS
Z0 = e1vT , where v 2 Rp is an arbitrary p vector, as shown on the right side of
Equation (7.16). Thus, any theoretical guarantees on nuclear norm regularization
must somehow account for these pathological cases. Both the matrices Z
and Z0 have maximal coherence with the standard basis of R4, meaning that
some subset of their left and/or right singular vectors are perfectly aligned
with some standard basis vector ej .
One way to exclude troublesome matrices is by drawing matrices from
some random ensemble; for instance, we might construct a random matrix
of the form Z = Pr
j=1 ajbTj
, where the random vectors aj  N(0, Ip) and
bj  N(0, Ip) are all independently drawn. Such random matrices are extremely
unlikely to have singular vectors that are highly coherent with standard
basis vectors. For this ensemble, Gross (2011) shows that with high
probability over the randomness in the ensemble and sampling, the nuclear
norm relaxation succeeds in exact recovery if the number of samples satisfies
N  Crp log p, (7.17)
where C > 0 is a fixed universal constant. See also Cand`es and Recht (2009)
for earlier but somewhat weaker guarantees. More generally, it is possible
to give exact recovery guarantees in which the pre-factor C depends on the
singular vector incoherence, as measured by the maximal alignment between
the singular vectors and the standard basis. We refer the reader to the papers
by Cand`es and Recht (2009), Gross (2011), and Recht (2011) for further details
on results of this type, as well as to Keshavan, Oh and Montanari (2009) for
related results on a slightly different estimator.
We carried out a small simulation study to better understand what result
(7.17) is saying. We generated matrices U,V each of size p × r and with i.i.d
standard normal entries and defined Z = UVT . Then we set to missing a fixed
proportion of entries, and applied Soft-Impute with  chosen small enough
so that kP
(Z− bZ)k2
F/kP
(Z)k2
F < 10−5; in other words, the observed entries
are (effectively) reproduced. Then we checked to see if
kP?

 (Z − bZ)k22
/kP?

 (Z)k22
< 10−5, (7.18)
that is, the missing data was interpolated. The process was repeated 100 times
for various values of the rank r and the proportion set to missing.
The proportion of times that the missing data was successfully interpolated
is shown in Figure 7.4. We see that when the rank is a small fraction of
the matrix dimension, one can reproduce the missing entries with fairly high
probability. But this gets significantly more difficult when the true rank is
higher.
Of course, the “exact” setting is often not realistic, and it might be more
reasonable to assume some subset of the entries are observed with additional
noise, as in observation model (7.7)—that is, Z = L+W, where L has rank r.
In this setting, exact matrix completion is not generally possible, and we would
be interested in how well we can approximate the low-rank matrix L using the
MISSING DATA AND MATRIX COMPLETION 179
0.0 0.2 0.4 0.6
0.0 0.2 0.4 0.6 0.8 1.0
Proportion Missing
Probability of Exact Completion
Rank 1
p=20
p=40
0.0 0.2 0.4 0.6
0.0 0.2 0.4 0.6 0.8 1.0
Proportion Missing
Probability of Exact Completion
Rank 5
Figure 7.4 Convex matrix completion in the no-noise setting. Shown are probabilities
of exact completion (mean ± one standard error) as a function of the proportion
missing, for n×n matrices with n 2 {20, 40}. The true rank of the complete matrix
is one in the left panel and five in the right panel.
estimator (7.10). Singular vector incoherence conditions are less appropriate
for noisy observations, because they are not robust to small perturbations.
To understand this issue, suppose that we start with a matrix B that has
rank r − 1, Frobenius norm one, and is maximally incoherent, meaning that
all its singular vectors are orthogonal to the standard basis vectors. Recalling
the troublesome matrix Z from Equation (7.16), now consider the perturbed
matrix L = B+Z for some  > 0. The matrix L always has rank r, and no
matter how small we choose the parameter , it is always maximally coherent,
since it has the standard basis vector e1 2 Rp as one of its singular vectors.
An alternative criterion that is not sensitive to such small perturbations is
based on the “spikiness” ratio of a matrix (Negahban and Wainwright 2012).
In particular, for any nonzero matrix L 2 Rp×p, we define sp(L) = pkLk1
kLkF ,
where kLk1 is the element-wise maximum absolute value of the matrix entries.
This ratio is a measure of the uniformity (or lack thereof) in the spread of
the matrix entries; it ranges between 1 and p. For instance, any matrix L
with all equal entries has sp(L) = 1, the minimal value, whereas the spikiest
possible matrix such as Z from Equation (7.16) achieves the maximal spikiness
ratio sp(Z) = p. In contrast to singular vector incoherence, the spikiness
ratio involves the singular values (as well as the vectors). Thus, the matrix
L = B+Z. will have a low spikiness ratio whenever the perturbation  > 0
is sufficiently small.
For the nuclear-norm regularized estimator (7.10) with a bound on the
180 MATRIX DECOMPOSITIONS
spikiness ratio, Negahban and Wainwright (2012) show that the estimate bL
satisfies a bound of the form
kbL − Lk2
F
kLk2
F  C max

2, 2
sp(L)
	 rp log p
N
(7.19)
with high probability over the sampling pattern, and random noise (assumed
i.i.d., zero-mean with all moments finite, and variance 2). See also Keshavan,
Montanari and Oh (2010) and Koltchinskii, Lounici and Tsybakov (2011), who
prove related guarantees for slightly different estimators.
Rank Ratio
Observation Ratio
Performance of Nuclear Norm Regularization
0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9
1
0.9
0.8
0.7
0.6
0.5
0.4
0.3
0.2
0.1
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Figure 7.5 Performance of the nuclear-norm regularized estimator (7.10), solved
via the Soft-Impute algorithm, for noisy matrix completion under the model (7.7)
with matrix L = CGT of rank r. Plots of the relative Frobenius norm error kbL −
Lk2
F/kLk2
F for p = 50 as a function of the rank ratio  = r log p
p and observation
ratio  = N
p2 , corresponding to the fraction of observed entries in a p × p matrix.
Observations were of the linear form (7.7) with wij  N(0, 2) where  = 1/4, and
we used the Soft-Impute algorithm to solve the program (7.10) with /N = 2
pp
N ,
the latter choice suggested by theory. The theory also predicts that the Frobenius error
should be low as long as  % , a prediction confirmed in this plot.
In order to better understand the guarantee (7.19), we carried out a simulation.
Let us define the ratio  = N
p2 2 (0, 1), corresponding to the fraction
of observed entries in a p × p matrix, and the rank ratio  = r log p
p , corresponding
to the relative rank of the matrix (up to a logarithmic factor). For
a constant noise variance and spikiness ratio, the bound predicts that the estimator
(7.10) should have low relative mean-squared error whenever  > .
Figure 7.5 confirms this prediction, and shows that the theory is actually
somewhat conservative; see the figure caption for further details.
MISSING DATA AND MATRIX COMPLETION 181
0.0 0.2 0.4 0.6
1.0 1.5 2.0 2.5 3.0 3.5
Proportion Missing
Average Relative Error
Rank 1
0.0 0.2 0.4 0.6
1.0 1.5 2.0 2.5 3.0 3.5
Proportion Missing
Average Relative Error
Rank 5
Figure 7.6 Matrix completion via Soft-Impute in the noisy setting. The plots show
the imputation error from matrix completion as a function of the proportion missing,
for 40×40 matrices. Shown are the mean absolute error( ± one standard error) over
100 simulations, all relative to the noise standard deviation. In each case we chose
the penalty parameter to minimize the imputation error, and the results would be
somewhat worse if that parameter were chosen by cross-validation. The true rank of
the complete matrix is one in the left panel and five in the right panel. The average
absolute size of each matrix entry was 0.80 and 1.77 in the left and right panels,
respectively.
Figure 7.6 is another illustration of the imputation error from matrix completion
in the noisy setting. Here we use Soft-Impute on 40 × 40 matrices,
with entries generated from a standard Gaussian matrix with rank r = 1 or
5, plus noise of standard deviation  = 0.5. We see that for rank one, we
can impute the missing values with average error close to  even when the
proportion missing is as high as 50%. However when the true rank increases
to five, the procedure starts to break down at about 30% missing.
7.3.4 Maximum Margin Factorization and Related Methods
Here we discuss a class of techniques that are close in spirit to the method of
the previous section. These are known as maximum margin matrix factorization
methods (MMMF), and use a factor model for approximating the matrix
Z (Rennie and Srebro 2005).4 Consider a matrix factorization of the form
M = ABT , where A and B are m × r and n × r, respectively. One way to
4The “maximum margin” refers to the particular margin-based loss used by these authors;
although we use squared-error loss, our focus is on the penalty, so we use the same
acronym.
182 MATRIX DECOMPOSITIONS
estimate such a factorization is by solving the optimization problem
minimize
A2R
m×r
B2R
n×r

kP
(Z) − P
(ABT )k2
F + 
􀀀
kAk2
F + kBk2
F
	
. (7.20)
Interestingly, this problem turns out to be equivalent to the nuclear norm
regularized problem (7.10) for sufficiently large r, in a way that we now make
precise. First, for any matrix M, it can be shown (Rennie and Srebro 2005,
Mazumder et al. 2010) that
kMk? = min
A2R
m×r, B2R
n×r
M=ABT
12
􀀀
kAk2
F + kBk2
F

(7.21)
As shown in Exercise 7.6, the solution to the problem (7.21) need not be
unique. However, the equivalence (7.21) implies that the family of solutions
cM = bAbBT of the biconvex problems (7.20) for r  min(m, n) are the same as
those for the family of convex problems (7.10). To be more specific, we have
the following result:
Theorem 1. Let Z be an m × n matrix with observed entries indexed by 
.
(a) The solutions to the MMMF criterion (7.20) with r = min{m, n} and the
nuclear norm regularized criterion (7.10) coincide for all   0.
(b) For some fixed  > 0, suppose that the objective (7.10) has an optimal
solution with rank r. Then for any optimal solution ( bA, bB) to the
problem (7.20) with r  r and  = , the matrix cM = bAbBT is an optimal
solution for the problem (7.10). Consequently, the solution space of
the objective (7.10) is contained in that of (7.20).
The MMMF criterion (7.20) defines a two-dimensional family of models
indexed by the pair (r, ), while the Soft-Impute criterion (7.10) defines a
one-dimensional family. In light of Theorem 1, this family is a special path
in the two-dimensional grid of solutions

bA(r,), bB(r,)

. Figure 7.7 depicts
the situation. Any MMMF model at parameter combinations above the red
points are redundant, since their fit is the same at the red point. However, in
practice the red points are not known to MMMF, nor is the actual rank of the
solution. Further orthogonalization of bA and bB would be required to reveal
the rank, which would only be approximate (depending on the convergence
criterion of the MMMF algorithm). In summary, the formulation (7.10) is
preferable for two reasons: it is convex and it does both rank reduction and
regularization at the same time. Using (7.20) we need to choose the rank of
the approximation and the regularization parameter .
In a related approach, Keshavan et al. (2010) propose the criterion
kP
(Z) − P
(USVT )k2
F + kSk2
F, (7.22)
to be minimized over the triplet (U,V, S), where UTU = VTV = Ir and
MISSING DATA AND MATRIX COMPLETION 183
−4 −2 0 2 4 6
0 20 40 60 80 100
Rank r
log 
Figure 7.7 Comparison of the parameter space for MMMF (gray and black points),
and Soft-Impute (red points) for a simple example. MMMF solutions for ranks
above the red points are identical to the Soft-Impute solutions at the red points and
hence the gray points are redundant. On the other hand, fixing a rank for MMMF
(for a given ) that is less than that of the Soft-Impute solution leads to a nonconvex
problem.
S is an r × r matrix. For a fixed rank r, they minimize the criterion (7.22)
by gradient descent. This criterion is similar to the MMMF criterion (7.20),
except that the matrices U,V are constrained to be orthonormal, so that
the “signal” and corresponding regularization are shifted to the (full) matrix
S. Like MMMF, the problem is nonconvex so that gradient descent is not
guaranteed to converge to the global optimum; moreover, it must be solved
separately for different values of the rank r.
Keshavan et al. (2010) provide some asymptotic theory for the estimator
(7.22) when applied to noisy matrix completion, using a scaling in which
the aspect ratio m/n converges to some constant  2 (0, 1). Here is a rough
description of one such result. Consider an m×n matrix Z that can be written
as a sum of the form Z = UV +W, where  2 Rr×r is a diagonal matrix.
Here the term W is a random matrix with i.i.d. entries, each with zero mean
and variance 2pmn. Each entry of the matrix Z is assumed to be observed
independently with probability . Let bZ be the estimate obtained by minimizing
the criterion (7.22) using the optimal value for . For this criterion,
Keshavan et al. (2010) show that the relative error kbZ−Zk2
F/kZk2
F converges
in probability to a quantity 1 − c() as as m/n !  2 (0, 1). The constant
c() is zero if 2/  maxjj jj and nonzero otherwise. This shows that the
estimator undergoes a phase transition: if the noise and probability of missing
entries are low relative to the signal strength, then the missing entries can be
recovered successfully. Otherwise they are essentially useless in reconstructing
the missing entries. Full details may be found in Keshavan et al. (2009) and
Keshavan et al. (2010).
184 MATRIX DECOMPOSITIONS
7.4 Reduced-Rank Regression
In this section we briefly revisit a topic touched on in Section 4.3, namely multivariate
regression. We have vector-valued responses yi 2 RK and covariates
xi 2 Rp, and we wish to build a series of K linear regression models. With N
observations on (yi, xi), we can write these regression models in matrix form
as
Y = X + E, (7.23)
with Y 2 RN×K, X 2 RN×p,  2 Rp×K a matrix of coefficients, and E 2 RN×K a matrix of errors.
The simplest approach would be to fit K separate models, perhaps via
the lasso or elastic net. However, the idea is that the responses may have a
lot in common, and these similarities can be used to borrow strength when
fitting the K regression models. In Section 4.3, we used the group lasso to
select variables simultaneously for each response; i.e., we used the group lasso
to set whole rows of  to zero. In this section we instead assume  has low
rank. The same ideas underlie multitask machine learning. Hence we entertain
models of the form
Y = XABT + E, (7.24)
with A 2 Rp×r and B 2 RK×r. One can think of having r < K derived
features Z = XbA which are then distributed among the responses via K
separate regressions bY = ZbBT . Although fitting (7.24) by least-squares is
a nonconvex optimization problem, with N > p closed-form solutions are
available through a form of canonical-correlation analysis (Hastie et al. 2009).
Example 7.1. As an example, we consider the problem of video denoising. Figure
7.8 shows four representative images of a video taken by a helicopter flying
over the desert. Each column j of the matrix Y represents an image frame (in
a vectorized form) at a time k, and the full matrix Y represents a video consisting
of K image frames. The p columns of X represent a dictionary of image
basis functions (e.g.,unions of orthonormal bases; see Chapter 10). Imposing a
low rank model on  is reasonable when the video sequence changes relatively
slowly over time (as they do in this sequence), so that most of its variation
can be described by linear combinations of a small number of representative
images.
Figure 7.9 shows the SVD computed using K = 100 frames from the video
in Figure 7.8; although the matrix Y is not exactly low-rank, its singular
values decay rapidly, suggesting that it can be well-approximated by a lowrank
matrix. }
As before, the nuclear norm is a useful convex penalty for enforcing lowrank
structure on an estimate. In this case we would solve the optimization
problem
minimize
2Rp×K

kY − Xk2
F + kk?
	
, (7.25)
and for sufficiently large values of  the solution b would have rank less than
min(N,K).
A GENERAL MATRIX REGRESSION FRAMEWORK 185
Figure 7.8 Four 352×640 image frames from a video sequence of a helicopter flying
over the desert. Each image was converted to a vector in RN with N = 352×640 =
225280 elements, and represented by one column of the matrix Y.
7.5 A General Matrix Regression Framework
In this section we present a general “trace” regression framework, that includes
matrix completion and reduced-rank regression as special cases. This general
framework allows for a unified theoretical treatment.
Let’s start with matrix completion. Let M represent a model underlying a
partially observed m×n matrix Z that we wish to complete. Then we consider
observations (Xi, yi), i = 1, 2, . . . , |
| from the model
yi = trace(XTi
M) + "i. (7.26)
Here Xi are m × n matrices and yi and "i are scalars. The observation
model (7.26) can be viewed as a regression with inputs the matrices Xi and
outputs the yi. The trace inner product on matrices plays the role of an ordinary
inner product on vectors, but otherwise everything is conceptually the
same as in a usual regression model.5
To relate this to matrix completion, let [a(i), b(i)] be the row-column
indices of the matrix entry observed in observation i. We then define
5Recall that if A and B are both m × n matrices, trace(ATB) =
Pm
i=1
Pn
j=1 aijbij .
186 MATRIX DECOMPOSITIONS
0 20 40 60 80 100
0.0 0.2 0.4 0.6 0.8 1.0
Index
Singular Value
SVD for K=100 Frames
Figure 7.9 Singular values of the matrix Y 2 Rp×K using K = 100 frames from
the video sequence. Note the rapid decay, showing that a low-rank approximation is
possible.
Xi = ena
(i)emb
(i)
T , where em` 2 Rm denotes the unit m-vector with a single
one in the `th coordinate, so that Xi is zero everywhere except at position
[a(i), b(i)]. With this choice, we have trace(XTi
M) = ma(i) b(i), so that the
observation model (7.26) provides us with certain entries of M—those in the
training set 
—each contaminated with noise "i. Our goal is to predict the unobserved
entries in Z via cM, which can be thought of as E(y|X) for feature
values X that are distinct from those in the training set.
The trace observation model (7.26) is also relevant in a more general setting,
since with different choices of the covariate matrices {Xi}, it can also be
used to model other types of matrix estimation problems involving low-rank
constraints.
The multiresponse regression model of the previous section is another
example. The response and covariate vectors are linked via the equation
yi = T xi + i, where  2 Rp×K is a matrix of regression coefficients, and
i 2 RK is a noise vector. Since each response yi is a K-vector of observations,
it can be rewritten as a collection of K separate observations in the trace
form: if we set Xij = xieKj
T where eKj
2 RK is the unit vector with a single
one in the jth position, then the jth component of yi can be expressed in the
form yij = trace(XT
ij) + ij .
In the context of multivariate regression, the matrix lasso takes the form
minimize

8<
:
1
2N
XN
i=1
XK
j=1
􀀀
yij − trace(XT
ij)
2 + kk?
9=
;. (7.27)
Exercise 7.9 explores another example. See the papers by Yuan, Ekici, Lu
and Monteiro (2007), Negahban and Wainwright (2011a), and Rohde and
Tsybakov (2011) for further details and benefits of this unified approach. See
PENALIZED MATRIX DECOMPOSITION 187
also Bunea, She and Wegkamp (2011) for analysis of an alternative procedure
for reduced-rank multivariate regression.
7.6 Penalized Matrix Decomposition
Maximum-margin matrix factorization methods lead naturally to other forms
of regularization such as the `1-penalized version
minimize
U2R
m×r, V2R
n×r
D2R
r×r

kZ − UDVT k2
F + 1kUk1 + 2kVk1
	
, (7.28)
where D is diagonal and nonnegative. Here we assume that all values of Z are
observed, and apply an `1 penalty to the left and right singular vectors of the
decomposition. The idea is to obtain sparse versions of the singular vectors
for interpretability.
Before discussing how to optimize the criterion (7.28), let’s see how it
can be used. Returning to the Netflix example, we created a smaller matrix
consisting of the 1000 users and the 100 movies, each with the most ratings.
We imputed the missing values using an iterated rank 10 SVD (Section 7.3).
Then we set the rank of U and V to two, and minimized a version of the
criterion (7.28) for values of 1 and 2 that yielded a very sparse solution.
The resulting solution bV had 12 nonzero entries, all with the same sign, corresponding
to the movies in Table 7.3. The first group looks like a mixture
Table 7.3 Movies with nonzero loadings, from a two-dimensional penalized matrix
decomposition.
First Component Second Component
The Wedding Planner Lord of the Rings: The Fellowship of the Ring
Gone in 60 Seconds The Last Samurai
The Fast and the Furious Lord of the Rings: The Two Towers
Pearl Harbor Gladiator
Maid in Manhattan Lord of the Rings: The Return of the King
Two Weeks Notice
How to Lose a Guy in 10 Days
of romantic comedies and action movies, while the second group consists of
historical action/fantasy movies.
How do we solve the optimization problem (7.28)? Let us first consider
the one-dimensional case, written in the constrained rather than Lagrangian
form:
minimize
u2R
m, v2R
n
d0
kZ − duvT k2
F subject to kuk1  c1 and kvk1  c2. (7.29)
188 MATRIX DECOMPOSITIONS
It turns out that the estimator (7.29) is not very useful, as it tends to produce
solutions that are too sparse, as illustrated in Figure 7.10 (right panel). In
order to fix this problem, we augment our formulation with additional `2-
norm constraints, thereby obtaining the optimization problem
minimize
u2R
m, v2R
n
d0
kZ − duvT k2
F subject to kuk1  c1, kvk1  c2, kuk2  1, kvk2  1.
(7.30)
It may seem surprising that adding constraints can make the solution sparse,
but Figure 7.10 provides some insight.
−1.5 −0.5 0.5 1.0 1.5
−1.5 −0.5 0.5 1.0 1.5
−1.5 −0.5 0.5 1.0 1.5
−1.5 −0.5 0.5 1.0 1.5
u1 u1
u2
u2
Figure 7.10 A graphical representation of the `1 and `2 constraints on u 2 R2 in
the PMD(`1, `1) criterion. The constraints are as follows: kuk22
 1 and kuk1  c.
The gray lines indicate the coordinate axes u1 and u2. Left panel: The `2 constraint
is the solid circle. For both the `1 and `2 constraints to be active, the constraint
radius c must be between 1 and p2. The constraints kuk1 = 1 and kuk1 = p2 are
shown using dashed lines. Right panel: The `2 and `1 constraints on u are shown
for some c between 1 and p2. Red dots indicate the points where both the `1 and
the `2 constraints are active. The red contour shows the boundary of the constraint
region. The black lines are the linear contours of the criterion (7.30) as a function
of u, which increase as we move to the upper right in this example. The solid red
arcs indicate the solutions that occur when 1 = 0 in Algorithm 7.2 (`2 active, `1
not). The figure shows that in two dimensions, the points where both the `1 and `2
constraints are active have neither u1 nor u2 equal to zero. We also see that without
the `2 constraints, we would always end up at a corner; this would lead to trivial
solutions.
If we fix the second component v, the criterion (7.30) is linear in u. Suppose
that the linear contour of the criterion is angled as in Figure 7.10 and not
exactly parallel to a side of the polyhedral constraint region. Then to solve
the problem, we move the linear contour toward the top right as far as possible
while still remaining inside the constraint region. The solution occurs at one
PENALIZED MATRIX DECOMPOSITION 189
of the open circles, or on the solid red contour. Notice that without the `2
constraint, the solution will occur at a corner of the polyhedron where only one
coefficient is nonzero. As shown in the left panel of Figure 7.10, the problem
is well defined as long as 1  c1  pm and 1  c2  pn.
Since the criterion (7.30) is biconvex, we can minimize it in an alternating
fashion. It is easy to verify that the solution in each direction is a softthresholding
operation. For example, the update for v 2 Rn takes the form
u   S1
􀀀
Zv

kS1
􀀀
Zv

k2
. (7.31)
Here we apply our soft-thresholding operator S element-wise on its vector
Algorithm 7.2 Alternating soft-thresholding for rank-one penalized
matrix decomposition.
1. Set v to the top left singular vector from the SVD of Z.
2. Perform the update u  
S1
􀀀
Zv

kS1
􀀀
Zv

k2
, with 1 being the smallest value such
that kuk1  c1;
3. Perform the update v  
S2
􀀀
ZT u

kS2
􀀀
ZT u

k2
, with 2 being the smallest value
such that kvk1  c2;
4. Iterate steps 2 and 3 until convergence.
5. Return u, v and d = uTZv.
argument. The threshold 1 in Equation (7.31) must be chosen adaptively
to satisfy the constraints: it is set to zero if this results in kuk1  c1, and
otherwise 1 is chosen to be a positive constant such that kuk1 = c1. (See
Exercise 7.7). The overall procedure is summarized in Algorithm 7.2. We note
that if c1 > pm and c2 > pn so that the `1 constraints have no effect,
then Algorithm 7.2 reduces to the power method for computing the largest
singular vectors of the matrix Z. See Section 5.9 for further discussion of
the (ordinary) power method. Some recent work has established theoretical
guarantees for iterative soft thresholding updates related to Algorithm 7.2;
see the bibliographic section for further details.
The criterion (7.30) is quite useful and may be used with other penalties
(in addition to the `1-norm) for either u or v, such as the fused lasso penalty
(u) =
Xm
j=2 |uj − uj−1|, (7.32)
where u = (u1, u2, . . . um). This choice is useful for enforcing smoothness along
a one-dimensional ordering j = 1, 2, . . .m, such as chromosomal position in
190 MATRIX DECOMPOSITIONS
a genomics application. Depending on this choice of penalty, the corresponding
minimization in Algorithm 7.2 must change accordingly. In addition, one
can modify Algorithm 7.2 to handle missing matrix entries, for example by
omitting missing values when computing the inner products Zv and ZTu.
To obtain a multifactor penalized matrix decomposition, we apply the
rank-one Algorithm (7.2) successively to the matrix Z, as given in Algorithm
7.3. If `1 penalties on uk and vk are not imposed—equivalently, if we
Algorithm 7.3 Multifactor penalized matrix decomposition
1. Let R   Z.
2. For k = 1, . . .K:
(a) Find uk, vk, and dk by applying the single-factor Algorithm 7.2 to
data R.
(b) Update R   R − dkukvT
k .
set 1 = 2 = 0 in Algorithm 7.2—then it can be shown that the K-factor
PMD algorithm leads to the rank-K SVD of Z. In particular, the successive
solutions are orthogonal. With penalties present, the solutions are no longer
in the column and row spaces of Z, and so the orthogonality does not hold.
It is important to note the difference between sparse matrix decomposition
and matrix completion, discussed earlier. For successful matrix completion, we
required that the singular vectors of Z have low coherence; that is, they need
to be dense. In sparse matrix decomposition, we seek sparse singular vectors,
for interpretability. Matrix completion is not the primary goal in this case.
Unlike the minimization of convex functions, alternating minimization of
biconvex functions is not guaranteed to find a global optimum. In special cases,
such as the power method for computing the largest singular vector, one can
show that the algorithm converges to a desired solution, as long as the starting
vector is not orthogonal to this solution. But in general, these procedures
are only guaranteed to move downhill to a partial local minimum of the function;
see Section 5.9 for discussion of this issue. Based on our experience,
however, they behave quite well in practice, and some recent theoretical work
provides rigorous justification of this behavior. See the bibliographic section
for discussion.
Lee, Shen, Huang and Marron (2010) suggest the use of the penalized matrix
decomposition for biclustering of two-way data. In Chapter 8 we describe
applications of the penalized matrix decomposition to derive penalized multivariate
methods such as sparse versions of principal components, canonical
correlation, and clustering.
7.7 Additive Matrix Decomposition
In the problem of additive matrix decomposition, we seek to decompose a
matrix into the sum of two or more matrices. The components in this additive
ADDITIVE MATRIX DECOMPOSITION 191
composition should have complementary structures; for instance, one of the
most widely studied cases involves decomposing into the sum of a low-rank
matrix with a sparse matrix (see also Section 9.5). Additive matrix decompositions
arise in a wide variety of applications, among them factor analysis, robust
forms of PCA and matrix completion, and multivariate regression problems,
as discussed below.
Most of these applications can be described in terms of the noisy linear
observation model Z = L + S + W, where the pair (L, S) specify the
additive matrix decomposition into low rank and sparse components, and W
is a noise matrix. In certain cases, we consider a slight generalization of this
model, in which we observe a noisy version of X(L + S), where X is some
type of linear operator on the matrix sum (e.g., the projection operator P

in the case of matrix completion, or multiplication via the model matrix X in
the case of matrix regression.
Given such observations, we consider estimators of the pair (L, S) based
on the criterion
minimize
L2R
m×n
S2R
m×n
1
2kZ − (L + S)k2
F + 11(L) + 22(S)

, (7.33)
where 1 and 2 are penalty functions each designed to enforce a different
type of generalized sparsity. For instance, in the case of low rank and sparse
matrices, we study the choices 1(L) = kLk? and 2(S) = kSk1.
We now turn to some applications of additive matrix decompositions.
Factor Analysis with Sparse Noise: Factor analysis is a widely used form of
linear dimensionality reduction that generalizes principal component analysis.
Factor analysis is easy to understand as a generative model: we generate
random vectors yi 2 Rp using the “noisy subspace” model
yi = μ + 􀀀ui + wi, for i = 1, 2, . . . ,N. (7.34)
Here μ 2 Rp is a mean vector, 􀀀 2 Rp×r is a loading matrix, and the random
vectors ui  N(0, Ir×r) and wi  N(0, S) are independent. Each vector yi
drawn from model (7.34) is obtained by generating a random element in the
r-dimensional subspace spanned by the columns of 􀀀. Given N samples from
this model, the goal is to estimate the column of the loading matrix 􀀀, or
equivalently, the rank r matrix L = 􀀀􀀀T 2 Rp×p that spans the column
space of 􀀀.
A simple calculation shows that the covariance matrix of yi has the form
 = 􀀀􀀀T + S. Consequently, in the special case when S = 2Ip×p, then
the column span of 􀀀 is equivalent to the span of the top r eigenvectors of
, and so we can recover it via standard principal components analysis. In
particular, one way to do so is by computing the SVD of the data matrix
Y 2 RN×p, as discussed in Section 7.2. The right singular vectors of Y specify
the eigenvectors of the sample covariance matrix, which is a consistent
estimate of .
192 MATRIX DECOMPOSITIONS
What if the covariance matrix S is not a multiple of the identity? A
typical assumption in factor analysis is that S is diagonal, but with the noise
variance depending on the component of the data. More generally, it might
have nonzero entries off the diagonal as well, but perhaps a relatively small
number, so that it could be represented as a sparse matrix. In such settings,
we no longer have any guarantees that the top r eigenvectors of  are close to
the column span of 􀀀. When this is not the case, PCA will be inconsistent—
meaning that it will fail to recover the true column span even if we have an
infinite sample size.
Nonetheless, when S is a sparse matrix, the problem of estimating
L = 􀀀􀀀T can be understood as an instance of our general observation model
with p = N. In particular, given our observations {yi}N
i=1, we can let our
observation matrix Z 2 Rp×p be the sample covariance matrix 1
N
PN
i−1 yiyT
i .
With this algebra, we can then write Z = L+S+W, where L = 􀀀􀀀T is of
rank r, and the random matrix W is a re-centered form of Wishart noise—in
particular, the zero-mean matrix W:= 1
N
PN
i=1 yiyT
i −

L + S
	
.
Robust PCA: As discussed in Section 7.2, standard principal component
analysis is based on performing an SVD of a (column centered) data matrix
Z 2 RN×p, where row i represents the ith sample of a p-dimensional data
vector. As shown there, the rank-r SVD can be obtained by minimizing the
squared Frobenius norm kZ − Lk2
F subject to a rank constraint on L. What
if some entries of the data matrix Z are corrupted? Or even worse, what if
some subset of the rows (data vectors) are corrupted? Since PCA is based
on a quadratic objective function, its solution (the rank r SVD) can be very
sensitive to these types of perturbations.
Additive matrix decompositions provide one way in which to introduce
some robustness to PCA. In particular, instead of approximating Z with a
low-rank matrix, we might approximate it with the sum L + S of a lowrank
matrix with a sparse component to model the corrupted variables. In
the case of element-wise corruption, the component S would be modeled as
element-wise sparse, having relatively few nonzero entries, whereas in the more
challenging setting of having entirely corrupted rows, it would be modeled as
a row-sparse matrix. Given some target rank r and sparsity k, the direct
approach would be to try and solve the optimization problem
minimize
rank(L)r
card(S)k
1
2kZ − (L + S)k2
F. (7.35)
Here card denotes a cardinality constraint, either the total number of nonzero
entries (in the case of element-wise corruption), or the total number of nonzero
rows (in the case of row-wise corruption). Of course, the criterion (7.35) is
doubly nonconvex, due to both the rank and cardinality constraints, but a
natural convex relaxation is provided by our general estimator (7.33) with
1(L) = kLk? and 2(S) = P
i,j |sij | for element-wise sparsity.
Figure 7.11 shows an example of robust PCA with the above penalties,
ADDITIVE MATRIX DECOMPOSITION 193
taken from an unpublished paper by Mazumder and Hastie and using images
from Li, Huang, Gu and Tian (2004). The columns of the data matrix Z are
frames from a video surveillance camera, and are noisy and have missing pixel
values (next section). The last two columns show the reconstructed frames; the
low-rank part represents the static background, while the sparse component
changes in each frame, and in this case represent people moving.
True Image Training Image Low-Rank (bL) Sparse (bS)
Figure 7.11 Video surveillance. Shown are the true image, noisy training image
with missing-values, the estimated low-rank part, and the sparse part aligned side by
side. The true images were sampled from the sequence and include ones with varying
illumination and some benchmark test sequences. Despite the missingness and added
noise the procedure succeeds in separating the moving components (people) from the
fixed background.
Robust Matrix Completion: Robustness is also a concern for matrix-completion
methods (Section 7.3), which are used in collaborative filtering and
recommender systems. Ratings may be corrupted for various reasons: for instance,
users might try to “game” the system (e.g., a movie star would like to
have his/her movies more highly recommended by Netflix). Alternatively, a
subset of users might simply be playing pranks with their ratings; for instance,
in 2002, The New York Times reported how the Amazon system had been manipulated
by adversarial users, so that it would recommend a sex manual to
users who expressed interest in Christian literature (Olsen 2002).
As we did for robust PCA, we can build in robustness to matrix completion
by introducing a sparse component S to our representation. The nature
of sparsity depends on how we model the adversarial behavior: if we believed
that only a small fraction of entries were corrupted, then it would be appropriate
to impose element-wise sparsity via the `1-norm. On the other hand,
if we wished to model users (rows) as being adversarial, then it would be ap194
MATRIX DECOMPOSITIONS
propriate to impose a row-wise sparsity penalty, such as the group lasso norm
kSk1,2 = Pm
i=1 kSik2, where Si 2 Rn denotes the ith row of the matrix. This
choice would lead to the following modification of our earlier estimator (7.10):
minimize
L,S2Rm×n
8<
:
1
2
X
(i,j)2

(zij − (Lij + Sij))2 + 1kLk? + 2
Xm
i=1 kSik2
9=
;. (7.36)
Exercise 7.10 shows an equivalence between this criterion and a nuclear-norm
regularized robust Huber loss. Hence one can develop an algorithm along the
lines of Soft-Impute in Section 7.1, replacing the squared-error loss with
the Huber loss. Figure 7.11 shows the results of this approach on some videosurveillance
data.
Multivariate Regression: Recall the multivariate linear regression model
yi = T xi + i, where  2 Rp×K is a matrix of regression coefficients used to
predict the multivariate response vector y 2 RK. As discussed in Section 7.5,
in one application of matrix regression, each column of the response matrix
Y represents a vectorized image, so that the full matrix represents a video
sequence consisting of K frames. The model matrix X represents p image
basis functions, one per column; for example, an orthonormal basis of twodimensional
wavelets, at different scales and locations (see Section 10.2.3).
Figure 7.8 showed that for certain types of video sequences, the matrix Y
exhibits rapid decay in its singular values, and so can be well-approximated
by a low-rank matrix.
In a more realistic setting, a video sequence consists of both a background,
and various types of foreground elements. The background component is often
slowly varying, so that the low-rank model is appropriate, whereas foreground
elements vary more rapidly, and may disappear and reappear. (The
“helicopter” sequence in Figure 7.8 can be viewed as pure background.) Consequently,
a more realistic model for the video sequence is based on decomposition
 = L + S, where L is low-rank, and S is a relatively sparse matrix.
Active entries of S correspond to the basis functions (rows) and time positions
(columns) for representing the foreground elements that play a role in
the video.
Of course, these types of decompositions also arise in other applications of
multivariate regression. In the general setting, we try to recover the decomposition
using the estimator
minimize
L,S
8<
:
1
2N
XN
i=1
XK
j=1
􀀀
yij − trace(XT
ij(L + S))
2 + 1kLk? + 2kSk1
9=
;
(7.37)
where Xij = xieKj
T for i = 1, . . . ,N and j = 1, . . . ,K. Note that this is a natural
generalization of our earlier estimator (7.27) for nuclear-norm regularized
multivariate regression.
BIBLIOGRAPHIC NOTES 195
Bibliographic Notes
Early work by Fazel (2002) studied the use of the nuclear norm as a surrogate
for a rank constraint. Srebro, Alon and Jaakkola (2005) studied the
nuclear norm as well as related relaxations of rank constraints in the context
of matrix completion and collaborative filtering. Bach (2008) derived some
asymptotic theory for consistency of nuclear norm regularization. Recht, Fazel
and Parrilo (2010) derived nonasymptotic bounds on the performance of nuclear
norm relaxation in the compressed sensing observation model. See also
the papers Negahban and Wainwright (2011a), Rohde and Tsybakov (2011)
for nonasymptotic analysis of the nuclear norm relaxation for more general
observation models.
Maximum margin matrix factorization is discussed in Srebro and Jaakkola
(2003), Srebro, Alon and Jaakkola (2005), and Srebro, Rennie and Jaakkola
(2005). Spectral regularization and the Soft-Impute algorithm were developed
by Mazumder et al. (2010). The penalized matrix decomposition is described
in Witten, Tibshirani and Hastie (2009). Matrix completion using
the nuclear norm has been studied by various authors, with initial results on
prediction-error bounds by Srebro, Alon and Jaakkola (2005). The first theoretical
results on exact recovery with noiseless observations for exactly lowrank
matrices were established by Cand`es and Recht (2009), with subsequent
refinements by various authors. Gross (2011) developed a general dual-witness
scheme for proving exactness of nuclear norm relaxations given noiseless observations
in arbitrary bases, generalizing the case of entry-wise sampling; see
also Recht (2011) for related arguments. Keshavan et al. (2009) provide exact
recovery guarantees for a slightly different two-stage procedure, involving
trimming certain rows and columns of the matrix and then applying the SVD.
The more realistic noisy observation model has also been studied by various
authors (e.g., Cand`es and Plan (2010), Negahban and Wainwright (2012),
Keshavan et al. (2010)).
The problem of additive matrix decomposition was first considered
by Chandrasekaran, Sanghavi, Parrilo and Willsky (2011) in the noiseless
setting, who derived worst-case incoherence conditions sufficient for exact recovery
of an arbitrary low-rank/sparse pair. Subsequent work by Cand`es, Li,
Ma and Wright (2011) studied the case of random sparse perturbations to
the low-rank matrix, with applications to robust PCA. Xu, Caramanis and
Sanghavi (2012) proposed an alternative approach to robust PCA, based on
modeling the corruptions in terms of a row-sparse matrix. Chandrasekaran,
Parrilo and Willsky (2012) developed the use of sparse/low-rank decompositions
for the problem of latent Gaussian graphical model selection. In the more
general noisy setting, Hsu, Kakade and Zhang (2011) and Agarwal, Negahban
and Wainwright (2012b) provide bounds on relatives of the estimator (7.33).
A recent line of work has provide some theory for alternating minimization
algorithms in application to particular nonconvex problems, including
matrix completion (Netrapalli, Jain and Sanghavi 2013), phase re196
MATRIX DECOMPOSITIONS
trieval (Netrapalli et al. 2013), mixtures of regression (Yi, Caramanis and
Sanghavi 2014), and dictionary learning (Agarwal, Anandkumar, Jain, Netrapalli
and Tandon 2014). These papers show that given suitable initializations,
alternating minimization schemes do converge (with high probability)
to estimates with similar statistical accuracy to a global minimum. Similarly,
there are also theoretical guarantees for variants of the power method
with soft thresholding for recovering sparse eigenvectors (Ma 2013, Yuan and
Zhang 2013).
Exercises
Ex. 7.1 Recall the singular value decomposition (7.2) of a matrix.
(a) Show that the SVD of the column-centered matrix Z gives the principal
components of Z.
(b) Show that the condition that successive PCs are uncorrelated is equivalent
to the condition that the vectors {vj} are orthogonal. What is the
relationship between the vectors {sj} in Section 7.2 and the components of
the SVD?
Ex. 7.2 In this exercise, we work through the proof of assertion (7.3), namely
that
bZr = arg min
rank(M)=r kZ −Mk2
F,
where bZr = UDrVT is the SVD truncated to its top r components. (In detail,
the SVD is given by Z = UDVT , and Dr is the same as D except all but the
first r diagonal elements are set to zero.) Here we assume that m  n and
rank(Z) = m.
We begin by noting that any rank r matrixMcan be factored asM = QA,
where Q 2 Rm×r is an orthogonal matrix, and A 2 Rr×n.
(a) Show that given Q, the optimal value for A is given by QTZ.
(b) Using part (a), show that minimizing kZ −Mk2
F is equivalent to solving
maximize
Q2R
m×r
trace(QTQ) subject to QTQ = Ir, (7.38)
where  = ZZT .
(c) Show that this is equivalent to the problem
maximize
Q2Rm×r
trace(QTD2Q) subject to QTQ = Ir. (7.39)
(d) Given an orthonormal matrix Q 2 Rm×r, define H = QQT with diagonal
elements hii for i = 1, . . . ,m. Show that hii 2 [0, 1] and that Pm
i=1 hii = r.
Conclude that problem (7.39) is equivalent to
maximize
Phii2[0,1] m
i=1 hii=r
Xm
i=1
hii d2i
. (7.40)
EXERCISES 197
(e) Assuming that d21
 d22
 . . . d2
m  0, show that the solution to problem
(7.40) is obtained by setting h11 = h22 = . . . = hrr = 1, and setting
the remaining coefficients zero. If the {d2i
} are strictly ordered, show that
this solution is unique.
(f) Conclude that an optimal choice for Q in problem (7.38) is U1, the matrix
formed from the first r columns of U. This completes the proof.
Ex. 7.3
(a) `1 norm as an LP: For any vector  2 Rp, show that
kk1 = max
u2Rp
Xp
j=1
ujj subject to kuk1  1. (7.41)
This relation expresses the fact that the `1 norm is dual to the `1 norm.
(b) Nuclear norm as an SDP: For any matrix B 2 Rm×n, show that
kBk? = max
U2Rm×n
trace(UTB) subject to kUkop  1,
where kUkop is the maximum singular value of the matrix U, a quantity
known as the spectral norm or `2 operator norm. This relation expresses
the fact that the spectral norm is dual to the nuclear norm. (Hint: use the
SVD of Z and cyclical properties of trace operator in order to reduce this
to an instance of part (a).)
(c) Given a matrix U 2 Rm×n, show that the inequality kUkop  1 is equivalent
to the constraint 
Im U
UT In

 0. (7.42)
Since this constraint is a linear matrix inequality, it shows nuclear norm
minimization can be formulated as an SDP. (Hint: The Schur-complement
formula might be useful.)
Ex. 7.4 Subgradients of the nuclear norm: Subgradients, as previously defined
in Section 5.2, extend the notion of a gradient to nondifferentiable functions.
(a) Given a matrix A 2 Rm×n with rank r  min(m, n), write its singular
value decomposition as A = UDVT . With this notation, show that the
subgradient of the nuclear norm is
@kAk? =

UVT +W | UTW= WV = 0, kWkop  1
	
. (7.43)
(b) Use part (a) to show that a fixed point of the Soft-Impute procedure
(7.1) satisfies the subgradient equation of the criterion (7.10).
Ex. 7.5 From Chapter 5, recall our description (5.21) of Nesterov’s generalized
gradient procedure. Show that the Soft-Impute procedure (7.1) corresponds
to this algorithm applied to the criterion (7.10).
198 MATRIX DECOMPOSITIONS
Ex. 7.6 Construct a solution to the maximum-margin problem (7.21), in the
case rank(M) = r  min(m, n), of the form cM = bAm×r bBTr
×n. Show that this
solution is not unique. Suppose we restrict A and B to have r0 > r columns.
Show how solutions of this enlarged problem might not reveal the rank of M.
Ex. 7.7 Consider the convex optimization problem
maximize
u2Rp
uTZv subject to kuk2  1 and kuk1  c. (7.44)
Show that the solution is given by
u = S
􀀀
Zv

kS
􀀀
Zv

k2
, (7.45)
where   0 is the smallest positive value such that kuk1  c.
Ex. 7.8 In this exercise, we demonstrate that, in the context of exact completion
of a n × n matrix M from noiseless entries, it is necessary to observe
at least N > n log n entries, even for a rank one matrix. We begin by noting
that if we fail to observe any entries from some row (or column) of M, then it
is impossible to recover M exactly (even if we restrict to incoherent matrices
with rank one). We let F be the event that there exists some row with no observed
entries, under the sampling model in which we choose N entries from
the matrix uniformly at random with replacement.
(a) For each row j = 1, . . . , p, let Zj be a binary indicator variable for the
event that no entries of j are observed, and define Z = Pn
j=1 Zj . Show that
P[F] = P[Z > 0] 
􀀀
E[Z]
2
E[Z2] .
(Hint: The Cauchy–Schwarz inequality could be useful.)
(b) Show that E[Z] = n(1 − 1/n)N.
(c) Show that E[ZiZj ]  E[Zi]E[Zj ] for i 6= j.
(d) Use parts (b) and (c) so show that E[Z2]  n(1−1/n)N +n2(1−1/n)2N.
(e) Use the previous parts to show that P[F] stays bounded away from zero
unless N > n log n.
Ex. 7.9 Quadratic polynomial regression in high dimensions is dangerous, because
the number of parameters is proportional to the square of the dimension.
Show how to represent this problem as a matrix regression (Section 7.5), and
hence suggest how the parameter explosion can be controlled.
Ex. 7.10 . In Exercise 2.11 of Chapter 2, we show that a regression model that
allows for a sparse perturbation of each prediction is equivalent to a robust
EXERCISES 199
regression using Huber’s  function. Here we establish an analogous result for
robust PCA.
Recall the sparse plus low-rank version of PCA:
minimize
L,S
1
2kZ − (L + S)k2
F + 1kLk? + 2kSk1. (7.46)
Now consider a robustified version of PCA
minimize
L
1
2
XN
i=1
Xp
j=1
 (zij − `ij ; 2) + 1kLk?, (7.47)
where
(t; ) =
(
|t| − 2/2 if |t| > 
t2/2 if |t|  .
(7.48)
is Huber’s loss function. Show that problem (7.47) has the same solution for
L as does problem (7.46).

Chapter 8
Sparse Multivariate Methods
8.1 Introduction
In this chapter, we discuss some popular methods for multivariate analysis
and explore how they can be “sparsified”: that is, how the set of features can
be reduced to a smaller set to yield more interpretable solutions. Many standard
multivariate methods are derived from the singular value decomposition
of an appropriate data matrix. Hence, one systematic approach to sparse multivariate
analysis is through a sparse decomposition of the same data matrix.
The penalized matrix decomposition of Section 7.6 is well-suited to this task,
as it delivers sparse versions of the left and/or right singular vectors.
For example, suppose that we have a data matrix X of dimension N×p, and
assume that the columns each have mean zero. Then the principal components
of X are derived from its singular value decomposition (SVD) X = UDVT :
the columns of V are the principal component direction vectors (in order), and
the columns of U are the standardized principal components. Hence we can
derive sparse principal components by applying instead the penalized matrix
decomposition to X, with sparsity enforced on the right vectors. In a similar
way, many multivariate methods can be derived by appropriate application
of the penalized matrix decomposition. These methods are summarized in
Table 8.1.
Table 8.1 The penalized matrix decomposition of Section 7.6 applied
to appropriate input matrices leads to sparse versions of classical multivariate
methods.
Input Matrix Result
Data matrix sparse SVD and principal components
Variance-covariance sparse principal components
Cross-products sparse canonical variates
Dissimilarity sparse clustering
Between-class covariance sparse linear discriminants
201
202 SPARSE MULTIVARIATE METHODS
−3 −2 −1 0 1 2 3
−3 −2 −1 0 1 2 3
x1
x2
v1
zi1
xi
Figure 8.1 A two-dimensional illustration of principal components analysis, showing
the first principal component v1 2 R2 of a collection of data points xi = (xi1, xi2),
shown in green circles. Letting ¯x = (¯x1, ¯x2)T denote the sample mean, the line
¯x + T v1 maximizes the variance of the projected points along the line, and minimizes
the total squared distance from each point to its orthogonal projection onto
the line. Here zi1 = ui1d1 is the scalar valued representation of observation xi in the
first principal component z1.
8.2 Sparse Principal Components Analysis
We begin our exploration with the problem of sparse principal component
analysis, which is a natural extension of PCA well-suited to high-dimensional
data. To set the stage, we first review principal components.
8.2.1 Some Background
Given a data matrix X of dimension N × p, consisting of N vectors
{x1, . . . , xN} in Rp, principal component analysis provides a sequence of linear
approximations, indexed by a rank r  min{p,N}.
There are two different but equivalent ways of viewing and deriving principal
components. The first approach is based on the directions of maximal
variance. Any unit-norm vector  2 Rp leads to a one-dimensional projection
of the data, namely the N-vector X.1 Assuming that the columns of X have
been centered, the sample variance of the projected data vector is given by
1In this chapter we deal with multivariate methods applied to a data matrix X 2 RN×p;
we hence adhere to our convention of representing N-vectors and all matrices in boldface,
and p-vectors in plain text.
SPARSE PRINCIPAL COMPONENTS ANALYSIS 203
dVar(X) = 1
N
PN
i=1(xTi
)2. Principal components analysis finds the direction
that maximizes the sample variance
v1 = arg max
kk2=1
n
dVar(X)
o
= arg max
kk2=1

T XTX
N


. (8.1)
Hence the first principal component direction corresponds to the largest eigenvalue
of the sample covariance XTX/N, which provides the link to the notion
of maximal variance at the population level. See Exercise 8.1 for further details.
Figure 8.1 illustrates the geometry of this optimization problem. The
resulting projection z1 = Xv1 is called the first principal component of the
data X, and the elements of v1 are called the principal component loadings.
The vector v1 is easily seen to be the right singular vector corresponding
to the largest singular value d1 of X. Similarly z1 = u1d1, where u1 is the
corresponding left singular vector.
Subsequent principal-component directions (eigen-vectors) v2, v3, . . . , vp
correspond to maxima ofdVar(Xvj) subject to kvjk2 = 1 and vj orthogonal to
v1, . . . vj−1. This property also implies that the zj are mutually uncorrelated
(see Exercise 8.2). In fact, after r steps of this procedure, we obtain a rank r
matrix that solves the optimization problem
Vr = arg max
A: ATA=Ir
trace(ATXTXA) (8.2)
See Exercise 7.2 for further details on this property. Thus, even though they
are defined sequentially, the collection of loading vectors in Vr also maximize
the total variance among all such collections.
A second derivation of principal components is based on minimizing the
reconstruction error associated with a particular generative model for the
data. Suppose that the rows of the data matrix can be modeled as xi  f(i),
where the function
f() = μ + Ar (8.3)
parametrizes an affine set of dimension r. Here μ 2 Rp is a location vector,
Ar 2 Rp×r is a matrix with orthonormal columns corresponding to directions,
and  2 Rr is a parameter vector that varies over samples. It is natural to
choose the parameters {μ,Ar, {i}N
i=1} to minimize the average reconstruction
error
1
N
XN
i=1 kxi − μ − Arik22
. (8.4)
This interpretation of PCA is illustrated in Figure 8.1. As we explore in Exercise
8.3, when the data has been precentered (so that we may take μ = 0),
the criterion (8.4) can be reduced to
1
N
XN
i=1 kxi − ArATr
xik22
, (8.5)
204 SPARSE MULTIVARIATE METHODS
and the value of Ar that minimizes the reconstruction error (8.5) can again
be obtained from the singular value decomposition of the data matrix. In
operational terms, we compute the SVD X = UDVT , and then form ˆAr = Vr
by taking the r columns of V corresponding to the top r singular values. The
estimates for i are given by the rows of Zr = UrDr. So maximizing total
variance within the affine surface corresponds to minimizing total distance
from the surface. Again we observe that the successive solutions are nested;
this property is special, and is not necessarily inherited by the generalizations
that we discuss in this chapter.
8.2.2 Sparse Principal Components
We often interpret principal components by examining the loading vectors
{vj}rj
=1 so as to determine which of the variables play a significant role. In
this section, we discuss some methods for deriving principal components with
sparse loadings. Such sparse principal components are especially useful when
the number of variables p is large relative to the sample size. With a large
number of variables, it is often desirable to select a smaller subset of relevant
variables, as revealed by the loadings. At the theoretical level, in the p  N regime, ordinary PCA is known to break down very badly, in that the
eigenvectors of the sample covariance need not be close to the population
eigenvectors (Johnstone 2001). Imposing sparsity on the principal components
makes the problem well-posed in the “large p, small N” regime. In this section,
we discuss a number of methods for obtaining sparse principal components,
all based on lasso-type (`1) penalties. As with ordinary PCA, we start with an
N ×p data matrix X with centered columns. The proposed methods focus on
either the maximum variance property of principal components, or minimum
reconstruction error. For ease of exposition, we begin by discussing the rankone
case for each method, deferring the case of higher ranks until Section 8.2.3.
8.2.2.1 Sparsity from Maximum Variance
We begin by discussing how the maximum variance characterization of PCA
can be modified to incorporate sparsity. The most natural modification would
be to impose an `0-restriction on the criterion, leading to the problem
maximize
kvk2=1

vTXTXv
	
subject to kvk0  t, (8.6)
where kvk0 = Pp
j=1 I[vj 6= 0] simply counts the number of nonzeros in the vector
v. However, this problem is doubly nonconvex, since it involves maximizing
(as opposed to minimizing) a convex function with a combinatorial constraint.
The SCoTLASS procedure of Jolliffe, Trendafilov and Uddin (2003) is a natural
relaxation of this objective, based on replacing the `0-norm by the `1-norm,
leading to
maximize
kvk2=1

vTXTXv
	
subject to kvk1  t. (8.7)
SPARSE PRINCIPAL COMPONENTS ANALYSIS 205
The `1-constraint encourages some of the loadings to be zero and hence v
to be sparse. Although the `1-norm is convex, the overall problem remains
nonconvex, and moreover is not well-suited to simple iterative algorithms.
There are multiple ways to address these challenges. One approach draws
on the SVD version of principal components; we re-express the problem, leaving
it nonconvex but leading to a computationally efficient algorithm for finding
local optima. Recall the penalized matrix criterion (7.28) on page 187;
applying it with no constraint on u—that is, with c1 = 1—leads to the
optimization problem
maximize
kuk2=kvk2=1

uTXv
	
subject to kvk1  t. (8.8)
Any optimal solution bv to this problem is also optimal for the original SCoTLASS
program (8.7). The advantage of this reformulation is that the objective
function (8.8) is biconvex in the pair (u, v), so that we can apply alternating
minimization to solve it—in particular, recall Algorithm 7.2 in Chapter 7 for
the penalized matrix decomposition. Doing so leads to Algorithm 8.1, which
consists of the following steps:
Algorithm 8.1 Alternating algorithm for rank one sparse PCA.
1. Initialize v 2 Rp with kvk2 = 1.
2. Repeat until changes in u and v are sufficiently small:
(a) Update u 2 RN via u   Xv
kXvk2 .
(b) Update v 2 Rp via
v   v(, u) = S(XTu)
kS(XTu)k2
, (8.9)
where  = 0 if kXTuk1  t, and otherwise  > 0 is chosen such that
kv(, u)k1 = t.
Here S(x) = sign(x) (|x| − )+ is the familiar soft-thresholding operator
at level . In Exercise 8.6, we show that any fixed point of this algorithm represents
a local optimum of the criterion (8.7), and moreover, that the updates
can be interpreted as a minorization-maximization, or simply a minorization
algorithm for the objective function (8.7).
An alternative approach, taken by d’Aspremont, El Ghaoui, Jordan and
Lanckriet (2007), is to further relax the SCoTLASS objective to a convex
program, in particular by lifting it to a linear optimization problem over the
space of positive semidefinite matrices. Such optimization problems are known
as semidefinite programs. In order to understand this method, let us begin
with an exact reformulation of the nonconvex objective function (8.7). By the
properties of the matrix trace, we can rewrite the quadratic form vTXTXv in
206 SPARSE MULTIVARIATE METHODS
terms of a trace operation—specifically
vTXTXv = trace(XTXvvT ). (8.10)
In terms of the rank one matrix M = vvT , the constraint kvk22
= 1 is equivalent
to the linear constraint trace(M) = 1, and the constraint kvk1  t can
be expressed as trace(|M|E)  t2, where E 2 Rp×p is a matrix of all ones,
and |M| is the matrix obtained by taking absolute values entry-wise. Putting
together the pieces, we conclude that the nonconvex SCoTLASS objective has
the equivalent reformulation
maximize
M0
trace(XTXM)
subject to trace(M) = 1, trace(|M|E)  t2, and rank(M) = 1.
(8.11)
By construction, any optimal solution to this problem is a positive semidefinite
matrix of rank one, say M = vvT , and the vector v is an optimal solution to
the original problem (8.7). However, the optimization problem (8.11) is still
nonconvex, due to the presence of the constraint rank(M) = 1. By dropping
this constraint, we obtain the semidefinite program proposed by d’Aspremont
et al. (2007), namely
maximize
M0
trace(XTXM)
subject to trace(M) = 1, trace(|M|E)  t2.
(8.12)
Since this problem is convex, it has no local optima, and a global optimum
can be obtained by various standard methods. These include interior point
methods (Boyd and Vandenberghe 2004); see also d’Aspremont et al. (2007)
for a special-purpose and more efficient method for solving it.
In general, solving the SDP (8.12) is computationally more intensive than
finding a local optimum of the biconvex criterion (8.8). However, since it is a
convex relaxation of an exact reformulation, it has an attractive theoretical
guarantee: if we solve the SDP and do obtain a rank-one solution, then we
have in fact obtained the global optimum of the nonconvex SCoTLASS criterion.
For various types of spiked covariance models, it can be shown that the
SDP (8.12) will have a rank-one solution with high probability, as long as the
sample size N is sufficiently large relative to the sparsity and dimension (but
still allowing for N  p); see Section 8.2.6 for further discussion. Thus, for
all of these problems, we are guaranteed to have found the global optimum of
the SCoTLASS criterion.
8.2.2.2 Methods Based on Reconstruction
We now turn to methods for sparse PCA that are based on its reconstruction
interpretation. In the case of a single sparse principal component, Zou, Hastie
SPARSE PRINCIPAL COMPONENTS ANALYSIS 207
and Tibshirani (2006) proposed the optimization problem
minimize
,v2R
p
kk2=1
(
1
N
XN
i=1 kxi − vT xik22
+ 1kvk1 + 2kvk22
)
, (8.13)
where 1, 2 are nonnegative regularization parameters. Let’s examine this
formulation in more detail.
• If we set 1 = 2 = 0, then it is easy to show that the program (8.13)
achieves its optimum at a pair ˆ = ˆv = v1, corresponding to a maximum
eigenvector of XTX, so that we recover the usual PCA solution.
• When p  N the solution is not necessarily unique unless 2 > 0. If we set
1 = 0, then for any 2 > 0, the optimal solution bv is proportional to the
largest principal component direction.
• In the general setting with both 1 and 2 strictly positive, the `1-penalty
weighted by 1 encourages sparsity of the loadings.
Like the objective (8.8), criterion (8.13) is not jointly convex in v and ,
but is biconvex. Minimization over v with  fixed is equivalent to an elasticnet
problem (see Section 4.2) and can be computed efficiently. On the other
hand, minimization over  with v fixed has the simple solution
 = XT z
kXT zk2
, (8.14)
where zi = vT xi for i = 1, . . . ,N (see Exercise 8.8). Overall, this procedure is
reasonably efficient, but not as simple as Algorithm 8.1, which involves just
soft-thresholding.
It turns out that the original SCoTLASS criterion (8.7) and the regressionbased
objective function (8.13) are intimately related. Focusing on the rankone
case (8.13), consider the constrained as opposed to the Lagrangian form
of the optimization problem—namely
minimize
kvk2=kk2=1 kX − XvT k2
F subject to kvk1  t. (8.15)
If we add the extra `1-constraint kk1  t, then as shown in Exercise 8.7,
the resulting optimization problem is equivalent to the SCoTLASS criterion
(8.7). Consequently, it can be solved conveniently by Algorithm 8.1. Note
that adding this `1-constraint is quite natural, as it just symmetrizes the constraints
in problem (8.15).
8.2.3 Higher-Rank Solutions
In Section 8.2.1, we presented a sequential approach for standard principal
components analysis, based on successively solving the rank-one problem, restricting
each candidate to be orthogonal to all previous solutions. This sequential
approach also solves the multirank problem (8.2).
208 SPARSE MULTIVARIATE METHODS
How about in the sparse setting? This sequential approach is also used
in the SCoTLASS procedure, where each candidate solution for rank k is
restricted to be orthogonal to all previous solutions for ranks < k. However,
here the sequential approach will typically not solve a multirank criterion.
For the sparse PCA approach (8.8), we can apply the multifactor penalized
matrix decomposition (7.3) of Chapter 7. Given the rank-one solution
(u1, v1, d1), we simply compute the residual X0 = X − d1u1vT1 and apply the
rank-one Algorithm (8.8) to X0 to obtain the next solution.2 Doing so ensures
neither orthogonality of the principal components {(u1d1), (u2d2), . . . (ukdk) nor the sparse loading vectors } {v1, v2 . . . , vk}. But the solutions do tend to be
somewhat orthogonal in practice.
However, there is a subtle issue here: it is not clear that orthogonality of
the vectors {v1, v2, . . . vk} is desirable in the setting of sparse PCA, as orthogonality
may be at odds with sparsity. Otherwise stated, enforcing orthogonality
might result in less sparse solutions. A similar issue arises with sparse coding,
as discussed in Section 8.2.5.
Interestingly, one can modify the approach (8.8) to constrain the vectors uj
to be orthogonal, with no such constraints on the vectors vj . This modification
can improve the interpretability of the set of solutions while still allowing the
vj to be sparse. In detail, consider the problem
maximize
uk, vk

uT
kXvk
	
subject to kvkk2  1, kvkk1  c,
and kukk2  1 with uT
k uj = 0 for all j = 1, . . . , k − 1.
(8.16)
The solution for uk with vk fixed is
uk =
P?
k −1Xvk
kP?
k−1Xvkk2
(8.17)
where P?
k−1 = I−
Pk−1
i=1 uiuT
i , the projection onto the orthogonal complement
of the space spanned by u1, u2, . . . uk−1. This multifactor version of Algorithm
8.1 uses operation (8.17) in place of the rank-one projection u = Xv
kXvk2 .
The approach (8.13) of Zou et al. (2006) can be generalized to r > 1
components by minimizing the cost function
1
N
XN
i=1 kxi − VT xik22
+
Xr
k=1
1kkvkk1 + 2
Xr
k=1 kvkk22
, (8.18)
subject to T = Ir×r. Here V is a p × r matrix with columns {v1, . . . , vr},
and  is also a matrix of dimension p × r. Although this objective function
(8.18) is not jointly convex in V and , it is biconvex. Minimization over
V with  fixed is equivalent to solving r separate elastic net problems and
2Without sparsity constraints, this procedure would deliver exactly the usual sequence
of principal components.
SPARSE PRINCIPAL COMPONENTS ANALYSIS 209
can be done efficiently. On the other hand, minimization over  with V fixed
is a version of the so-called Procrustes problem, and can be solved by a simple
SVD calculation (Exercise 8.10). These steps are alternated until convergence
to a local optimum.
8.2.3.1 Illustrative Application of Sparse PCA
Here we demonstrate sparse principal components on a dataset of digitized
handwritten digits. We have a training set of N = 664 gray-scale images of
handwritten sevens. Each image contains 16 × 16 pixels, leading to a data
matrix X of dimension 664 × 256. Panel (a) of Figure 8.2 shows some ex-
(a)
(b)
Figure 8.2 (a) A sample of handwritten sevens from the zip code database. (b)
Top row: first four principal components for “sevens” data (color shades represent
negative loadings as yellow and positive loadings as blue); Bottom two rows: first eight
sparse principal components, constrained to be positive. These are superimposed on
the average seven to enhance interpretability.
amples of these images, where panel (b) shows the results of sparse principal
components, and contrasts them with standard PCA. The top row in panel
(b) shows the first four standard principal components, which explain about
50% of the variance. To enhance interpretability, we compute sparse principal
components with the loadings constrained to be nonnegative. In order to do
so, we simply replace the soft-threshold operator S(x) in Algorithm 8.1 by
the nonnegative soft-threshold operator S+
 (x) = (x − )+.
210 SPARSE MULTIVARIATE METHODS
The first eight sparse principal components are shown in the middle and
bottom rows, and also explain about 50% of the variation. While more components
are needed to explain the same amount of variation, the individual
components are simpler and potentially more interpretable. For example, the
2nd and 6th sparse components appear to be capturing the “notch” style used
by some writers, for example in the top left image of Figure 8.2(a).
8.2.4 Sparse PCA via Fantope Projection
Vu, Cho, Lei and Rohe (2013) propose another related approach to sparse
PCA. Letting S = XTX/N, their proposal is to solve the semidefinite program
maximize
Z2Fp {trace(SZ) − kZk1} (8.19)
where the convex set Fp = {Z : 0  Z  I, trace(Z) = p} is known as a
Fantope. When p = 1 the spectral norm bound in Fp is redundant and (8.19)
reduces to the direct approach of d’Aspremont et al. (2007). For p > 1, although
the penalty in (8.19) only implies entry-wise sparsity of the solution, it
can be shown (Lei and Vu 2015) that the solution is able to consistently select
the nonzero entries of the leading eigenvectors under appropriate conditions.
8.2.5 Sparse Autoencoders and Deep Learning
In the neural network literature, an autoencoder generalizes the idea of principal
components. Figure 8.3 provides a simple illustration of the idea, which
is based on reconstruction, much like in the criterion (8.13). The autoenx1
x2
x3
x4
x5
ˆx1
ˆx2
ˆx3
ˆx4
ˆx5
Input
layer
Hidden
layer
Output
layer
WT
(WT x)
W
Figure 8.3 Left: Network representation of an autoencoder used for unsupervised
learning of nonlinear principal components. The middle layer of hidden units creates
a bottleneck, and learns nonlinear representations of the inputs. The output layer is
the transpose of the input layer, and so the network tries to reproduce the input
data using this restrictive representation. Right: Images representing the estimated
columns of W in an image modeling task.
SPARSE PRINCIPAL COMPONENTS ANALYSIS 211
coder is based on a p × m matrix of weights W with m < p; it is used to
create m linear combinations of the input vector x. Each such linear combination
is passed through a nonlinear function , with the sigmoid function
(t) = 1/(1 + e−t) being one typical choice, as represented in Figure 8.3 via
the vector function h(x) = (WT x). The output layer is then modeled as
Wh(x) = W(WT x).3 Given input vectors xi for i = 1, . . . ,N, the weight
matrixWis then estimated by solving the (nonconvex) optimization problem
minimize
W2Rm×p
(
1
2
XN
i=1 kxi −Wh(xi)k2
)
. (8.20)
If we restrict  to be the identity function, then h(x) =WT x and the solution
to (8.20) is equivalent to principal components; i.e., WWT = VmVTm
, where
Vm is the p × m matrix consisting of the first m principal component loadings
(see Exercise 8.12). Here the bottleneck in the network imposes a rank
constraint on W, forcing it to learn structure.
In modeling high-dimensional signals such as images, the vectors xi might
represent the pixels of a (sub) image. The columns of W represent a learned
dictionary of image shapes, and h(xi) tries to represent xi in this basis. Now
the bottleneck might be seen as an unnecessary restriction, since many slightly
different shapes are likely in an image. The idea is to replace this restriction
by imposing sparseness on the coefficients h(x), leading to so-called sparse
coding (Olshausen and Field 1996). To build intuition, we first consider the
linear case, but now with m > p. In the optimization problem
minimize
W2Rp×m,{si}N1
2Rm
(
1
2
XN
i=1

kxi −Wsik22
+ ksik1
	
)
subject to kWk2
F  1,
(8.21)
the individual si are forced to be sparse through the `1-penalties. The columns
of W are not constrained to be uncorrelated, and their total size is kept
in bound by the Frobenius norm. Exercise 8.13 examines the sparse linear
coder (8.21) in more detail, and develops a natural alternating algorithm for
solving it. The right panel of Figure 8.3 illustrates a typical solution for W
in an image modeling problem, where each xi is a vectorized version of an
image. Each subimage represents a column of W (the codebook), and every
image is modeled as a sparse superposition of elements of W. Modern sparse
encoders used in deep learning generalize this formulation in several ways (Le
et al. 2012):
• They use multiple hidden layers, leading to a hierarchy of dictionaries;
• Nonlinearities that can be computed more rapidly than the sigmoid are
used—for example (t) = t+.
3In practice, bias terms are also included in each linear combination; we omit them here
for simplicity.
212 SPARSE MULTIVARIATE METHODS
• More general sparseness penalties are imposed directly on the coefficients
h(xi) in the problem (8.20).
These models are typically fit by (stochastic) gradient descent, and often on
very large databases of images (for example), using distributed computing
with large clusters of processors.
One important use of the sparse autoencoder is for pretraining. When fitting
a supervised neural network to labelled data, it is often advantageous
to first fit an autoencoder to the data without the labels and then use the
resulting weights as starting values for fitting the supervised neural network
(Erhan et al. 2010). Because the neural-network objective function is nonconvex,
these starting weights can significantly improve the quality of the final
solution. Furthermore, if there is additional data available without labels, the
autoencoder can make use of these data in the pretraining phase.
8.2.6 Some Theory for Sparse PCA
Here we give a brief overview of how standard principal component analysis
breaks down in the high-dimensional setting (p  N), and why some structural
assumption—such as sparsity in the principal components—is essential.
One way of studying the behavior of (sparse) PCA is in terms of a spiked
covariance model, meaning a p-dimensional covariance matrix of the form
 =
MX
j=1
!jjT
j + 2Ip×p, (8.22)
where the vectors {j}Mj
=1 are orthonormal, and associated with positive
weights !1  !2  · · ·  !M > 0. By construction, the vectors {j}Mj
=1 are the
top M eigenvectors of the population covariance, with associated eigenvalues
{2 + !j}Mj
=1.
Given N i.i.d. samples {xi}Ni
=1 from a zero-mean distribution with covariance
, standard PCA is based on estimating the span of {j}Mj
=1 using the
top M eigenvectors of the sample covariance matrix b = 1
N
PN
i=1 xixTi
. In
the classical setting, in which the dimension p remains fixed while the sample
size N ! +1, the sample covariance converges to the population covariance,
so that the principal components are consistent estimators. More relevant for
high-dimensional data analysis is a scaling in which both p and N tend to
infinity, with p/N ! c 2 (0,1) with M and the eigenvalues remaining fixed.4
Under this scaling, the sample eigenvectors or principal components do not
converge to the population eigenvectors {
(p)
j }Mj
=1. In fact, if the signal-to-noise
ratios !j/2 are sufficiently small, the sample eigenvectors are asymptotically
orthogonal to the population eigenvectors! This poor behavior is caused by
4To be clear, for each j = 1, . . . ,M, we have a sequence {
(p)
j } of population eigenvectors,
but we keep the signal-to-noise ratio !j/2 fixed, independently of (p,N).
SPARSE CANONICAL CORRELATION ANALYSIS 213
the p − M dimensions of noise in the spiked covariance model (8.22), which
can swamp the signal when N  p; see Johnstone and Lu (2009) for a precise
statement of this phenomenon.
Given the breakdown of high-dimensional PCA without any structure on
the eigenvectors, we need to make additional assumptions. A number of authors
have explored how sparsity can still allow for consistent estimation of
principal components even when p  N. Johnstone and Lu (2009) propose a
two-stage procedure, based on thresholding the diagonal of the sample covariance
matrix in order to isolate the highest variance coordinates, and then performing
PCA in the reduced-dimensional space. They prove consistency of this
method even when p/N stays bounded away from zero, but allow only polynomial
growth of p as a function of sample size. Amini and Wainwright (2009)
analyze the variable selection properties of both diagonal thresholding and the
semidefinite programming relaxation (8.12) of the SCoTLASS problem (8.7).
For a spiked covariance model (8.22) with a single leading eigenvector that
is k-sparse, they show that the diagonal thresholding method (Johnstone and
Lu 2009) succeeds in recovering sparsity pattern of the leading eigenvector if
and only if the sample size N  k2 log p. The SDP relaxation also performs
correct variable selection with this scaling of the sample size, and in certain
settings, can succeed with fewer samples. Amini and Wainwright (2009)
show that no method—even one based on exhaustively enumerating all the
subsets—can succeed with fewer than N  k log p samples.
Other authors have studied the estimation of the eigenspaces themselves
in `2 or related norms. Paul and Johnstone (2008) propose the augmented
SPCA algorithm, a refinement of the two-stage method of Johnstone and
Lu (2009); this algorithm is also analyzed by Birnbaum, Johnstone, Nadler
and Paul (2013), who show that it achieves the minimax rates for models of
weakly sparse eigenvectors in `q-balls. In independent work, Vu and Lei (2012)
prove minimax lower bounds for the sparse PCA problem, and show that
they can be achieved by computing the maximum eigenvalue of the sample
covariance subject to an `q-constraint. Ma (2010, 2013) and Yuan and Zhang
(2013) have studied algorithms for sparse PCA based on a combination of
the power method (a classical iterative technique for computing eigenvectors)
with intermediate soft-thresholding steps. When M = 1, the procedure of Ma
(2013) is essentially the same as Algorithm 8.1, the only difference being the
use of a fixed level  in the soft-thresholding step, rather than the variable
choice used in the latter to solve the bound version of the problem.
8.3 Sparse Canonical Correlation Analysis
Canonical correlation analysis extends the idea of principal components analysis
to two data matrices. Suppose that we have data matrices X, Y of dimensions
N × p and N × q, respectively, with centered columns. Given two
vectors  2 Rp and  2 Rq, they define one-dimensional projections of the two
datasets, namely the variates (N-vectors) X and Y, respectively. Canoni214
SPARSE MULTIVARIATE METHODS
cal correlation analysis (CCA) chooses  and  to maximize the correlation
between these two variates.
In detail, the sample covariance between X and Y is given by
dCov(X,Y) = 1
N
XN
i=1
(xTi
) (yT
i ) = 1
N
TXTY. (8.23)
where xi and yi are the ith rows of X and Y, respectively. CCA solves the
problem
maximize
2Rp, 2Rq
n
dCov(X,Y)
o
subject to dVar(X) = 1 and dVar(Y) = 1.
(8.24)
The solution set (1, 1) are called the first canonical vectors, and the corresponding
linear combinations z1 = X1 and s1 = Y1 the first canonical
variates. Subsequent pairs of variates can be found by restricting attention
to vectors such that the resulting variates are uncorrelated with the earlier
ones. All solutions are given by a generalized SVD of the matrix XTY (see
Exercise 8.14).
Canonical correlation analysis fails when the sample size N is strictly less
than max(p, q): in this case, the problem is degenerate, and one can find
meaningless solutions with correlations equal to one. One approach to avoiding
singularity of the sample covariance matrices 1
NXTX and 1
NYTY is by
imposing additional restrictions. For instance, the method of ridge regularization
is based on adding some positive multiple  of the identity to each
sample covariance matrix; see Exercise 8.17 for further discussion. An alternative
method is based on taking only the diagonal entries of the sample
covariance matrices, an approach that we adopt below.
Sparse canonical vectors can be derived by imposing `1-constraints on 
and  in the criterion (8.24), leading to the modified objective
maximize
, 
n
dCov(X,Y)
o
subject toVar(X) = 1, kk1  c1,Var(Y) = 1, kk1  c2.
(8.25)
Note that one can use either the bound form for the `1-constraints (as above),
or add corresponding Lagrangian terms. For numerical solution of this problem,
we note that the standard CCA problem (8.24) can be solved by alternating
least squared regressions (see Exercises 8.14–8.17). Not surprisingly then,
the sparse version (8.25) can be solved by alternating elastic-net procedures,
as we explore in Exercise 8.19.
The sparse formulation (8.25) is useful when N > max(p, q), but can fail
in high-dimensional situations just as before. Again, ridging the individual
SPARSE CANONICAL CORRELATION ANALYSIS 215
covariance matrices will resolve the issue, and can be absorbed in the alternating
elastic-net regressions. When the dimensions are very high—as in genomic
problems—the cross-covariance between X and Y is of primary interest, and
the internal covariance among the columns of X and among the columns of
Y are nuisance parameters which can add to the estimation variance. In this
case, it is convenient to standardize the variables, and then assume the internal
covariance matrices are the identity. We are thus led to the problem
maximize
,
dCov(X,Y)
subject tokk2  1, kk2  1, kk1  c1, kk1  c2.
(8.26)
This objective has the same form as the penalized matrix decomposition (7.6)
previously discussed in Chapter 7, but using as input the data matrix XTY.
We can thus apply Algorithm 7.2 directly, using alternating soft-thresholding
to compute the solutions.
Higher-order sparse canonical variates are obtained from the higher-order
PMD components: as in Algorithm 7.3, after computing a solution, we take
residuals and then apply the procedure to what remains.
8.3.1 Example: Netflix Movie Rating Data
Let us illustrate the behavior of sparse CCA by applying it to the Netflix
movie-ratings data. As originally described in detail in Section 7.3.1, the full
dataset consists of 17, 770 movies and 480, 189 customers. Customers have
rated some (around 1%) of the movies on a scale from 1 to 5. For this example,
we selected the p = N = 500 movies and customers with the most ratings,
and imputed the missing values with the movie means.
Among the 500 films, we identified those that were action movies (59 in all)
and those that were romantic movies (73 in all). The remaining movies were
discarded. We then applied the sparse CCA procedure to the data. The idea
was to correlate each customer’s ratings on the action movies with their ratings
on the romantic movies. We divided the 500 customers into two equal-sized
training and test groups at random, and applied sparse CCA to the training
set. We constrained the weight vectors to be nonnegative for interpretability.
The movies receiving positive weights in the first sparse pair of components
are shown in Table 8.3.1. Perhaps a movie buff could tell us why the ratings
on these particular movies should correlate; for example, the action movies
may be relatively “tame” compared to films like Terminator. In Figure 8.4,
we plot the average ratings for the seven action movies on the test set, plotted
against the average rating for the 16 romantic movies for each customer. The
correlation is quite high—about 0.7. Hence for a given customer, we can do a
reasonable job of predicting his/her average rating for the seven action movies
from his/her average rating on the 16 romantic movies, and vice versa.
216 SPARSE MULTIVARIATE METHODS
Table 8.2 Small Netflix dataset: Action and romantic movies with nonzero
weights in the first sparse canonical covariates.
Action Movies
Speed S.W.A.T. Men in Black II
The Fast and the Furious Behind Enemy Lines Charlies Angels
Con Air
Romantic Movies
What Women Want Ghost The Family Man
The Bodyguard Miss Congeniality Pretty Woman
Sister Act Dirty Dancing Runaway Bride
Just Married Maid in Manhattan Two Weeks Notice
Legally Blonde 2: Red 13 Going on 30 Father of the Bride
Legally Blonde
1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0
2 3 4 5
Action Movies
Romantic Movies
Average Ratings
corr= 0.7
Figure 8.4 Sparse canonical correlation analysis applied to a subset of the Netflix
movie rating data. The plot shows the average rating for the seven action movies on
the test data versus the average for the 16 romantic movies having nonzero weights
in the first sparse CCA components.
SPARSE LINEAR DISCRIMINANT ANALYSIS 217
8.4 Sparse Linear Discriminant Analysis
Linear discriminant analysis (LDA) is an important technique for classification.
There is a variety of different proposals for sparse linear discriminant
analysis, in part because there are at least three different ways to approach
classical discriminant analysis. These are the normal theory model, Fisher’s
between-to-within variance criterion, and optimal scoring. In addition, in the
high-dimensional regime p  N, some form of regularization is needed for
the within-class covariance estimate, and the form of this estimate leads to
different methods for sparse LDA.
8.4.1 Normal Theory and Bayes’ Rule
Consider a response variable G falling into one of K classes {1, 2, . . . ,K},
and a predictor vector X 2 Rp. Suppose that fk(x) is the class-conditional
density of X in class G = k, and let k be the prior probability of class k,
with PK
k=1 k = 1. A simple application of Bayes’ rule gives us
Pr(G = k | X = x) = kfk(x)
PK
`=1 `f`(x) . (8.27)
Suppose moreover that each class density is modeled as a multivariate Gaussian
N(μk,w), with density
fk(x) = 1
(2)p/2|w|1/2 e−12
(x−μk)T−1
w (x−μk), (8.28)
based on a common covariance matrix w. In comparing two classes k and
`, it is sufficient to look at the log-ratio of their posterior probabilities (8.27),
and we find that
log Pr(G = k | X = x)
Pr(G = `|X = x) = log fk(x)
f`(x) + log k
`
= log k
` −
1
2(μk + μ`)T−1
w (μk − μ`)
+ xT−1
w (μk − μ`),
(8.29)
an equation linear in x. Consequently, the decision boundary between classes k
and `—i.e., all vectors x for which Pr(G = k | X = x) = Pr(G = ` | X = x)—
defines a hyperplane in Rp. This statement holds for any pair of classes, so
all the decision boundaries are linear. If we divide Rp into regions that are
classified as class 1, class 2, and so on, these regions will be separated by
hyperplanes.
Equation (8.29) shows us that these LDA models are also linear logistic
regression models; the only difference is the way the parameters are estimated.
In logistic regression, we use the conditional binomial/multinomial likelihoods,
whereas estimation in LDA is based on the joint likelihood of X and G (Hastie
218 SPARSE MULTIVARIATE METHODS
et al. 2009, Chapter 4). From Equation (8.29), we see that the linear discriminant
functions
k(x) = xT−1
w μk −
1
2μTk
−1
w μk + log k (8.30)
provide an equivalent description of the decision rule, leading to the classification
function G(x) = arg maxk2{1,...,K} k(x).
In practice, the parameters of the Gaussian class-conditional distributions
are not known. However, given N samples {(x1, g1), . . . , (xN, gN)} of featurelabel
pairs, we can estimate the parameters as follows. Let Ck denote the
subset of indices i for which gi = k, and let Nk = |Ck| denote the total
number of class-k samples. We then form the estimates bk = Nk/N, and
bμk = 1
Nk
X
i2Ck
xi, and (8.31a)
bw = 1
N − K
XK
k=1
X
i2Ck
(xi − bμk)(xi − bμk)T . (8.31b)
Note that bw is an unbiased estimate of the pooled within-class covariance.
In the high-dimensional setting with p > N, the sample within-class covariance
matrix bw is singular, and so we must regularize it in order to proceed. As
before, there are many ways to do so; later in this section, we describe an approach
based on quadratic regularization (Hastie, Buja and Tibshirani 1995).
In very high dimensions, it is often effective to assume that predictors are
uncorrelated, which translates into a diagonal form for w. Doing so yields
the so-called naive Bayes classifier, or alternatively diagonal linear discriminant
analysis (see Exercise 8.20). Letting b2
j = s2j
be the pooled within-class
variance for feature j, the estimated classification rule simplifies to
bG(x) =
arg min
`=1,...,K
8<
:
Xp
j=1
(xj − bμj`)2
b2
j − log ˆk
9=
;, (8.32)
known as the nearest centroid rule.
8.4.2 Nearest Shrunken Centroids
Notice that the classification rule (8.32) will typically involve all features;
when p is large, while one might expect that only a subset of these features is
informative. This subset can be revealed by reparametrizing the model, and
imposing a sparsity penalty. More specifically, suppose that we decompose the
mean vector for class k into the sum μk = ¯x + k, where ¯x = 1
N
PN
i=1 xi is
the overall mean vector, and k 2 Rp, k = 1, . . . ,K denotes the contrast
for class k, together satisfying the constraint PK
k=1 k = 0. We then consider
SPARSE LINEAR DISCRIMINANT ANALYSIS 219
optimizing the `1-regularized criterion
minimize
k2Rp,k=1,...,K
8<
:
1
2N
XK
k=1
X
i2Ck
Xp
j=1
(xij − ¯xj − jk)2
s2j
+ 
XK
k=1
Xp
j=1
pNk
sj |jk|
9=
;
subject to PK
k=1 jk = 0 for j = 1, . . . , p.
(8.33)
The solutions for jk amount to simple soft-thresholding of particular
class-wise contrasts. In detail, we define the contrasts
djk = exjk − ¯xj
mksj
, (8.34)
where exjk = 1
Nk
P
i2Ck
xij , the quantity ¯xj denotes the jth component of the
global mean ¯x, and5 m2
k = 1
Nk − 1
N . We then apply the soft-thresholding operator
d0
jk = S(djk) = sign(djk)(|djk| − )+, (8.35a)
and reverse the transformation to obtain the shrunken centroid estimates
bμ0
jk = ¯xj + mksjd0
kj . (8.35b)
Finally, we use these shrunken centroids for the estimates for μjk in the nearest
centroid rule (8.32).
Suppose for a given feature j, the contrasts d0
jk are set to zero by the softthresholding
for each of the k classes. Then that feature does not participate
in the nearest centroid rule (8.32), and is ignored. In this way, the nearest
shrunken centroid procedure does automatic feature selection. Alternatively,
a feature might have d0
jk = 0 for some classes but not others, and hence would
only play a role for those classes.
The nearest shrunken centroid classifier is very useful for high-dimensional
classification problems, like those that occur in genomic and proteomic
data. The publicly available software (Hastie, Tibshirani, Narasimhan and
Chu 2003) includes some additional bells and whistles: a small constant s0
is added to each sj , to stabilize the contrasts when sj is close to zero; classspecific
shrinkage rates, to name a few.
Figure 8.5 shows the results of this procedure applied to some Lymphoma
cancer data (Tibshirani, Hastie, Narasimhan and Chu 2003). These data consist
of expression measurements on 4026 genes from samples of 59 lymphoma
patients. The samples are classified into diffuse large B-cell lymphoma (DLBCL),
follicular lymphoma (FL), and chronic lymphocytic lymphoma (CLL).
5The quantity mk is a standardization constant, based on the variance of the numerator,
which makes djk a t-statistic.
220 SPARSE MULTIVARIATE METHODS
−1.5 −0.5 0.5 1.0 1.5
DLCL (27)
0 1000 2000 3000 4000
−1.5 −0.5 0.5 1.0 1.5
FL (5)
−1.5 −0.5 0.5 1.0 1.5
CLL (7)
Gene
Centroids: Average Expression Centered at Overall Centroid
0 1 2 3 4 5
Amount of Shrinkage l
Error
4026 3146 1774 867 557 354 212 128 78 48 21 13 3
Size
0.0 0.2 0.4 0.6 0.8
Train
CV
Test
Figure 8.5 Results of nearest-shrunken-centroid classification on some Lymphoma
data, with three classes. The top plot shows the class-specific mean expression for
each gene (gray lines), and their shrunken versions (blue). Most of the genes are
shrunk to the overall mean (0 here). The lower plot shows training, cross-validated,
and test misclassification error as a function of the shrinkage threshold . The chosen
model includes 79 genes, and makes 0 test errors.
SPARSE LINEAR DISCRIMINANT ANALYSIS 221
The data are divided into a training set of 39 (27, 5, 7) samples, and a test
set of 20. The genes have been organized by hierarchical clustering. All but
79 of the genes have been shrunk to zero. Notice that the deviations of the
smaller classes are larger, since the biggest class DLBCL mostly determines
the overall mean. In Section 8.4.3.1, we compare the nearest shrunken centroid
classifier to a sparse version of Fisher’s linear discriminant analysis, discussed
next.
8.4.3 Fisher’s Linear Discriminant Analysis
A different approach to sparse discriminant analysis arises from Fisher’s discriminant
framework. Here the idea is to produce low-dimensional projections
of the data that preserve the class separation. Although these projections are
primarily intended for visualization, one can also perform Gaussian classification
in the subspace produced.
Let X be an N × p matrix of observations, and assume that its columns,
corresponding to features, have been standardized to have mean zero. Given
such an observation matrix, we seek a low-dimensional projection such that
the between-class variance is large relative to the within-class variance. As
before, let bw be the pooled within-class covariance matrix and bμk the classspecific
centroids. The between-class covariance matrix bb is the covariance
matrix of these centroids, given by
bb =
XK
k=1
bkbμkbμTk
, (8.36)
treating them as multivariate observations with mass ˆk. Note that
bt = 1
N
XTX = bb + bw. (8.37)
For now we assume that bw is of full rank (which implies that p  N); we
treat the non-full rank case below. For a linear combination z = X, Fisher’s
between-to-within variance criterion is captured by the ratio
R() = T bb
T bw
, (8.38)
which is to be maximized. Fisher’s LDA proceeds by sequentially solving the
following problem:
maximize
2Rp
n
T bb
o
such that T bw  1, and T bw b` = 0 for all ` < k.
(8.39)
for k = 1, 2, . . . , min(K −1, p). Although the problem (8.39) is generally written
with the inequality constraint replaced with an equality constraint, the
two programs are equivalent if bw has full rank. The solution bk is called
222 SPARSE MULTIVARIATE METHODS
the kth discriminant vector, and zk = Xbk the corresponding discriminant
variable. Note that LDA essentially does principal components on the class
centroids, but using a normalization metric that respects the within-class variances
(Hastie et al. 2009, Chapter 4). In practice, we do not need to solve the
problem sequentially, because as with PCA we can get all the solutions with a
single eigen-decomposition: the first k discriminant vectors are the k leading
eigenvectors of b−1
w
bb.
Witten and Tibshirani (2011) proposed a way to “sparsify” the objective
(8.39), in particular by solving
maximize

8<
:T bb − 
Xp
j=1
ˆj |j |
9=
; subject to T ew  1, (8.40)
where ˆ2
j is the jth diagonal element of bw, and ew is a positive definite estimate
for w. This produces a first sparse discriminant vector b1 with level
of sparsity determined by the choice of . Further components can be successively
found by first removing the current solution from bb before solving
problem (8.40); see the reference for details.
The choice for the regularized within-covariance matrix ew depends on the
setting. In some problems, we might choose ew to encourage spatial smoothness,
for example when the data are images. Then we can take ew = bw +

where 
 penalizes differences in spatially nearby values. This idea is studied
in the flexible and penalized discriminant analysis approach of Hastie,
Tibshirani and Buja (1994) and Hastie et al. (1995). In the sparse setting,
this is conveniently implemented using the optimal-scoring approach of Section
8.4.4. In other cases we only require that ew makes the sample estimate
bw positive definite, and for that purpose we can use a ridged version
ew = bw +  diag(bw) for some  > 0.
One simple case of particular interest is where ew is taken to be a diagonal
matrix, for example diag(bw). Then problem (8.40) can be cast as
a penalized matrix decomposition applied to the between covariance matrix
bb, and Algorithm 7.2 can be applied. In this case, with K = 2 classes, this
method gives a solution that is similar to nearest shrunken centroids: details
are in Witten and Tibshirani (2011, Section 7.2). With more than two classes,
the two approaches are different. Nearest shrunken centroids produce sparse
contrasts between each class and the overall mean, while the sparse LDA
approach (8.40) produces sparse discriminant vectors for more general class
contrasts. This distinction is explored in the next example.
8.4.3.1 Example: Simulated Data with Five Classes
We created two artificial scenarios to contrast the nearest shrunken centroids
approach with sparse discriminant analysis (8.40). Figure 8.6 shows the results
of nearest shrunken centroids classifier applied to the two different simulated
SPARSE LINEAR DISCRIMINANT ANALYSIS 223
1 2 3 4 5
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
Scenario 1
1 2 3 4 5
1
2
3
4
5
6
7
9
10
11
12
13
14
15
16
17
18
19
20
53
172
233
271
512
542
671
700
750
835
925
954
Scenario 2
Figure 8.6 Results of nearest shrunken centroid classifier applied to two different
simulated datasets, as described in the text. Those features (rows in each plot) with
nonzero estimated contrasts are shown. The length of each horizontal line segment is
proportional to the size of the contrast, with positive values to the right and negative
values to the left.
datasets. In both cases there are N = 100 observations, with 20 observations
falling into each of K = 5 classes involving p = 1000 features.
1. In the first scenario, the first 10 features are two units higher in class 1,
features 11–20 are two units higher in class 3, and features 21–30 are two
units lower in class 5. Thus, higher values in each of the first three block of
10 features characterize classes 1, 3, and 5.
2. In the second scenario, features 1–10 are one unit higher in classes 3–5
versus 1,2 and features 11–20 are one unit higher in class 2 and one unit
lower in class 1. Hence higher values for the first 10 features discriminate
classes 3–5 versus 1 and 2, while higher values for the second 10 features
discriminate between classes 1 versus 2.
We applied the nearest shrunken centroid classifier, using cross-validation
to choose the shrinkage parameter and show the features with nonzero estimated
contrasts. The length of each horizontal line segment is proportional to
the size of the contrast, with positive values to the right and negative values
to the left. In the left panel, we see that nearest shrunken centroids has clearly
revealed the structure of the data, while in the right panel, the structure does
not come through as clearly. Figure 8.7 shows the results of rank-2 sparse
linear discriminant analysis with diagonal within-class covariance in each of
the two scenarios. In the first scenario (top row), the discriminant projection
cleanly separates classes 1, 3, and 5 from the rest, but the discriminant loadings
(top right) are forced to combine three pieces of information into two
vectors, and hence give a cloudy picture. Of course one could use more than
224 SPARSE MULTIVARIATE METHODS
−6 −4 −2 0 2 4 6 8
−6 −4 −2 0 2 4 6 8
First Discriminant Score
Second Discriminant Score
2
5 5
3
2
4
2
5
3
1
5
4
5
3
2 4
3
2
3
4
4
2
3
5
3
1
4
5
1
4
1
2 5
4
2
5
4
1
3
1
4
3
2
1
2
2
5
1
2
1
1
3
1
1
3
2
2 5
5
3
2
5
3
3
4 4 5
5
3
3
2
5
3
3
1
1
2
1
2
5
3
4 2
5
1
4
3
1
4
4
5
4 4
1
1
2
1
0 5 10 15 20 25 30
−0.3 −0.1 0.1 0.2 0.3
Predictor
Discriminant Loading
●
●
●
● ●
●
●
●
● ●
●
●
●
●
●
●
● ●
● ●
●
● ●
●
● ●
●
●
● ●
●
●
●
●
●
●
●
●
●
●
●
●
●
● ●
●
●
●
●
● ●
●
First Component
Second Component
Scenario 1
−4 −2 0 2 4
−4 −2 0 2
First Discriminant Score
Second Discriminant Score
1
1
2
2
2
4
2
3
4
3
5
2
3
1
5
1
4
3
5
4
3
1
2
5
4
1
3
2 2
4
2
4
5
3
2 2
5
4
1
4
3
3 4 4
5
5
2
3
4
2
3
3 3
5
4 4
5
5
1
3
5
5
5
2
3
5
3
1 1
5
1
1
4
4
2
5
2
1
1
2
5
3
2 1
4
1
3
5
4
5 3
1
4
2
1
4
1
1
3
2
0 5 10 15 20 25 30
−0.5 −0.4 −0.3 −0.2 −0.1 0.0
Predictor
Discriminant Loading
● ●
●
●
●
●
●
●
●
● ●
●
●
●
●
●
●
●
●
Scenario 2
Figure 8.7 Rank two sparse linear discriminant analysis with diagonal within-class
covariance, applied to the same two scenarios (top and bottom panels) as in Figure
8.6. The projections onto the first two sparse discriminant vectors is shown in
the left panels, while the right panels show the discriminant weights or loadings.
SPARSE LINEAR DISCRIMINANT ANALYSIS 225
K = 2 sparse components and this would help in this example, but this approach
is less attractive if high-order discriminants are required. The second
scenario is well suited to sparse LDA, as it cleanly separates classes 1 and
2 from the rest (bottom left), and reveals the features responsible for this
separation (bottom right).
8.4.4 Optimal Scoring
A third approach to the derivation of linear discriminant analysis is called
optimal scoring. It is based on a recasting of the problem in terms of a multivariate
linear regression, where the codes for the output classes are chosen
“optimally,” as we detail next. Suppose that the membership of the samples
are coded using a binary-valued N × K indicator matrix Y, with entries
yik =
(
1 if observation i belongs to class k
0 otherwise.
Using this notation, optimal scoring involves solving the sequence of problems
for k = 1, . . . ,K, each of the form
(bk, bk) = arg min
k2Rp,k2RK
 1
N kYk − Xkk22

(8.41)
such that T
k YTYk = 1 and T
k YTYj = 0 for all j = 1, 2, . . . , k − 1.
The optimal solution bk of this problem turns out to be proportional to the
solution of the Fisher linear discriminant criterion (8.39) (Breiman and Ihaka
1984, Hastie et al. 1995). This equivalence is not too surprising. With just
K = 2 classes, it is well known that the linear regression of a binary response
˜y = Y (with arbitrary coding ) on X gives the same coefficient vector as
linear discriminant analysis (up to a proportionality factor). For example, see
Exercise 4.2 of Hastie et al. (2009). With more than two classes, a regression
of ˜y` on X will differ according to how we assign numerical scores `k to
the classes. We obtain the particular solution from linear regression that is
equivalent to linear discriminant analysis by optimizing over the choice of
scores, as in the problem (8.41).
As with the other methods for sparse discriminant analysis, adding an
`1-penalty to the criterion (8.41) yields the modified optimization problem
minimize
k2Rp,k2RK
 1
N kYk − Xkk22
+ T
k 
k + kkk1

(8.42)
such that T
k YTYk = 1 and T
k YTYj = 0 for all j = 1, 2, . . . , k − 1
(Leng 2008, Clemmensen, Hastie, Witten and Ersboll 2011). In addition to
the `1-penalty with nonnegative regularization weight , we have also added
a quadratic penalty defined by a positive semidefinite matrix 
, equivalent
226 SPARSE MULTIVARIATE METHODS
to the elastic net penalty in the special case 
 = 
I. The resulting discriminant
vectors will be sparse if the regularization weight  on the `1-
penalty is sufficiently large. At the other extreme, if  = 0, then minimizing
the criterion (8.42) is equivalent to the penalized discriminant analysis proposal
of Hastie et al. (1995). Although the criterion is nonconvex (due to the
quadratic constraints), a local optimum can be obtained via alternating minimization,
using the elastic net to solve for . In fact, if any convex penalties
are applied to the discriminant vectors in the optimal scoring criterion (8.41),
then it is easy to apply alternating minimization to solve the resulting problem.
Moreover, there is a close connection between this approach and sparse
Fisher LDA (8.40). In particular, they are essentially equivalent if we take
e = bw + 
. The qualification “essentially” is needed due to nonconvexity:
we can only say that a stationary point for the one problem is also a stationary
point for the other (see Exercise 8.22 for details).
Whether one approaches the sparse discriminant problem through Fisher
LDA (8.40) or optimal scoring (8.42) depends on the nature of the problem.
When p  N and the features are not structured—a category containing
many genomic problems—it is most attractive to set ˜w equal to diag(ˆw).
Since this matrix is positive definite, we can take 
 = 0, and the resulting
problem is easily solved via the soft-thresholding algorithm for penalized matrix
decomposition. When the problem has a spatial or temporal structure,
the matrix 
 can be chosen to encourage spatial or temporal smoothness of
the solution. In this case the optimal scoring approach is attractive, since the
quadratic term can be absorbed into the quadratic loss. Otherwise, the matrix

 can be chosen to be a diagonal matrix, as in the next example, and again
optimal scoring is convenient. Both methods are implemented in packages
in R: penalizedLDA (Witten 2011) for the criterion (8.40), and sparseLDA
(Clemmensen 2012) for the criterion (8.42).
8.4.4.1 Example: Face Silhouettes
We illustrate sparse discriminant analysis based on the objective function
(8.42) with a morphometric example taken from Clemmensen et al.
(2011). The dataset consisting of 20 adult male and 19 adult female facesilhouettes.
Following the work of Thodberg and Olafsdottir (2003), we apply
a minimum description length (MDL) approach to annotate the silhouettes,
and then perform Procrustes’ alignment on the resulting 65 MDL landmarks
of (x, y)-coordinates. These 65 pairs are vectorized resulting in p = 130 spatial
features. We set 
 = I in the criterion (8.42); in this case the spatial features
are already smooth, and the ridge penalty I is sufficient to deal with the strong
spatial autocorrelations. For training, we used 22 of the silhouettes (11 female
and 11 male), which left 17 silhouettes for testing (8 female and 9 male). The
left and middle panels of Figure 8.8 illustrate the two classes of silhouettes.
Leave-one-out cross validation was performed on the training data, estimating
an optimal value of  that yielded 10 nonzero features. Since there are
SPARSE CLUSTERING 227
Figure 8.8 The silhouettes and the 65 (x, y)-coordinates for females (left) and males
(middle). Right: The mean shape of the silhouettes, and the 10 (x, y)-coordinates in
the SDA model. The superimposed dots indicate the landmarks retained in the sparse
discriminant vector. The arrows illustrate the directions of the differences between
male and female classes.
two classes, there is only one sparse direction. The nonzero weights are shown
in the right panel of Figure 8.8. The few landmarks included in the model
are placed near high curvature points in the silhouettes, suggesting that the
important gender differences are located in these regions. The training and
test classification rates were both 82%.
8.5 Sparse Clustering
In this section, we discuss methods for clustering observations that employ
sparsity to filter out the uninformative features. We first give a brief background
on clustering; more details can be found, for example, in Hastie et al.
(2009, Chapter 14).
8.5.1 Some Background on Clustering
Suppose we wish to group or cluster a collection of N observations on p features,
where p  N. Our goal is to find groups of observations that are similar
with respect to the p features. A standard method for doing this is called “hierarchical
clustering.” More precisely, we are referring to agglomerative (or
bottom-up) hierarchical clustering. This method starts with the individual
observations, and then merges or agglomerates the pair that are closest according
to some metric, with the Euclidean distance over the p features being
one common choice. This process is continued, with the closest pair grouped
together at each stage. Along the way, we consider merging not only individual
pairs of observations, but also merging clusters of observations that were
created at previous steps, with individual observations or other clusters. For
this, we need to define a linkage measure—the distance between two clusters.
Some common choices include average linkage, which define the distance between
two clusters as the average distance between any two observations, one
in each cluster; complete linkage, which uses the maximum pairwise distance;
and single linkage, which uses the minimum pairwise distance.
228 SPARSE MULTIVARIATE METHODS
8.5.1.1 Example: Simulated Data with Six Classes
The top panel of Figure 8.9 shows an example of hierarchical clustering applied
to some artificial data with 120 observations and 2000 features. The
figure shows the result of hierarchical clustering using Euclidean distance and
complete linkage. The clustering tree or dendrogram summarizes the sequence
of merges, leading to a single cluster at the top. The colors of the leaves of
the tree were not used in the clustering, and are explained below.
Now suppose that the observations vary only over a subset of the features.
Then we would like to isolate that subset both for interpretation and to improve
the clustering. In the top panel of Figure 8.9, the data were actually
generated so that the average levels of the first 200 features varied over six
predefined classes, with the remaining 1800 features being standard Gaussian
noise. These classes are not used in the clustering, but after carrying out the
clustering, we have colored the leaves of the dendrogram according to the true
class. We see that hierarchical clustering is confused by the uninformative
features, and does a poor job of clustering the observations into classes. In
this instance we would like to isolate the informative subset of features both
for interpretability and to improve the clustering. One way of doing that is
described next.
8.5.2 Sparse Hierarchical Clustering
We now describe an approach that introduces sparsity and feature selection
to this problem. Given a data matrix X 2 RN×p, standard clustering based
on Euclidean distance uses the dissimilarity measure Di,i0 = Pp
j=1 di,i0,j with
di,i0,j = (xij − xi0j)2. The idea here is to find a set of feature weights wj  0
and use these to define a weighted dissimilarity measure ˜Di,i0 = Pp
j=1 wjdi,i0,j ;
we want each weight to reflect the importance of that feature. Finally, this
modified dissimilarity matrix is used as input into hierarchical clustering.
Denote by  the N2 × p matrix with column j containing the N2 pairwise
dissimilarities for feature j. Then 1 is the vectorized version of Di,i0 ,
and likewise w the vectorized version of ˜Di,i0 . We now seek the vector w,
subject to sparsity and normalization restrictions, that recovers most of the
variability in . This requirement leads to the penalized matrix decomposition
problem (Witten et al. 2009) (see Section 7.6):
maximize
u2RN2
, w2Rp

uTw
	
subject to kuk2  1, kwk2  1,
kwk1  s, and w  0.
(8.43)
Notice that wj is a weight on the dissimilarity matrix for feature j. Given the
optimal solution bw, we rearrange the elements of w into a N × N matrix,
and perform hierarchical clustering on this reweighted dissimilarity matrix.
The result is a sparse hierarchical clustering of the data. In Figure 8.9, we see
that sparse clustering isolates the informative features (bottom panel) and
SPARSE CLUSTERING 229
58 62 66 70
Standard clustering
0.000 0.010 0.020
Sparse clustering
0 500 1000 1500 2000
0.00 0.04 0.08 0.12
Feature
Feature weight
Estimated feature weights
Figure 8.9 Standard and sparse clustering applied to a simulated example. The
data were generated so that the average levels of the first 200 features varied over
six predefined classes, while the remaining 1800 features were noise features with the
same distribution over the classes. The top two panels show the result of standard
hierarchical clustering and sparse clustering, respectively. We used complete linkage
in each case. The class of each sample is indicated by the color of each leaf, and was
not used by the clustering procedures. The bottom panel shows the estimated weight
given to each feature by the sparse clustering procedure.
230 SPARSE MULTIVARIATE METHODS
uses this information to correctly cluster the observations into the predefined
groups (middle panel).
8.5.3 Sparse K-Means Clustering
Another commonly used method of clustering is called “K-means.” Here we
predefine the number of groups K and then try to partition the observations
into K homogeneous groups. Each group is summarized by a centroid, with
each observation assigned to the group with the closest centroid.
In detail, the K-means algorithm maintains a partition C = {C1, . . . ,CK of the index set } {1, 2, . . . ,N}, where subset Ck corresponds to those observations
currently assigned to class k. It chooses these partitions by minimizing
the within cluster sum of squares:
W(C) =
XK
k=1
X
i2Ck
kxi − ¯xkk22
. (8.44)
Here xi is the ith observation and ¯xk is a p-vector equal to the average of all
observations in cluster k. The collection {¯xk}K1
is referred to as the codebook
in the compression literature. The encoder  (i) assigns each observation xi to
the cluster k whose centroid is closest to it. Hence Ck = {i :  (i) = k}. The
standard algorithm for K-means clustering alternates over optimizing for C and {¯x1, . . . , ¯xK}, and is guaranteed to find a local minimum of W(C). Since
X
i,i02Ck
kxi − xi0k22
= 2Nk
X
i2Ck
kxi − ¯xkk22
, (8.45)
with Nk = |Ck|, one can alternatively derive K-means clustering using a
squared Euclidean dissimilarity matrix Di,i0 . For general dissimilarity matrices,
K-medoids clustering is a natural generalization (Hastie et al. 2009, for
example).
It might seem reasonable to define as a criterion for sparse K-means clustering
the minimum of the weighted within-cluster sum of squares:
minimize
C, w2Rp
8<
:
Xp
j=1
wj
XK
k=1
1
Nk
X
i,i02Ck
di,i0,j

9=
;.
We still need to add constraints on w, to make the problem meaningful. Adding
the constraints kwk2  1, kwk1  s as well as the nonnegativity constraint
w  0 makes the problem convex in w, but leads to the pathological solution
bw = 0. On the other hand, the triplet of constraints kwk2  1, kwk1  s,w  0
would lead to a potentially useful solution, but make the problem nonconvex
in w.
Witten and Tibshirani (2010) proposed a modified criterion that focuses
SPARSE CLUSTERING 231
instead on the between-cluster sum of squares:
maximize
C, w2Rp
8<
:
Xp
j=1
wj
0
@ 1
N
XN
i=1
XN
i0=1
di,i0,j −
XK
k=1
1
Nk
X
i,i02Ck
di,i0,j
1
A
9=
;
subject to kwk2  1, kwk1  s,w  0.
(8.46)
When wj = 1 for all j, we can see from condition (8.45) that the second
term is equal to 2W(C), and hence this approach is equivalent to K-means.
This problem is now convex in w and generally has an interesting solution. It
can be solved by a simple alternating algorithm. With C = (C1, ...,CK) fixed,
the minimization over w is a convex problem, with solutions given by softthresholding.
With w fixed, optimization with respect to C leads to a weighted
K-means clustering algorithm. Details are given in Exercise 8.11.
8.5.4 Convex Clustering
The method of K-means clustering and its sparse generalization lead to problems
that are biconvex but not jointly convex, and hence it is difficult to
guarantee that a global solution has been attained. Here we present a different
formulation of clustering that yields a convex program, and represents
an interesting alternative to K-means and hierarchical clustering. Unlike the
methods of the previous section which use sparsity to do feature selection, this
method uses a form of sparsity to determine the number and memberships of
the clusters.
In this approach, each of the N observations xi 2 Rp is assigned a prototype
ui 2 Rp. We then minimize the objective function
J(u1, u2, . . . , uN) = 1
2
XN
i=1 kxi − uik2 + 
X
i<i0
wii0kui − ui0kq (8.47)
for some fixed   0, and some q-norm (typically q = 1 or q = 2). This
criterion seeks prototypes that are close to the data points, but not too far
from one another. The weights wii0 can be equal to 1, or can be a function
of the distance between observations i and i0. We note that this problem is
convex for q  1. Consider for example the natural choice q = 2 (group lasso).
Then the penalty term shrinks prototype vectors toward each other, and the
distance between many pairs will be equal to zero for a sufficiently large value
of .
Each distinct prototype bui in the solution represents a cluster; however,
as shown in the example of Figure 8.10, we should not think of it as a typical
prototype or centroid of that cluster. In this example, there are two classes
each containing 50 spherical Gaussian data points, with their means separated
by three units in both directions. Here we used q = 2 and weight function
wii0 = exp(−kxi − xi0k2). The colors in the right panel coincide with the
232 SPARSE MULTIVARIATE METHODS
0 2 4
−1 0 1 2 3 4
0 2 4
−1 0 1 2 3 4
X1 X1
X2
X2
 = 3.27  = 12.65
Figure 8.10 Convex clustering applied to data generated from two spherical Gaussian
populations separated by three units in each direction. We show two solutions
from a path of 50 values of ; the solution on the right was the smallest value of 
that yielded two clusters, and in this case identified the true clusters. Points xi are
associated with prototypes bμi of the same color. The estimated prototypes need not
be close to the centroids of their clusters.
true clusters; further details are given in the caption. The convexity of the
objective function as well as its ability to choose the number of clusters and
the informative features, makes this approach attractive.
The next example is taken from Chi and Lange (2014), on the problem of
clustering mammals based on their dentition. Eight different kinds of teeth
were counted for each of 27 mammals: the number of top incisors, bottom
incisors, top canines, bottom canines, top premolars, bottom premolars, top
molars, and bottom molars. Figure 8.11 shows the resulting clustering path
over  using kernel-based weights wii0 . For visualization, the prototypes have
been projected onto the first two principal components. The continuous path
of solutions provides an appealing summary of the similarity among the mammals.
Both these examples were produced using the cvxcluster package in
R (Chi and Lange 2014). The path of solutions creates a tree, which in this
example is rather similar to that produced by hierarchical clustering with
average linkage.
Bibliographic Notes
Jolliffe et al. (2003) proposed the original SCoTLASS criterion (8.7) for sparse
PCA; the reformulation and alternating updates (8.9) were proposed by Witten
et al. (2009). d’Aspremont et al. (2007) proposed the semidefinite programming
relaxation (8.12) of the nonconvex SCoTLASS criterion; Amini and
BIBLIOGRAPHIC NOTES 233
oppossum
htailmole
commonmole
brownbat
shairbat
pigmybat
housebat
redbat
armadillo
pika
ssrabbit
beaver
graysquirrel
packrat
coyote
wolf
civetcat
raccoon
weasel
riverotter
seaotter
jaguar
furseal
walrus
ephantseal
elk
deer
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
−2
−1
0
1
2
−2 0 2 4
Principal Component 1
Principal Component 2
Figure 8.11 Mammal data: path of convex clustering solutions using the criterion
(8.47), and a grid of values of . As  increases, the prototypes unite to form
a smaller set.
Wainwright (2009) develop some theory for the variable selection properties of
this relaxation for sparse PCA. Zou et al. (2006) proposed the reconstructionbased
criterion (8.13). Johnstone (2001) studied the high-dimensional asymptotics
of ordinary PCA, and proposed the spiked covariance model (8.22).
Johnstone and Lu (2009) and Birnbaum et al. (2013) study various types
of two-stage procedures for estimating sparse principal components. Birnbaum
et al. (2013) and Vu and Lei (2012) derive minimax lower bounds on
`2-estimation error for sparse PCA when the eigenvectors belong `q-balls.
Ma (2010, 2013) and Yuan and Zhang (2013) have studied iterative algorithms
for sparse PCA based on combining the power method with soft thresholding.
Berthet and Rigollet (2013) study the detection problem for high-dimensional
sparse PCA, and establish a computational hardness result related to the
random k-clique problem.
Olshausen and Field (1996) proposed the version of sparse coding discussed
in Section 8.2.5. There is a large literature on deep learning; see Le et al. (2012)
and references therein for some recent approaches.
There is a variety of papers that explore sparse canonical correlation analysis,
for example Parkhomenko, Tritchler and Beyene (2009), Waaijenborg,
234 SPARSE MULTIVARIATE METHODS
Vers´elewel de Witt Hamer and Zwinderman (2008), Hardoon and Shawe-
Taylor (2011), Parkhomenko et al. (2009), Witten et al. (2009), Witten and
Tibshirani (2009), and Lykou and Whittaker (2010). Dudoit, Fridlyand and
Speed (2002) provide comparison of different classification methods for microarray
data, including diagonal LDA. Nearest shrunken centroids was proposed
by Tibshirani, Hastie, Narasimhan and Chu (2001) and Tibshirani
et al. (2003). Sparse discriminant analysis from Fisher’s framework and optimal
scoring were explored in Trendafilov and Jolliffe (2007), Leng (2008),
Clemmensen et al. (2011), and Witten and Tibshirani (2011). Minorization
algorithms are discussed in Lange, Hunter and Yang (2000), Lange (2004),
and Hunter and Lange (2004). Sparse hierarchical and k-means clustering are
presented in Witten and Tibshirani (2010), while convex clustering was proposed
by Pelckmans, De Moor and Suykens (2005) and Hocking, Vert, Bach
and Joulin (2011).
Exercises
Ex. 8.1 In this exercise, we consider some elementary properties of principal
component analysis.
(a) Show that the first principal component is a maximal eigenvector of the
sample covariance matrix 1
NXTX.
(b) Suppose that the rows of X, denoted {x1, . . . , xN} are drawn i.i.d. according
to a zero-mean distribution P, and suppose that  = Cov(x) has
a unique maximal eigenvalue . Explain why, for large sample size N, one
might expect bv to approach
v = arg max
kvk2=1
Var(vT x), where x  P. (8.48)
Ex. 8.2 Consider the principal component criterion (8.1), and the definition
of the vectors v1, v2, and so on.
(a) Show that the principal components zj are mutually uncorrelated.
(b) Show that instead of using orthogonality of the vj to define the sequence
of principal component directions, we can instead use the uncorrelatedness
of the zj .
Ex. 8.3 Consider the reconstruction error objective (8.4) with μ = 0.
(a) For fixed Vr, show that the optimal choice of the reconstruction weights
is i = VT
r xi for each i = 1, . . . ,N.
(b) Use part (a) to show that the optimal Vr maximizes the criterion
VT
r XTXV, and conclude that it can be obtained via the truncated SVD
(as described in the main text).
EXERCISES 235
Ex. 8.4 Consider criterion (8.8) and Algorithm 8.1 for finding a solution. By
partially maximizing w.r.t. u with kuk2  1, show that any stationary value
of v is also a stationary value for the SCoTLASS criterion (8.7).
Ex. 8.5 Consider the problem
minimize
u,v,d kX − duvT kF
subject to kuk1  c1, kvk1  c2, kuk2 = 1, kvk2 = 1, d  0,
(8.49)
where X is N × p, and assume 1  c1  pN, 1  c2  pp. Show that a
solution u1, v1, d1 is also the solution to the following problem:
maximize
u,v
uTXv
subject to kuk1  c1, kvk1  c2, kuk2 = 1, kvk2 = 1,
(8.50)
and d1 = uT1 Xv1.
Ex. 8.6 In this exercise, we explore some properties of the SCoTLASS criterion
(8.7).
(a) Use the Cauchy–Schwarz inequality to show that a fixed point of Algorithm
8.1 is a local minimum of the SCoTLASS criterion (8.7).
(b) Notice that the Cauchy–Schwarz inequality implies that
vTXTXv 
(v(m)TXTXv)2
v(m)TXTXv(m)
, (8.51)
and equality holds when v = v(m). So (v(m)TXTXv)2
v(m)TXTXv(m) minorizes vTXTXv at
v(m). Hence show that the MM algorithm (Section 5.8) using this minorization
function yields Algorithm 8.1.
Ex. 8.7 Show that the solution to the problem (8.15), with the additional
constraint kk1  t, is also a solution to the SCoTLASS problem (8.7).
Ex. 8.8 Consider the problem
minimize
: kk2=1
XN
i=1 kxi − zik22
, (8.52)
where the vectors {xi}Ni
=1 and  are all p-dimensional, and the variables
{zi}N
i=1 are scalars. Show that the optimal solution is unique and given by
b = XT z
kXT zk2 .
Ex. 8.9 Show that the vectors uk in (8.17) solve the multifactor sparse PCA
problem (8.16).
236 SPARSE MULTIVARIATE METHODS
Ex. 8.10 Consider the reconstruction criterion (8.13) for sparse principal components.
(a) With V fixed, derive the solution for .
(b) Show that when the 1k = 0 for all k the iterations are stationary w.r.t.
any set of k principal components of X; in particular, if the algorithm is
started at the largest k principal components, it will not move from them.
(c) Show under the conditions in (b) that the criterion is maximized by
 = V and both are equal to Vk, the matrix consisting of the largest k
principal components of X.
(d) For a solution Vk in (c), show that VkR is also a solution, for any k ×k
orthogonal matrix R.
Consequently, this version of sparse principal components is similar to the
Varimax method (Kaiser 1958) of rotating factors to achieve sparsity.
Ex. 8.11 Sparse K-means clustering algorithm. Consider the objective function
(8.46).
(a) Show that with w fixed, optimization with respect to C = (C1, ...,CK)
yields the problem
minimize
C1,...,CK
8<
:
Xp
j=1
wj(
XK
k=1
1
Nk
X
i,i02Ck
(xij − xi0j)2)
9=
;. (8.53)
This can be thought of as K-means clustering with weighted data. Give a
sketch of its solution.
(b) With C1, ...,CK fixed, we optimize with respect to w yielding
maximize
w2Rp
8<
:
Xp
j=1
wj
0
@ 1
N
XN
i=1
XN
i0=1
(xij − xi0j)2 −
XK
k=1
1
Nk
X
i,i02CK
(xij − xi0j)2
1
A
9=
;
such that kwk2 = 1, kwk1  s, and wj  0. (8.54)
This is a simple convex problem of the form
maximize
w2Rp

wT a
	
such that kwk2 = 1, kwk1  s, and w  0. (8.55)
Give the details of its solution.
Ex. 8.12 Consider the optimization problem:
minimize
A,B2Rp×m
(
XN
i=1 kxi − ABT xik2
)
, (8.56)
where xi 2 Rp, i = 1, . . . ,N are the rows of X, and m < min(N, p). Show
that the solution satisfies ˆA
ˆBT =
V
m
VTm
, where Vm is the matrix of the first
m right-singular vectors of X.
EXERCISES 237
Ex. 8.13 Consider the sparse encoder specified in the optimization problem
(8.21). Develop a simple alternating algorithm for solving this problem.
Give some details for each step.
Ex. 8.14 Canonical correlation via alternating regression: Consider two random
vectors X 2 Rm1 and Y 2 Rm2 with covariance matrices 11 and 22,
respectively, and cross-covariance 12. Define L = −1
2
11 12−12
22 . Denote by

i and i the left and right singular vectors of L, ordered by their singular
values i.
(a) Show that the vectors 1 and 1 maximizing Corr(X, Y ) are given by
1 = −1
2
11 
1
1 = −12
22 1,
(8.57)
and the maximal correlation is 1.
(b) Now consider the analogous problem based on data matrices X and Y of
dimension N × p and N × q, respectively, each centered to have zero-mean
columns. In this setting, the canonical correlation estimates are obtained
simply by replacing 11, 22, and 12 by their sample estimates.
Based on this formulation, show that the optimal sample canonical vectors
are given by 1 = (XTX)−1
2 
1 and 1 = (YTY)−1
2 1, where 
1 and 1 are
the leading left and right singular vectors of the matrix
(XTX)−12
XTY(YTY)−12 .
(c) Denote the first canonical variates by z1 = X1 and s1 = Y1, both
N-vectors. Let HX = X(XTX)−1XT be the projection onto the column
space of X; likewise HY . Show that
HXs1 = 1z1, and
HY z1 = 1s1.
Consequently, alternately regressing onto X and Y until convergence yields
a solution of the maximal canonical correlation problem.
Ex. 8.15 In Exercise 8.14, we found that the leading pair of canonical variates
can be found by alternating least-squares regressions. Having solved for the
leading canonical variates, how could you modify this procedure to produce
the second pair of canonical variates (z2, s2)? Propose a modification and
prove that it works. Show how to extend this approach to find all subsequent
pairs.
Ex. 8.16 CCA via optimal scoring: Given data matrices X and Y as in Exercise
8.14, both with mean-centered columns and both with full column rank,
consider the problem
minimize
, kY − Xk22
subject to 1
N kYk2 = 1. (8.58)
238 SPARSE MULTIVARIATE METHODS
(a) Characterize the solution to this problem, by first solving for  with 
fixed, and then solving for .
(b) Show that the optimal solution is given by b = 1 and b = 11, where
1 and 1 are the first pair of canonical vectors, and 1 the largest canonical
correlation.
(c) Show in addition that kY1 − X1k22
= 1 − 21
. This equivalence shows
that solving the optimal scoring problem is equivalent to solving the CCA
problem.
(d) Describe how to find subsequent canonical solutions, uncorrelated with
the earlier solutions. Show how this can be achieved by transforming the
data matrices X and Y.
(e) Does the problem change if we include a constraint kXk2 = 1?
Ex. 8.17 Low-rank CCA: Suppose that at least one of the matrices in Exercise
8.14 or 8.16 do not have full column rank. (For instance, this degeneracy
will occur whenever N < min(p, q).)
(a) Show that 1 = 1, and the CCA problem has multiple optima.
(b) Suppose that Y is full column rank, but X is not. You add a ridge constraint
to (8.58), and solve
minimize
, kY − Xk22
+ kk22
subject to kYk2 = 1. (8.59)
Is this problem degenerate? Characterize the solution.
(c) Show that the solution in (b) is equivalent to applying CCA to X and
Y, except that the optimal solution b satisfies the normalization condition
1
N
bT (XTX+I)b = 1, corresponding to normalization by a type of ridged
covariance estimate.
Ex. 8.18 For data matrices X and Y with centered columns, consider the
optimization problem
maximize
,
n
dCov(X,Y) − 1kk22
− 2kk22
− 0
1kk1 − 0
2kk2
o
. (8.60)
Using the results of Exercise 8.14, outline how to solve this problem using
alternating elastic-net fitting operations in place of the least-squares regressions.
Ex. 8.19 Sparse canonical correlation analysis: Consider the optimal scoring
problem (8.58) from Exercise 8.16, but augmented with `1 constraints:
minimize
,

kY − Xk22
+ 1kk1 + 2kk1
	
subject to kXk2 = 1. (8.61)
Using the results of Exercises 8.14, 8.16, and 8.17, outline how to solve this
problem using alternating elastic-net regressions in place of the least-squares
regressions.
EXERCISES 239
Ex. 8.20 Consider the multivariate Gaussian setup in Section 8.4.1, but assume
a different covariance matrix k in each class.
(a) Show that the discriminant functions k are quadratic functions of x.
What can you say about the decision boundaries?
(b) Suppose that the covariance matrices k are assumed to be diagonal,
meaning that the features X are conditionally independent in each class.
Describe the decision boundary between class k and ` for this naive Bayes
classifier.
Ex. 8.21 This exercise relates to the nearest shrunken centroids problem of
Section 8.4.2. Consider the `1-regularized criterion
minimize
¯μ2R
p
k2R
p,k = 1, . . . , p
8<
:
1
2
XK
k=1
X
i2Ck
Xp
j=1
(xij − ¯μj − jk)2
s2j
+ 
XK
k=1
Xp
j=1
pNk
sj |jk|
9=
;.
(8.62)
Here we have decomposed each class mean into an overall mean plus a classwise
contrast from the overall mean, and we have weighted the penalties by
the class sizes and within-class standard deviations for each feature.
(a) Show that replacing ¯μj by ¯xj , corresponding to the overall mean for
feature j, yields the shrinkage scheme (8.35a), apart from a term 1/N in
mk.
(b) Show that part (a) does not yield a solution to the criterion (8.33) unless
we restrict ¯μj as above.
(c) A more natural criterion would add the constraints PK
k=1 jk = 0 for
all j = 1, . . . p. Discuss the solution to this problem, and whether it can
coincide with the solution from part (a).
Ex. 8.22 Show that the penalized Fisher’s discriminant problem (8.40) and
the penalized optimal scoring problem (8.42) are equivalent in the sense that
any stationary point for one problem is also a stationary point for the other
problem. (Clemmensen et al. 2011, Witten and Tibshirani 2011).

Chapter 9
Graphs and Model Selection
9.1 Introduction
Probabilistic graphical models provide a useful framework for building parsimonious
models for high-dimensional data. They are based on an interplay
between probability theory and graph theory, in which the properties of an
underlying graph specify the conditional independence properties of a set of
random variables. In typical applications, the structure of this graph is not
known, and it is of interest to estimate it based on samples, a problem known
as graphical model selection. In this chapter, we discuss a variety of methods
based on `1-regularization designed for this purpose.
9.2 Basics of Graphical Models
We begin by providing a brief introduction to the basics of graphical models;
for more details, we refer the reader to the references cited in the bibliographic
notes at the end of the chapter. Any collection X = (X1,X2, . . . ,Xp) of
random variables can be associated with the vertex set V = {1, 2, . . . , p of some underlying graph. The essential idea of a graphical model is to us}e
the structure of the underlying graph—either its clique structure or its cut set
structure—in order to constrain the distribution of the random vector X. We
now make these notions more precise.
9.2.1 Factorization and Markov Properties
An ordinary graph G consists of a vertex set V = {1, 2, . . . , p}, and an edge
set E  V × V . In this chapter, we focus exclusively on undirected graphical
models, meaning that there is no distinction between an edge (s, t) 2 E,
and the edge (t, s). In contrast, directed acyclic graphs (DAGs) are the most
popular form of graph in which the edges have directionality. In general, such
directed graphs are more difficult to handle than undirected graphs, and we
do not cover them here. But we do note that some methods for computation
in undirected graphs can be helpful in the DAG case: see the bibliographic
notes for some references.
A graph clique C  V is a fully-connected subset of the vertex set, meaning
241
242 GRAPHS AND MODEL SELECTION
that (s, t) 2 E for all s, t 2 C. A clique is said to be maximal if it is not strictly
contained within any other clique. For instance, any single vertex {s} is itself
a clique, but it is not maximal unless s is an isolated vertex (meaning that
it participates in no edges). We use C to denote the set of all cliques in the
graph, both maximal and nonmaximal; see Figure 9.1(a) for an illustration of
graph cliques.
3
4
5
1
2
3 4
5
6
7
A B C
D
A
B
S
(a) (b)
Figure 9.1 (a) Illustration of cliques in a graph: each of the four subsets indicated
are cliques. Sets A and B are 3-cliques, whereas C and D are 2-cliques, more commonly
known as edges. All of these cliques are maximal. (b) Illustration of a vertex
cut set S: with the vertices in S removed, the graph is broken into two subcomponents
A and B.
9.2.1.1 Factorization Property
We now describe how the clique structure of a graph can be used to constrain
the probability distribution of the random vector (X1, . . . ,Xp) indexed by
the graph vertices. For a given clique C 2 C, a compatibility function  C is
a real-valued function of the subvector xC := (xs, s 2 C), taking positive
real values. Given a collection of such compatibility functions, we say that the
probability distribution P factorizes over G if it has the decomposition
P(x1, . . . , xp) = 1
Z
Y
C2C
 C(xC). (9.1)
Here the quantity Z, known as the partition function, is given by the sum
Z = P
x2Xp
Q
C2C  C(xC). Thus, it ensures that P is properly normalized,
and so defines a valid probability distribution. As a particular example, any
probability distribution that factorizes over the graph in Figure 9.1(a) must
have the form
P(x1, . . . , x7) = 1
Z
 123(x1, x2, x3)  345(x3, x4, x5)  46(x4, x6)  57(x5, x7),
(9.2)
for some choice of the compatibility functions { 123,  345,  46,  57}.
BASICS OF GRAPHICAL MODELS 243
A factorization of the form (9.1) is practically significant, since it can lead
to substantial savings, in both storage and computation, if the clique sizes
are not too large. For instance, if each variable Xs is binary, then a generic
probability distribution over the vector X 2 {−1, +1}p requires specifying
2p − 1 nonnegative numbers, and so grows exponentially in the graph size.
On the other hand, for a clique-based factorization, the number of degrees of
freedom is at most |C| 2c, where c is the maximum cardinality of any clique.
Thus, for the clique-based factorization, the complexity grows exponentially
in the maximum clique size c, but only linearly in the number of cliques
|C|. Luckily, many practical models of interest can be specified in terms of
cliques with bounded size, in which case the clique-based representation yields
substantial gains.
9.2.1.2 Markov Property
We now turn to an alternative way in which the graph structure can be used
to constrain the distribution of X, based on its cut sets (see Figure 9.1(b)).
In particular, consider a cut set S that separates the graph into disconnected
components A and B, and let us introduce the symbol ?? to denote the relation
“is conditionally independent of.” With this notation, we say that the random
vector X is Markov with respect to G if
XA ?? XB | XS for all cut sets S  V . (9.3)
The graph in Figure 9.1(b) is an example showing this conditional independence
relation.
Markov chains provide a particular illustration of this property; naturally,
they are based on a chain-structured graph, with edge set
E = {(1, 2), (2, 3), . . . , (p − 1, p)}.
In this graph, any single vertex s 2 {2, 3, . . . , p−1} forms a cut set, separating
the graph into the past P = {1, . . . , s − 1} and the future F = {s + 1, . . . , p}.
For these cut sets, the Markov property (9.3) translates into the fact that, for a
Markov chain, the future XF is conditionally independent of the past XP given
the present Xs. Of course, graphs with more structure have correspondingly
more complex cut sets, and thus more interesting conditional-independence
properties.
9.2.1.3 Equivalence of Factorization and Markov Properties
A remarkable fact, known as the Hammersley–Clifford theorem, is that for
any strictly positive distribution (i.e., for which P(x) > 0 for all x 2 Xp), the
two characterizations are equivalent: namely, the distribution of X factorizes
according to the graph G (as in Equation (9.1)) if and only if the random
vector X is Markov with respect to the graph (as in Equation (9.3)). See the
bibliographic section for further discussion of this celebrated theorem.
244 GRAPHS AND MODEL SELECTION
9.2.2 Some Examples
We present some examples to provide a concrete illustration of these properties.
9.2.2.1 Discrete Graphical Models
We begin by discussing the case of a discrete graphical model, in which random
variables Xs at each vertex s 2 V take values in a discrete space Xs. The
simplest example is the binary case, say with Xs = {−1, +1}. Given a graph
G = (V,E), one might consider the family of probability distributions
P(x1, . . . , xp) = exp
X
s2V
sxs +
X
(s,t)2E
stxsxt − A()
	
, (9.4)
parametrized by the vector  2 R|V |+|E|. For later convenience, here we have
introduced the notation A() = log Z(), reflecting the dependence of the
normalization constant on the parameter vector . This family of distributions
is known as the Ising model, since it was originally used by Ising (1925) to
model the behavior of magnetic materials; see the bibliographic section for
further discussion. Figure 9.2 shows simulations from three different Ising
models.
(a) (b) (c)
Figure 9.2 Samples generated from Ising models based on a graph with p = 1024
nodes. For illustrative purposes, the resulting vector x 2 {+1, 1}1024 is plotted as
a 32 × 32 binary image. Panels (a) through (c) correspond to three very different
distributions. The samples were drawn by running the Gibbs sampler.
The Ising model has been used to model social networks, for example
the voting behavior of politicians. In this context, the random vector
(X1,X2, . . . ,Xp) represents the set of votes cast by a set of p politicians on
a particular bill. We assume that politician s provides either a “yes” vote
(Xs = +1) or a “no” vote (Xs = −1) on the bill. With the voting results
for N bills, we can make inferences on the joint distribution of X. In the factorization
(9.4), a parameter s > 0 indicates that politician s is more likely
(assuming fixed values of other politicians’ votes) to vote “yes” on any given
bill, with the opposite interpretation holding in the case s < 0. On the other
BASICS OF GRAPHICAL MODELS 245
hand, for any given pair s, t that are joined by an edge, a weight st > 0
means that with the behavior of all politicians held fixed, politicians s and
t are more likely to share the same vote (i.e., both yes or both no) than to
disagree; again, the opposite interpretation applies to the setting st < 0. See
Figure 9.7 on page 257 for an application to voting-record data.
Many extensions of the Ising model are possible. First, the factorization
(9.4) is limited to cliques of size at most two (i.e., edges). By allowing
terms over cliques of size up to size three, one obtains the family of models
P(x) = exp
X
s2V
sxs +
X
(s,t)2E
stxsxt +
X
(s,t,u)2E3
stuxsxtxu − A()
	
.
(9.5)
where E3 is some subset of vertex triples. This factorization can be extended
up to subsets of higher order, and in the limit (where we allow an interaction
term among all p variables simultaneously), it is possible to specify the distribution
of any binary vector. In practice, of most interest are models based
on relatively local interactions, as opposed to such a global interaction.
Another extension of the Ising model is to allow for non-binary variables,
for instance Xs 2 {0, 1, 2, . . . ,m− 1} for some m > 2. In this case, one might
consider the family of distributions
P(x1, . . . , xp) = exp
X
s2V
mX−1
j=1
s;jI[xs = j] +
X
(s,t)2E
stI[xs = xt] − A()
	
,
(9.6)
where the indicator function I[xs = j] takes the value 1 when xs = j, and
0 otherwise. When the weight st > 0, the edge-based indicator function
I[xs = xt] acts as a smoothness prior, assigning higher weight to pairs (xs, xt)
that agree. The model (9.6) has found many uses in computer vision, for
instance in image denoising and disparity computation problems.
All the models discussed here have a parallel life in the statistics and
biostatistics literature, where they are referred to as log-linear models for
multiway tables. However, in that setting the number of variables is typically
quite small.
In Section 9.4.3 we discuss a general class of pairwise-Markov models for
mixed data—allowing for both continuous and discrete variables.
9.2.2.2 Gaussian Graphical Models
Let X  N(μ,) be a Gaussian distribution in p dimensions, with mean
vector μ 2 Rp and covariance matrix :
Pμ,(x) = 1
(2) p2
det[] 1
2
e−12
(x−μ)T−1(x−μ). (9.7)
246 GRAPHS AND MODEL SELECTION
If we view the multivariate Gaussian distribution as a particular type of exponential
family, then (μ,) are known as the mean parameters of the family.
In order to represent the multivariate Gaussian as a graphical model, it is
convenient to consider instead its parametrization in terms of the so-called
canonical parameters, say a vector 
 2 Rp and  2 Rp×p. Any nondegenerate
multivariate Gaussian—meaning whenever  is strictly positive definite—can
be represented in the form
P
,(x) = exp
Xp
s=1

sxs −
1
2
Xp
s,t=1
st xsxt − A()

, (9.8)
where A() = −1
2 log det[/(2)], so that
R
P
,(x)dx = 1. Our choice of
the rescaling by −1/2 in the factorization (9.8) is to ensure that the matrix
 has a concrete interpretation. In particular, with this scaling, as shown in
Exercise 9.1, we have the relation  = −1, so that  corresponds to the
inverse covariance, precision or concentration matrix.
The representation (9.8) is especially convenient, because it allows us to
discuss the factorization properties directly in terms of the sparsity pattern
of the precision matrix . In particular, whenever X factorizes according to
the graph G, then based on the factorization (9.8), we must have st = 0 for
1
2
3
4
5
1 2 3 4 5
5
4
3
2
1
Zero pattern of 
(a) (b)
Figure 9.3 (a) An undirected graph G on five vertices. (b) Associated sparsity pattern
of the precision matrix . White squares correspond to zero entries.
any pair (s, t) /2 E, which sets up a correspondence between the zero pattern
of  and the edge structure E of the underlying graph. See Figure 9.3 for an
illustration of this correspondence.
9.3 Graph Selection via Penalized Likelihood
We now turn to the problem of graph selection, and the use of `1-regularized
likelihood methods for solving it. The problem itself is simply stated: suppose
GRAPH SELECTION VIA PENALIZED LIKELIHOOD 247
that we are given a collection X = {x1, . . . , xN} of samples from a graphical
model, but the underlying graph structure is unknown. How to use the data
to select the correct graph with high probability? Here we discuss the use of
likelihood-based methods in conjunction with `1-regularization for this purpose.
This section discusses methods based on the global likelihood function
of the graphical model. In the Gaussian case, this approach leads to tractable
methods for model selection based on a log-determinant convex program with
`1-regularization. On the other hand, in the discrete case, this approach is
computationally tractable only for relatively small graphs, or graphs with
special structure.
9.3.1 Global Likelihoods for Gaussian Models
We start with model selection for the Gaussian graphical model, a problem
that is also known as covariance selection. Since our primary interest is in
estimating the graph structure, we assume that the distribution has mean zero,
so that under the parametrization (9.8), we need only consider the symmetric
precision matrix  2 Rp×p.
Suppose X represents samples from a zero-mean multivariate Gaussian
with precision matrix . Based on some straightforward algebra (see Exercise
9.2 for details), it can be seen that (up to a constant) the rescaled
log-likelihood L(;X) of the multivariate Gaussian takes the form
L(;X) = 1
N
XN
i=1
log P(xi)
= log det− trace(S), (9.9)
where S = 1
N
PN
i=1 xixTi
is the empirical covariance matrix. The log-determinant
function is defined on the space of symmetric matrices as
log det() =
(Pp
j=1 log(j()) if   0
−1; otherwise,
(9.10)
where j() is the jth eigenvalue of . In Exercise 9.2, we explore some additional
properties of this function. The objective function (9.9) is an instance
of a log-determinant program, a well-studied class of optimization problems.
It is strictly concave, so that the maximum—when it is achieved—must be
unique, and defines the maximum likelihood estimate bML, denoted MLE for
short.
By classical theory, the maximum likelihood estimate bML converges to
the true precision matrix as the sample size N tends to infinity. Thus, at least
in principle, one could use a thresholded version of bML to specify an edge set,
and thereby perform Gaussian graphical model selection. However, for problems
frequently arising in practice, the number of nodes p may be comparable
to or larger than the sample size N, in which case the MLE does not exist.
248 GRAPHS AND MODEL SELECTION
Indeed, the empirical correlation matrix S must be rank-degenerate whenever
N < p, which implies that the MLE fails to exist (see Exercise 9.2(c)). Hence
we must consider suitably constrained or regularized forms of the MLE. Moreover,
irrespective of the sample size, we may be interested in constraining the
estimated precision matrix to be sparse, and hence easier to interpret.
If we are seeking Gaussian graphical models based on relatively sparse
graphs, then it is desirable to control the number of edges, which can be
measured by the `0-based quantity
0() =
X
s6=t
I[st 6= 0], (9.11)
where I[st 6= 0] is a 0-1-valued indicator function. Note that by construction,
we have 0() = 2|E|, where |E| is the number of edges in the graph uniquely
defined by . We could then consider the optimization problem
b 2 arg max
0
0()k

log det() − trace(S)
	
. (9.12)
Unfortunately, the `0-based constraint defines a highly nonconvex constraint
set, essentially formed as the union over all
􀀀(p2
)
k

possible subsets of k edges.
For this reason, it is natural to consider the convex relaxation obtained by
replacing the `0 constraint with the corresponding `1-based constraint. Doing
so leads to the following convex program
b 2 arg max
0

log det− trace(S) − 1()
	
, (9.13)
where 1() = P
s6=t |st| is simply the `1-norm of the off-diagonal entries of
. The problem (9.13) can be formulated as an instance of a log-determinant
program; it is thus a convex program, often referred to as the graphical lasso.
Since this is a convex program, one can use generic interior point methods
for its solution, as in Vandenberghe, Boyd and Wu (1998). However this is not
efficient for large problems. More natural are first-order block coordinatedescent
approaches, introduced by d’Aspremont, Banerjee and El Ghaoui
(2008) and refined by Friedman, Hastie and Tibshirani (2008). The latter
authors call this the graphical lasso algorithm. It has a simple form which
also connects it to the neighborhood-based regression approach, discussed in
Section 9.4.
9.3.2 Graphical Lasso Algorithm
The subgradient equation corresponding to (9.13) is
−1 − S −  ·	 = 0, (9.14)
with the symmetric matrix 	 having diagonal elements zero,  jk = sign(jk)
if jk 6= 0, else  jk 2 [−1, 1] if jk = 0.
GRAPH SELECTION VIA PENALIZED LIKELIHOOD 249
We now consider solving this system by blockwise coordinate descent. To
this end we consider partitioning all the matrices into one column versus the
rest; for convenience we pick the last column:
 =
 11 12
T
12 22

, S =

S11 s12
sT12 s22

, etc. (9.15)
Denote byWthe current working version of −1, with partitions as in (9.15).
Then fixing all but the last row and column and using partitioned inverses,
(9.14) leads to
W11 − s12 +  ·  12 = 0, (9.16)
where  = −12/22. Here we have fixed the pth row and column: W11 is the
(p−1)×(p−1) block of −1, and s12 and 12 are p−1 nondiagonal elements
of the pth row and columns of S and . Finally 22 is the pth diagonal element
of . These details are derived in Exercise 9.6.1
It can be seen that (9.16) is equivalent to a modified version of the estimating
equations for a lasso regression. Consider the usual regression setup
with outcome variables y and predictor matrix Z. In that problem, the lasso
minimizes
1
2N (y − Z)T (y − Z) +  · kk1 (9.17)
The subgradient equations are
1
N ZTZ − 1
N ZT y +  · sign() = 0. (9.18)
Comparing to (9.16), we see that 1
N ZT y is the analog of s12, and 1
N ZTZ corresponds
toW11, the estimated cross-product matrix from our current model.
Thus we can solve each blockwise step (9.16) using a modified algorithm for
the lasso, treating each variable as the response variable and the other p − 1
variables as the predictors. It is summarized in Algorithm 9.1.
Friedman et al. (2008) use the pathwise-coordinate-descent approach to
solve the modified lasso problems at each stage, and for a decreasing series
of values for . [This corresponds to the “covariance” version of their lasso
algorithm, as implemented in the glmnet package in R and matlab (Friedman
et al. 2010b).]
From Equation (9.14) we see that the diagonal elements wjj of the solution
matrix W are simply sjj , and these are fixed in Step 1 of Algorithm 9.1.2
1On a historical note, it turns out that this algorithm is not block-coordinate descent
on  in (9.14) (as originally intended in Friedman et al. (2008)), but instead amounts to
a block coordinate-descent step for the convex dual of problem (9.13). This is implied in
Banerjee, El Ghaoui and d’Aspremont (2008), and is detailed in Mazumder and Hastie
(2012). The dual variable is effectively W = −1. These latter authors derive alternative
coordinate descent algorithms for the primal problem (see Exercise 9.7). In some cases, this
gives better numerical performance than the original graphical lasso procedure.
2An alternative formulation of the problem can be posed, where we penalize the diagonal
of  as well as the off-diagonal terms. Then the diagonal elements wjj of the solution matrix
are sjj + , and the rest of the algorithm is unchanged.
250 GRAPHS AND MODEL SELECTION
Algorithm 9.1 Graphical Lasso.
1. Initialize W = S. Note that the diagonal of W is unchanged in what
follows.
2. Repeat for j = 1, 2, . . . p, 1, 2, . . . p, . . . until convergence:
(a) Partition the matrix W into part 1: all but the jth row and column,
and part 2: the jth row and column.
(b) Solve the estimating equations W11 − s12 +  · sign() = 0 using a
cyclical coordinate-descent algorithm for the modified lasso.
(c) Update w12 =W11ˆ
3. In the final cycle (for each j) solve for ˆ12 = −ˆ · ˆ22, with 1/ˆ22 =
w22 − wT12ˆ.
The graphical lasso algorithm is fast, and can solve a moderately sparse
problem with 1000 nodes in less than a minute. It is easy to modify the algorithm
to have edge-specific penalty parameters jk; note also that jk = 1 will force ˆjk to be zero.
Figure 9.4 illustrates the path algorithm using a simple example. We generated
20 observations from the model of Figure 9.3, with
 =
2
66664
2 0.6 0 0 0.5
0.6 2 −0.4 0.3 0
0 −0.4 2 −0.2 0
0 0.3 −0.2 2 0
0.5 0 0 −0.2 2
3
77775
. (9.19)
Shown are the graphical lasso estimates for a range of  values, plotted against
the `1 norm of the solution ˆ. The true values of  are indicated on the
right. The solutions are spot on, but this is not surprising since the solution on
the right (no regularization) is S−1 which equals  (Exercise 9.3). In the right
panel, we have added independent Gaussian noise to each element of the data
matrix (with standard deviation 0.05). Now we see that the estimate is not
nearly as accurate; in fact, the nonzero support is never recovered correctly
along the path.
Some further points about the Gaussian graphical model:
• A simpler approach would be to use the observed covariance S11 in place of
W11: this requires just a single pass through the predictors, carrying out a
lasso regression of each variable Xj on the others. This is called neighborhood
selection (Meinshausen and B¨uhlmann 2006). Like the graphical lasso
algorithm, this yields a consistent estimate of the support of , but is not
guaranteed to produce a positive definite estimate ˆ. We discuss this in
detail in Section 9.4.
• If we pre-specify the zero pattern in , we can use standard linear regression
in place of the lasso, leaving out the predictors that are supposed to
GRAPH SELECTION VIA PENALIZED LIKELIHOOD 251
0 1 2 3 4
−0.4 −0.2 0.0 0.2 0.4 0.6
12
15
23
24
34
35
No Noise
0 1 2 3 4 5
−0.4 −0.2 0.0 0.2 0.4 0.6
12
13
14
15
23
24
25
34
35
45
With Noise
ℓ1 Norm ℓ1 Norm
Estimated 
Estimated 
Figure 9.4 Left: Profiles of estimates from the graphical lasso, for data simulated
from the model of Figure 9.3. The actual values of  are achieved at the right end
of the plot. Right: Same setup, except that standard Gaussian noise has been added
to each column of the data. Nowhere along the path is the true edge set recovered.
have coefficients of zero. This provides a convenient way of computing the
constrained maximum likelihood estimate of . Details are in Chapter 17
of Hastie et al. (2009).
9.3.3 Exploiting Block-Diagonal Structure
If the inverse covariance matrix has a block diagonal structure
 =
2
6664
11 0 · · · 0
0 22 · · · 0
...
...
... ...
0 0 · · · kk
3
7775
, (9.20)
for some ordering of the variables, then the graphical lasso problem can be
solved separately for each block, and the solution is constructed from the
individual solutions. This fact follows directly from the subgradient equations
(9.14).
It turns out that there is a very simple necessary and sufficient condition
for a graphical-lasso solution to have such structure (Witten, Friedman and
Simon 2011, Mazumder and Hastie 2012). Let C1,C2, . . .CK be a partition of
the indices 1, 2, . . . , p of S into K blocks. Then the corresponding arrangement
of ˆ has this same block structure if and only if |sii0 |   for all pairs (i, i0)
not belonging to the same block. The proof is easy, by inspection of (9.14)
and using the fact that the inverse of a block diagonal matrix has the same
block-diagonal structure. This means that the elements of each block Ck are
fully disconnected from elements of all other blocks.
252 GRAPHS AND MODEL SELECTION
●
●
●
●
●
●
●
●
●
1000 3000 5000 7000
0.15 0.20 0.25 0.30
Sample Size
Operator−Norm Error
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
p=64
p=100
p=225
●
●
●
●
●
●
●
●
10 15 20 25 30
0.10 0.15 0.20 0.25 0.30
Rescaled Sample Size
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
●
Figure 9.5 Plots of the operator-norm error kb
−k2 between the graphical lasso
estimate b
and the true inverse covariance matrix. Left: plotted versus the raw
sample size N, for three different graph sizes p 2 {64, 100, 225}. Note how the curves
shift to the right as the graph size p increases, reflecting the fact that larger graphs
require more samples for consistent estimation. Right: the same operator-norm error
curves plotted versus the rescaled sample size N
d2 log p for three different graph sizes
p 2 {64, 100, 225}. As predicted by theory, the curves are now quite well-aligned.
This fact can be exploited to provide a substantial speedup in computation,
by first identifying the disconnected components and then solving the
subproblems in each block. The number of blocks is monotone in . This
means, for example, that solutions can be found for very large problems (that
perhaps could not be solved in general), as long as  is sufficiently large.
9.3.4 Theoretical Guarantees for the Graphical Lasso
In order to explore the behavior of graphical lasso or log-determinant method,
we carried out a series of simulations. For a given graph type with p nodes and
specified covariance matrix, we generated a set of N zero-mean multivariate
Gaussian samples, and used them to form the empirical covariance matrix
S. We solved the graphical lasso program using the regularization parameter
N = 2
q
log p
N (Ravikumar, Wainwright, Raskutti and Yu 2011, as suggested
by theory) and plot the operator norm error k b − k2 versus the sample
size N. Figure 9.5 (left) shows such plots for three different dimensions p 2
{64, 100, 225} of two-dimensional grid graphs, in which each node has degree
four. For each graph size, we generated an inverse covariance matrix  2
GRAPH SELECTION VIA PENALIZED LIKELIHOOD 253
Rp×p with entries

st =
8><
>:
1 if s = t,
0.2 if |s − t| = 1, and
0 otherwise
The plots in the left panel show that the graphical lasso is a consistent procedure
for estimating the inverse covariance  in operator norm, since the
error curves converge to zero as N increases. Comparing the curves for different
graph sizes, we see a rightward-upward shift in the error curves, reflecting
the fact that larger graphs require more samples to achieve the same error
tolerance.
It is known that the solution b to the graphical lasso satisfies, with high
probability, the error bound
k b−k2 .
r
d2 log p
N
, (9.21)
where d is the maximum degree of any node in the graph, and . denotes
inequality up to constant terms. (See the bibliographic notes on page 261 for
details). If this theoretical prediction were sharp, one would expect that the
same error curves—if replotted versus the rescaled sample size N
d2 log p—should
be relatively well-aligned. The right panel in Figure 9.5 provides empirical
confirmation of this prediction. We note that there are also theoretical results
that guarantee that, as long as N = 
(d2 log p), the support set b of the
graphical lasso estimate coincides with the support set of . Thus, the
graphical lasso also succeeds in recovering the true graph structure.
9.3.5 Global Likelihood for Discrete Models
In principle, one could imagine adopting the `1-regularized version of the
global likelihood to the problem of graph selection in models with discrete
variables. A major challenge here is that the partition functions A in (9.4)–
(9.6)—in sharp contrast to the multivariate Gaussian case—are difficult to
compute in general. For instance, in the case of the Ising model (9.4), it takes
the form
A() = log
2
4
X
x2{−1,+1}p
exp
8<
:
X
s2V
sxs +
X
(s,t)2E
stxsxt
9=
;
3
5 .
Thus, a brute force approach is intractable for large p, since it involves a
summation over 2p terms. With the exception of some special cases, computing
the value of A() is computationally intractable in general.
There are various approaches that can be taken to approximate or bound
the partition function (see the bibliographic discussion for some references).
However, these methods are somewhat off the main course of development
254 GRAPHS AND MODEL SELECTION
in this chapter. Instead, the next section moves away from global likelihoods
toward the idea of conditional or pseudo-likelihoods. These approaches can be
used both for Gaussian and discrete variable models, and are computationally
tractable, meaning polynomial-time in both sample size and graph size in
either case.
9.4 Graph Selection via Conditional Inference
An alternative approach to graph selection is based on the idea of
neighborhood-based likelihood, or products of such quantities that are known
as pseudo-likelihoods. Both of these methods focus on conditional distributions,
which for many situations are tractable.
For a given vertex s 2 V , we use
X\{s} = {Xt, t 2 V \{s}} 2 Rp−1.
to denote the collection of all other random variables in the graph. Now consider
the distribution of Xs given the random vector X\{s}. By the conditional
s
t1
t2
t3
t4
t5
Figure 9.6 The dark blue vertices form the neighborhood set N(s) of vertex s (drawn
in red); the set N+(s) is given by the union N(s) [ {s}. Note that N(s) is a cut
set in the graph that separates {s} from V \N+(s). Consequently, the variable Xs is
conditionally independent of XV \N+(s) given the variables XN(s) in the neighborhood
set. This conditional independence implies that the optimal predictor of Xs based on
all other variables in the graph depends only on XN(s).
independence properties of any undirected graphical model (see Section 9.2),
the only relevant variables to this conditioning are those in the neighborhood
set
N(s) =

t 2 V | (s, t) 2 E
	
. (9.22)
Indeed, as shown in Figure 9.6, the set N(s) is a cut set that separates {s from the remaining vertices V } \N+(s), where we define N+(s) = N(s) [
GRAPH SELECTION VIA CONDITIONAL INFERENCE 255
{s}. Consequently, we are guaranteed that the variable Xs is conditionally
independent of XV \N+(s) given the variables XN(s), or equivalently that
(Xs | X\{s}) d= (Xs | XN(s)). (9.23)
How can this conditional independence (CI) property be exploited in the
context of graph selection? If we consider the problem of predicting the value
of Xs based on XV \{s}, then by the CI property, the best predictor can be
specified as a function of only XN(s). Consequently, the problem of finding
the neighborhood can be tackled by solving a prediction problem, as detailed
next.
9.4.1 Neighborhood-Based Likelihood for Gaussians
Let us first develop this approach for the multivariate Gaussian. In this case,
the conditional distribution of Xs given X\{s} is also Gaussian, so that Xs can
be decomposed into the best linear prediction based on X\{s} and an error
term—namely
Xs = XT
\{s}s +W\{s}. (9.24)
In this decomposition, W\{s} is zero-mean Gaussian variable with
Var(W\{s}) = Var(Xs | X\{s}), corresponding to the prediction error, and
is independent of X\{s}. So the dependence is captured entirely by the linear
regression coefficients s, which are a scalar multiple of s, the corresponding
subvector of  in (9.8) in Section 9.2.2 (Exercise 9.4).
The decomposition (9.24) shows that in the multivariate Gaussian case,
the prediction problem reduces to a linear regression of Xs on X\{s}. The
key property here—as shown in Exercise 9.4—is that the regression vector s
satisfies supp(s) = N(s). If the graph is relatively sparse—meaning that the
degree |N (s)| of node s is small relative to p—then it is natural to consider
estimating s via the lasso. This leads to the following neighborhood-based
approach to Gaussian graphical model selection, based on a set of samples
X = {x1, . . . , xN}.
In step 1(a), xi,V \{s} represents the (p−1) dimensional subvector of the pvector
xi, omitting the sth component. To clarify step 2, the AND rule declares
that edge (s, t) belongs to the estimated edge set b E if and only s 2 b N(t)
and t 2 b N(s). On the other hand, the OR rule is less conservative, allowing
(s, t) 2 b E if either s 2 b N(t) or t 2 b N(s).
An advantage of neighborhood models is speed. Many efficient implementations
of the lasso are available, and the p regression problems can be solved
independently of each other, and hence in parallel.
The AND/OR rules can be avoided by using a joint estimation approach
using the pseudo-likelihood, which is essentially the sum of the log-likelihoods
in (9.25). In this case we would enforce the symmetry of . While more elegant,
this does incur a small additional computational cost (Friedman, Hastie
256 GRAPHS AND MODEL SELECTION
Algorithm 9.2 Neighborhood-based graph selection for Gaussian
graphical models.
1. For each vertex s = 1, 2, . . . , p:
(a) Apply the lasso to solve the neighborhood prediction problem:
bs 2 arg min
s2Rp−1
(
1
2N
XN
i=1
􀀀
xis − xT
i,V \{s}s)2 + ksk1
)
. (9.25)
(b) Compute the estimate b N(s) = supp(bs) of the neighborhood set N(s).
2. Combine the neighborhood estimates { b N(s), s 2 V } via the AND or OR
rule to form a graph estimate bG = (V, b E).
and Tibshirani 2010a). It also produces an estimate b, and not just its graph.
We discuss such approaches in more generality in Section 9.4.3.
9.4.2 Neighborhood-Based Likelihood for Discrete Models
The idea of a neighborhood-based likelihood is not limited to Gaussian models,
but can also be applied to other types of graphical models that can be
written in the exponential family form. In fact, given that global likelihood
calculations are intractable for discrete graphical models, the neighborhoodbased
approach is especially attractive in the discrete case, at least from the
computational perspective.
The simplest type of discrete graphical model is the Ising model (9.4),
used to model a collection of variables (X1,X2, . . . ,Xp) 2 {−1, +1}p that
interact in a pairwise manner. In this case, as we explore in Exercise 9.5, the
conditional log-odds for the probability of Xs given XV \{s} takes the form3
s (X\{s}) = log

P(Xs = +1 | X\{s})
P(Xs = −1 | X\{s})

= 2s +
X
t2V \{s}
2stXt, (9.26)
with s = [s, {st}t2V \{s}]. Consequently, the neighborhood-based approach
for the Ising model has the same form as Algorithm 9.2, with the ordinary
lasso in step 1(a) replaced by the lasso logistic regression problem
bs 2 arg min
s2Rp
8<
:
1
N
XN
i=1
`[xis, s (xi,\{s})] + 
X
t2V \{s}
|st|
9=
;, (9.27)
3the factor of 2 comes from the particular response coding +1/-1 rather than the traditional
0/1.
GRAPH SELECTION VIA CONDITIONAL INFERENCE 257
Jeffords
Grassley
Hagel
Thomas
Sessions
Sununu Bunning
McCain
Warner
Kyl
Kennedy
Reid
Kohl
Clinton
Rockefeller
Reed Kerry
Lieberman
Biden
Salazar
Cantwell
(a) (b)
Figure 9.7 Politician networks estimated from voting records of U.S. Senate (2004–
2006). A total of N = 546 votes were collected for each of p = 100 senators, with
Xs = +1 (respectively Xs = −1) meaning that senator s voted “yes” (respectively
“no”). A pairwise graphical model was fit to the dataset using the neighborhoodbased
logistic regression approach. (a) A subgraph of 55 senators from the fitted
graph, with Democratic/Republican/Independent senators coded as blue/red/yellow
nodes, respectively. Note that the subgraph shows a strong bipartite tendency with
clustering within party lines. A few senators show cross-party connections. (b) A
smaller subgraph of the same social network.
where ` is the negative log-likelihood for the binomial distribution. This problem
is again a convex program, and any algorithm for `1-penalized logistic
regression can be used, such as the coordinate-descent procedure discussed in
Chapter 5. As in the Gaussian case, rules have to be used to enforce symmetry
in the edge calls.
Hoefling and Tibshirani (2009) present a pseudo-likelihood method for this
problem which imposes the symmetry. It can be thought of as intermediate
to the exact, but computationally intractable, global likelihood approach and
the neighborhood-based method described above. We cover their approach in
Section 9.4.3.
Figure 9.7 shows the results of fitting an Ising model to represent the
politician social network for the U.S. Senate, reconstructed on the basis of
voting records. Details are given in the figure caption; overall we see strong
clustering within each party.
The neighborhood-based approach for graphical model selection can be
shown to be consistent under relatively mild conditions on the sample size
(see the bibliographic section for references and further discussion). In the
case of the Ising model, let bG denote the output of the neighborhood-based
approach using logistic regression. It is known that N = 
(d2 log p) samples
258 GRAPHS AND MODEL SELECTION
● ●
●
●
●
●
●
● ● ● ●
0 200 400 600 800 1200
0.0 0.2 0.4 0.6 0.8 1.0
Sample Size
Probability of Correct Edge Detection
● ●
●
●
●
●
●
● ● ●
●
●●
●
●
●
●
●
●●●
●
p=64
p=100
p=225 ●
●
●
●
●
●
●
● ● ● ●
2 4 6 8 10
0.0 0.2 0.4 0.6 0.8 1.0
Rescaled Sample Size
●
●
●
●
●
●
● ● ●
●
●
●
●
Figure 9.8 Plots of the probability P[bG = G] of correctly recovering the graph versus
the sample size. The neighborhood-based logistic regression procedure was applied to
recover a star-shaped graph (central hub with spokes) with p vertices and hub degree
d = d0.1pe. (a) Plotted versus the raw sample size N. As would be expected, larger
graphs require more samples for consistent estimation. (b) The same simulation
results plotted versus the rescaled sample size N
d log p .
are sufficient to ensure that bG = G with high probability. Figure 9.8 illustrates
the sufficiency of this condition in practice, when the method is applied to a
star-shaped graph with p nodes, in which a central hub node is connected
to d = d0.1pe spoke nodes. (The remaining nodes in the graph are disconnected
from the hub-spoke subgraph.) We implemented the neighborhoodbased
logistic-regression method for graphs with p 2 {64, 100, 225} nodes,
using the AND rule to combine the neighborhoods so as to form the graph
estimate. In panel (a) of Figure 9.8, we plot the probability P[bG = G] of
correctly recovering the unknown graph versus the sample size N, with each
curve corresponding to a different graph size as labelled. Each of these plots
show that the method is model-selection consistent, in that as the sample size
N increases, the probability P[bG = G] converges to one. Naturally, the transition
from failure to success occurs later (at larger sample sizes) for larger
graphs, reflecting that the problem is more difficult. Panel (b) shows the same
simulation results plotted versus the rescaled sample size N
d log p ; on this new
axis, all three curves are now well-aligned. This simulation confirms that the
theoretical scaling N = 
(d2 log p) is sufficient to ensure successful graph recovery,
but not necessary for this class of graphs. However, there are other
classes of graphs for which this scaling is both sufficient and necessary (see
the bibliographic section for details).
GRAPH SELECTION VIA CONDITIONAL INFERENCE 259
9.4.3 Pseudo-Likelihood for Mixed Models
So far we have covered graphical models for all continuous variables (the
Gaussian graphical model), and models for all binary variables (the Ising
model). These do not cover other frequently occurring situations:
• discrete variables with more than two states;
• mixed data types: i.e., some continuous and some discrete.
In this section, we extend the models covered so far to include these cases,
and demonstrate an approach for inference based on the pseudo-likelihood.
A simple generalization of the Gaussian and Ising models is the pairwise
Markov random field model. For convenience in notation, we denote the p
continuous variables by X and the q discrete variables by Y . The density
P
(x, y) is proportional to
exp
8<
:
Xp
s=1

sxs −
1
2
Xp
s=1
Xp
t=1
stxsxt +
Xp
s=1
Xq
j=1
sj [yj ]xs +
Xq
j=1
Xq
r=1
 jr[yj , yr]
9= ;
.
(9.28)
The first two terms are as in the Gaussian graphical model (9.8). The term
sj represents an edge between continuous Xs and discrete Yj . If Yj has Lj
possible states or levels, then sj is a vector of Lj parameters, and sj [yj ]
references the yth
j value. Likewise  jr will be an Lj × Lr matrix representing
an edge between discrete Yj and Yr, and  jr[yj , yr] references the element in
row yj and column yr. The terms  jj will be diagonal, and represent the node
potentials (they correspond to the s in the Ising model (9.4) on page 244).
The matrix 
 represents the entire collection of parameters. Needless to say,
the partition function is typically intractable, except in very low-dimensional
cases.
Here the pseudo-likelihood is attractive: it is the product of the p + q
conditional likelihoods, and each of these are simple (Exercise 9.8), depending
on the type of response:
Continuous: The conditional distribution for each of the p continuous variables
is Gaussian, with mean linear in the conditioning variables.
P(Xs|X\{s}, Y ;
) =

ss
2
12
e
−ss
2

Xs−

s+
P
j
sj [Yj ]−
P
t6=s
stXt
ss
2
(9.29)
The contributions of the discrete conditioning variables on the right-hand
side are different additive constants, as for qualitative factors in linear regression
models; i.e., a constant for each level, determined by the sj .
Discrete: The conditional distribution for each of the q discrete variables is
multinomial, with log-odds linear in the conditioning variables.
P(Yj |X, Y\{j};
) = e
 jj [Yj,Yj]+
P
s
sj [Yj ]Xs+
P
r6=j
 [Yj,Yr]
PLj
`=1 e
 jj [`,`]+
P
s
sj [`]Xs+
P
r6=j
 [`,Yr] (9.30)
260 GRAPHS AND MODEL SELECTION
X1
X2
X3
Y1
Y2
Figure 9.9 Mixed graphical model, with three continuous and two discrete variables.
Y1 has two states, and Y3 has three. The diagram on the right shows the sets of parameters
associated with each edge. The group lasso treats these as sets, and includes
or excludes them all together.
With this notation, the pseudo-log-likelihood is defined to be
`p(
;X,Y) =
XN
i=1
2
4
Xp
s=1
log P(xis|xi\{s}, yi;
)
Xq
j=1
log P(yij |xi, yi\{j};
)
3
5.
(9.31)
One can show that (9.31) is a concave function of 
. Notice that each of the
parameters appears twice: once when one of the indices corresponds to the
response, and again when that index refers to a conditioning variable.
The edge parameters are now of three kinds: scalars st, vectors sj , and
matrices  jr. Figure 9.9 illustrates with a small example. Lee and Hastie
(2014) use the group-lasso to select these different parameter types; they propose
optimizing the penalized pseudo-log-likelihood
`p(
;X,Y) − 
0
@
Xp
s=1
Xs−1
t=1 |st| +
Xp
s=1
Xq
j=1 ksjk2 +
Xq
j=1
j−1X
r=1 k jrk2
1
A (9.32)
w.r.t. the parameters 
. Notice that not all the parameters are penalized. In
particular the diagonal of  is left alone (as in the graphical lasso algorithm),
as are each of the node-potentials  jj . This imposes interesting constraints
on some of the parameter estimates, which are explored in Exercise 9.9.
With only continuous variables, this is exactly the penalized pseudolikelihood
for the Gaussian graphical model. For all binary variables, one can
show that this is equivalent to the lasso-penalized pseudo-likelihood for the
Ising model (see Hoefling and Tibshirani (2009) and Exercise 9.10).
Block coordinate descent is attractive here, since each of the components
has well-studied solutions. However, the parameters are shared, and so care
must be taken to respect this symmetry. Lee and Hastie (2014) use a proximal-
Newton algorithm.
GRAPHICAL MODELS WITH HIDDEN VARIABLES 261
9.5 Graphical Models with Hidden Variables
Chandrasekaran et al. (2012) propose a method for undirected graphical models,
in which some of the variables are unobserved (or “latent”). Suppose for
example that we are modelling stock prices in a certain sector, and they are
heavily dependent on the price of energy, the latter being unmeasured in our
data. Then the concentration matrix of the stock prices will not look sparse
in our data, but may instead be sparse if we could condition on energy price.
Let the covariance matrix of all variables—observed and unobserved—be
. The sub-block of  corresponding to the observed variables is O. Let
K = −1 be the concentration matrix for the set of observed and hidden
variables, with sub-matrices KO, KO,H, KH,O and KH. These capture the
dependencies among the observed variables, between the observed and hidden
variables, and among the hidden variables, respectively. Making use of the
partitioned-inverse formulas, we get the following expression for the concentration
matrix of the observed variables:
˜K
O = −1
O = KO −KO,HK−1
H KH,O (9.33)
Here KO is the concentration matrix of the conditional statistics of the observed
variables given the hidden variables. Now ˜KO may not be sparse, but
if the graphical model for all variables (observed and hidden) has few edges
then KO will be sparse.
Motivated by the form (9.33), letting KO =  the idea is to write
˜K
O = − L, (9.34)
where L is assumed to be low rank, with the rank at most the number of
hidden variables. We then solve the problem
minimize
,L

trace[S(− L)] − log[det(− L)] + kk1 + trace(L)
	
(9.35)
over the set { − L  0,L  0}. Like the graphical lasso, this is again a
convex problem. This relates to the “sparse plus low rank” idea discussed
in Mazumder et al. (2010) and Chandrasekaran et al. (2011). Ma, Xue and
Zou (2013) propose first-order alternating direction-of-multipliers (ADMM)
techniques for this problem, and compare them to second order methods.
Some details are given in Exercise 9.11.
Bibliographic Notes
Detailed discussion of graphical models can be found in Whittaker (1990),
Lauritzen (1996), Cox and Wermuth (1996), Edwards (2000), Pearl (2000),
Anderson (2003), and Koller and Friedman (2009).
The Hammersley–Clifford theorem was first announced in the unpublished
note of Hammersley and Clifford (1971). Independent proofs were given by Besag
(1974) and Grimmett (1973), the latter proof using the M¨oebius inversion
262 GRAPHS AND MODEL SELECTION
formula. See Clifford (1990) for some historical discussion and context of the
result.
Welsh (1993) discusses the computational intractability of evaluating the
partition function for general discrete graphical models. For graphs with special
structure, exact computation of the cumulant function is possible in polynomial
time. Examples include graphs with low tree width, for which the
junction tree algorithm can be applied (Lauritzen and Spiegelhalter 1988,
Lauritzen 1996), and certain classes of planar models (Kastelyn 1963, Fisher
1966). For other special cases, there are rapidly mixing Markov chains that
can be used to obtain good approximations to the cumulant function (Jerrum
and Sinclair 1993, Jerrum and Sinclair 1996, for example, and the references
therein). A complementary approach is provided by the class of variational
methods, which provide approximations to the cumulant generating function
(e.g., see the monograph by Wainwright and Jordan (2008) and references
therein). Examples include the mean-field algorithm, the sum-product
or belief-propagation algorithm, expectation propagation, as well as various
other convex relaxations. For certain graphs, particularly those that are “locally
tree-like,” there are various kinds of asymptotic exactness results (e.g.,
see the book by M´ezard and Montanari (2008) and references therein).
Gaussian graphical models are used for modelling gene expression
data (Dobra, Hans, Jones, Nevins, Yao and West 2004), and other genomic
and proteomic assays. The Ising model (9.4) was first proposed in the context
of statistical physics by Ising (1925). In more recent work, it and related
models have been used as simple models for binary images (Geman and
Geman 1984, Greig, Porteous and Seheuly 1989, Winkler 1995), voting behavior
in politicians (Banerjee et al. 2008), citation network analysis (Zhao,
Levina and Zhu 2011).
Some of the methods discussed in this chapter for undirected models can
be used to aid in the more difficult model search for directed graphical models;
see for example Schmidt, Niculescu-Mizil and Murphy (2007). The paper by
Vandenberghe et al. (1998) provides an introduction to the problem of determinant
maximization with constraints; the Gaussian MLE (with or without
regularization) is a special case of this class of problems. Yuan and Lin (2007a)
proposed the use of `1-regularization in conjunction with the Gaussian (logdeterminant)
likelihood for the covariance-selection problem, and used interior
point methods (Vandenberghe et al. 1998) to solve it. d’Aspremont et al.
(2008) and Friedman et al. (2008) develop faster coordinate descent algorithms
for solving the graphical lasso (9.13), based on solving a sequence of
subproblems. Mazumder and Hastie (2012) offer variants on these algorithms
with better convergence properties. Witten et al. (2011) and Mazumder and
Hastie (2012) show how to exploit block-diagonal structure in S in computing
graphical-lasso solutions. Rothman, Bickel, Levina and Zhu (2008) established
consistency of the estimator in Frobenius norm, whereas Ravikumar et al.
(2011) provide some results on model selection consistency as well as rates
EXERCISES 263
for operator norm. In particular, they proved the operator-norm bound (9.21)
illustrated in Figure 9.5.
The idea of pseudo-likelihood itself is quite old, dating back to the seminal
work of Besag (1975). Meinshausen and B¨uhlmann (2006) were the first
to propose and develop the lasso-based neighborhood selection for Gaussian
graphical models, and to derive consistency results under high-dimensional
scaling; see also the papers by Zhao and Yu (2006) and Wainwright (2009) for
related results on static graphs. Zhou, Lafferty and Wasserman (2008) consider
the problem of tracking a time-varying sequence of Gaussian graphical
models.
Ravikumar, Wainwright and Lafferty (2010) proposed `1-regularized logistic
regression for model selection in discrete binary graphical models, and
showed that it is model-selection consistent under the scaling N = 
(d3 log p).
Subsequent analysis by Bento and Montanari (2009) improved this scaling
to N = 
(d2 log p) for Ising models below the phase transition. Koh
et al. (2007) develop an interior-point algorithm suitable for large-scale `1-
regularized logistic regression. Instead of solving separate a logistic regression
problem at each node, Hoefling and Tibshirani (2009) propose minimization
of the `1-regularized pseudo-likelihood, and derive efficient algorithms for it;
see also Friedman et al. (2010a). Santhanam and Wainwright (2008) derive
information-theoretic lower bounds on Ising model selection, showing that no
method can succeed more than half the time if N = O(d2 log p). This shows
that the neighborhood approach is an optimal procedure up to constant factors.
Cheng, Levina and Zhu (2013) and Lee and Hastie (2014) discuss mixed
graphical models, involving both continuous and discrete variables. Kalisch
and B¨uhlmann (2007) show that a variant of the PC algorithm can be used
for high-dimensional model selection in directed graphs.
A different kind of graphical model is the covariance graph or relevance
network, in which vertices are connected by bidirectional edges if the covariance
(rather than the partial covariance) between the corresponding variables
is nonzero. These are popular in genomics; see for example Butte, Tamayo,
Slonim, Golub and Kohane (2000). The negative log-likelihood from these
models is not convex, making the computations more challenging (Chaudhuri,
Drton and Richardson 2007). Recent progress on this problem has been made
by Bien and Tibshirani (2011) and Wang (2014). The latter paper derives
a blockwise coordinate descent algorithm analogous to the to the graphical
lasso procedure. Some theoretical study of the estimation of large covariance
matrices is given by Bickel and Levina (2008) and El Karoui (2008).
Exercises
Ex. 9.1 The most familiar parametrization of the multivariate Gaussian is in
terms of its mean vector μ 2 Rp and covariance matrix  2 Rp×p. Assuming
that the distribution is nondegenerate (i.e.,  is strictly positive definite),
264 GRAPHS AND MODEL SELECTION
show that the canonical parameters (
,) 2 Rp × Sp+
from the factorization
(9.8) are related by
μ = −−1
, and  = −1. (9.36)
Ex. 9.2 Let {x1, . . . , xN} be N i.i.d. samples from a Gaussian graphical model,
and let L(;X) = 1
N
PN
i=1 log P(xi) denote the rescaled log-likelihood of the
sample.
(a) Show that
L(;X) = log det− trace(S) + C,
where S = 1
N
PN
i=1 xixTi
is the empirical covariance matrix, and C is a
constant independent of .
(b) Show that the function f() = −log det is a strictly convex function
on the cone of positive definite matrices. Prove that rf() = −1 for any
 2 Sp+
.
(c) The (unregularized) Gaussian MLE is given by
b 2 arg max
2Sp+

log det− trace(S)
	
,
when this maximum is attained. Assuming that the maximum is attained,
show that b = S−1. Discuss what happens when N < p.
(d) Now consider the graphical lasso (9.13), based on augmenting the rescaled
log-likelihood with an `1-regularizer. Derive the Karush–Kuhn–Tucker equations
that any primal-optimal pair ( b, cW) 2 Sp+
× Rp×p must satisfy.
(e) Derive the dual program associated with the graphical lasso. Can you
generalize your result to regularization with any `q-norm, for q 2 [1,1]?
Ex. 9.3 Show that if S is positive definite, the graphical lasso algorithm with
 = 0 computes b = S−1.
Ex. 9.4 In this exercise, we explore properties of jointly Gaussian random
vectors that guarantee Fisher consistency of the neighborhood-based lasso
approach to covariance selection. Let (X1,X2, . . . ,Xp) be a zero-mean jointly
Gaussian random vector with positive definite covariance matrix . Letting
T = {2, 3, . . . , p}, consider the conditioned random variable Z = (X1 | XT ).
(a) Show that there is a vector  2 Rp−1 such that
Z = TXT +W,
where W is a zero-mean Gaussian variable independent of XT . Hint: consider
the best linear predictor of X1 given XT .
(b) Show that  = −1
TTT1, where T1 2 Rp−1 is the vector of covariances
between X1 and XT .
EXERCISES 265
(c) Show that j = 0 if and only if j /2 N(1). Hint: The following elementary
fact could be useful: let A be an invertible matrix, given in the blockpartitioned
form
A =

A11 A12
A21 A22

.
Then letting B = A−1, we have B12 = A−1
11 A12

A21A−1
11 A12 − A22
−1
(Horn and Johnson 1985, for example).
Ex. 9.5 Consider the neighborhood-based likelihood approach for selection of
Ising models.
(a) Derive the conditional distribution P(xs | xV \{s}; ), and show how the
neighborhood-prediction reduces to logistic regression.
(b) Verify that the method is Fisher-consistent, meaning that the true conditional
distribution is the population minimizer.
Ex. 9.6 Here we show how, in expression (9.14), we can solve for  and its
inverse W= −1 one row and column at a time. For simplicity let’s focus on
the last row and column. Then the upper right block of Equation (9.14) can
be written as
w12 − s12 −  · sign(12) = 0. (9.37)
Here we have partitioned the matrices into two parts: part 1 being the first
p−1 rows and columns, and part 2 the pth row and column. With W and its
inverse  partitioned in a similar fashion

W11 w12
wT12 w22
11 12
T
12 22

=

I 0
0T 1

, (9.38)
show that
w12 = −W1112/22 (9.39)
= W11 (9.40)
where  = −12/22. This is obtained from the formula for the inverse of a
partitioned inverse of a matrix (Horn and Johnson 1985, for example). Substituting
(9.40) into (9.37) gives
W11 − s12 +  · sign() = 0. (9.41)
Ex. 9.7 With the partitioning as in (9.38), write down the expressions for the
partitioned inverses of each matrix in terms of the other. Show that since
W11 depends on 12, we are not really holding W11 fixed as assumed in the
graphical lasso Algorithm 9.1.
(a) Show that as an alternative we can write (9.37) as
−1
11 12w22 + s12 +  sign(12) = 0. (9.42)
266 GRAPHS AND MODEL SELECTION
(b) Show how to use the solution 12 to update the current version ofWand
b in O(p2) operations.
(c) Likewise, show how to move to a new block of equations in O(p2) operations.
(d) You have derived a primal graphical lasso algorithm. Write it down in
algorithmic form, as in Algorithm 9.1
(Mazumder and Hastie 2012)
Ex. 9.8 Derive the conditional distributions (9.29) and (9.30) for the mixed
graphical model.
Ex. 9.9 Close inspection of the pairwise Markov random field model (9.28)
will show that it is overparametrized with respect to the discrete potentials
sj and  jr. This exercise shows that this aliasing is resolved by the quadratic
penalties in the penalized pseudo-likelihood, in the form of “sum-to-zero” constraints
familiar in regression and ANOVA modelling.
Consider the penalized pseudo log-likelihood (9.32), with  > 0.
(a) Since the 
s are not penalized, show that the solution ˆsj for any s and
j satisfies
XLj
`=1
ˆsj [`] = 0.
(b) Since the (diagonal) matrices  jj are not penalized, show that the solution
ˆ 
jr for any j 6= r satisfies
XLj
`=1
ˆ 
jr[`,m] = 0, m = 1, . . . ,Lr; (9.43)
XLr
m=1
ˆ 
jr[`,m] = 0, ` = 1, . . . ,Lj . (9.44)
Ex. 9.10 Consider the pairwise Markov random field model with only binary
discrete variables. This appears to be different from the Ising model, since
we have four parameters per edge. Use Exercise 9.9 to show that with the
quadratic constraints in (9.32), it is exactly equivalent to a lasso-penalized
pseudo log-likelihood for the Ising model.
Ex. 9.11 Consider the objective function (9.35) for the graphical model that allows
for latent variables. Defining a new variable R = −L, derive the details
of the steps of an ADMM algorithm for solving (9.35) using the augmented
Lagrangian
Lμ(R,0,L,􀀀) = trace(SR) − log detR + kk1 +  · trace(L)
+I(L  0) − trace[􀀀(R −+ L)] + 1
2μkR −+ Lk2
F
EXERCISES 267
successively over R,,L and 􀀀 (Ma et al. 2013).

Chapter 10
Signal Approximation and Compressed
Sensing
10.1 Introduction
In this chapter, we discuss applications of `1-based relaxation to problems of
signal recovery and approximation. Our focus is the role played by sparsity
in signal representation and approximation, and the use of `1-methods for
exploiting this sparsity for solving problems like signal denoising, compression,
and approximation. We begin by illustrating that many classes of “natural”
signals are sparse when represented in suitable bases, such as those afforded
by wavelets and other multiscale transforms. We illustrate how such sparsity
can be exploited for compression and denoising in orthogonal bases. Next
we discuss the problem of signal approximation in overcomplete bases, and
the role of `1-relaxation in finding near-optimal approximations. Finally, we
discuss the method of compressed sensing for recovering sparse signals. It
is a combination of two ideas: taking measurements of signals via random
projections, and solving a lasso-type problem for reconstruction.
10.2 Signals and Sparse Representations
Let us begin by providing some background on the role of sparse representations
in signal processing. To be clear, our use of the term “signal” is general,
including (among other examples) data such as sea water levels, seismic recordings,
medical time series, audio recordings, photographic images, video data,
and financial data. In all cases, we represent the signal by a vector  2 Rp.
(For two-dimensional signals such as images, the reader should think about a
vectorized form of the image.)
10.2.1 Orthogonal Bases
In signal processing, it is frequently useful to represent signals in different
types of bases. Examples include Fourier representations, useful for extracting
periodic structure in time series, and multiscale representations such
as wavelets. Such representations are described by a collection of vectors
269
270 SIGNAL APPROXIMATION AND COMPRESSED SENSING
{ j}p
j=1 that form an orthonormal basis of Rp. If we define the p × p matrix
	 :=

 1  2 . . .  p

, then the orthonormality condition guarantees
that 	T	 = Ip×p. Given an orthonormal basis, any signal  2 Rp can be
expanded in the form
 :=
Xp
j=1

j  j , (10.1)
where the jth basis coefficient 
j := h,  ji = Pp
i=1 
i  ij is obtained by
projecting the signal onto the jth basis vector  j . Equivalently, we can write
the transformation from signal  2 Rp to basis coefficient vector  2 Rp as
the matrix-vector product  = 	T .
20 60 100
Time
Arterial Pressure
Original
1 31 64 96 128
20 60 100
Time
Arterial Pressure
Reconstructed
1 31 64 96 128
−60 −40 −20 0 20 40 60
Index Wavelet Coefficient
Haar Representation
1 31 64 96 128
Figure 10.1 Illustration of sparsity in time series data. Left, top panel: Signal
 2 Rp of arterial pressure versus time over p = 128 points. Left, bottom panel:
Reconstruction b 128 based on retaining the largest (in absolute amplitude) k = 64
coefficients from the Haar basis. Right: Haar basis coefficients  = 	T  of the
signal.
To give a simple example, consider the following matrix
	 :=
2
6664
1
2
12
1 p2 0
12
12
−1 p2 0
12
−12
0 1 p2
12
−12
0 −1 p2
3
7775
. (10.2)
It is an orthonormal matrix, satisfying 	T	 = I4×4, and corresponds to a
two-level Haar transform for signal length p = 4. For any given signal  2 R4,
the Haar basis coefficients  = 	T  have a natural interpretation. The first
SIGNALS AND SPARSE REPRESENTATIONS 271
coefficient 
1 = h 1, i = 1
2
P4
j=1 
j is a rescaled version of the averaged
signal. The second column  2 is a differencing operator on the full signal,
whereas the third and fourth columns are local differencing operators on each
half of the signal. This Haar transform is the simplest example of a wavelet
transform.
An important fact is that many signal classes, while not sparse in the
canonical basis, become sparse when represented in a different orthogonal
basis. Figure 10.1 provides an illustration of this phenomenon for some medical
time series data. The top-left panel shows p = 128 samples of arterial pressure
from a patient, showing that the signal  itself is not at all sparse. The right
panel shows the Haar coefficient representation  = 	T  of the signal; note
how in contrast it is relatively sparse. Finally, the bottom-left panel shows a
reconstruction b of the original signal, based on discarding half of the Haar
coefficients. Although not a perfect reconstruction, it captures the dominant
features of the time series.
Figure 10.2 provides a second illustration of this sparsity phenomenon, this
time for the class of photographic images and two-dimensional wavelet transforms.
Panel (a) shows a 512×512 portion of the “Boats” image; in our framework,
we view this two-dimensional image as a vector in p = 5122 = 262, 144
dimensions. Shown in panel (b) is the form of a particular two-dimensional
wavelet; as can be discerned from the shape, it is designed to extract diagonally
oriented structure at a particular scale. Taking inner products with this
wavelet over all spatial positions of the image (a procedure known as convolution)
yields a collection of wavelet coefficients at all spatial positions of
the image. These coefficients are then sub-sampled, depending on the scale
of the wavelet. Then we reconstruct the image from these coefficients. Doing
so at multiple scales (three in this illustration) and orientations (four in this
illustration) yields the multiscale pyramid shown in panel (c). Once again,
although the original image is not a sparse signal, its representation in this
multiscale basis is very sparse, with many coefficients either zero or very close
to zero. As a demonstration of this sparsity, panel (d) shows a histogram of
one of the wavelet coefficients, obtained by pooling its values over all spatial
positions of the image. This histogram is plotted on the log scale, and the
sharp peak around zero reveals the sparsity of the coefficient distribution.
10.2.2 Approximation in Orthogonal Bases
The goal of signal compression is to represent the signal  2 Rp, typically in
an approximate manner, using some number k  p of coefficients much smaller
than the ambient dimension. In the setting of orthogonal bases, one method
for doing so is based on using only a sparse subset of the orthogonal vectors
{ j}p
j=1. In particular, for an integer k 2 {1, 2, . . . , p} that characterizes the
272 SIGNAL APPROXIMATION AND COMPRESSED SENSING
(a) (b)
−500 0 500
−10
−8
−6
−4
−2
Log Probability
(c) (d)
Figure 10.2 Sparsity in wavelet-based representations of natural images. (a)
“Boats” image. (b) Basis vector of a multiscale pyramid transform, drawn here as
a 2-dimensional image. (c) Three levels of a multiscale representation of “Boats”
image with four different orientations at each scale. (d) Log histogram of the amplitudes
of a wavelet coefficient from a fixed scale and orientation, pooled over all
pixels within the image. Note that the majority of coefficients are close to zero, with
relatively few large in absolute value.
approximation accuracy, let us consider reconstructions of the form
	 =
Xp
j=1
j j , such that kk0 := Pp
j=1 I[j 6= 0]  k. (10.3)
Here we have introduced the `0-“norm,” which simply counts the number of
nonzero elements in the vector  2 Rp. We then consider the problem of
SIGNALS AND SPARSE REPRESENTATIONS 273
(a) (b)
Figure 10.3 Illustration of image compression based on wavelet thresholding. (a)
Zoomed portion of the original “Boats” image from Figure 10.2(a). (b) Reconstruction
based on retaining 5% of the wavelet coefficients largest in absolute magnitude.
Note that the distortion is quite small, and concentrated mainly on the fine-scale
features of the image.
optimal k-sparse approximation—namely, to compute
bk 2 arg min
2Rp k −	k22
such that kk0  k. (10.4)
Given the optimal solution bk of this problem, the reconstruction
k :=
Xp
j=1
bk
j  j (10.5)
defines the best least-squares approximation to  based on k terms. Figure
10.3 illustrates the idea.
Note that the problem (10.4) is nonconvex and combinatorial, due to the
`0-norm constraint. Despite this fact, it is actually very easy to solve in this
particular case, essentially due to the structure afforded by orthonormal transforms.
In particular, suppose that we order the vector  2 Rp of basis coefficients
in terms of their absolute values, thereby defining the order statistics
|
(1)|  |
(2)|  . . .  |
(p)|. (10.6)
Then for any given integer k 2 {1, 2, . . . , p}, it can be shown that the optimal
k-term approximation is given by
bk :=
Xk
j=1

(j) (j), (10.7)
274 SIGNAL APPROXIMATION AND COMPRESSED SENSING
where (j) denotes the basis vector associated with the jth order statistic. In
words, we retain only the basis vectors associated with the largest k coefficients
in absolute value.
In summary, then, we have the following simple algorithm for computing
optimal k-term approximations in an orthogonal basis:
1. Compute the basis coefficients 
j = h,  ji for j = 1, 2, . . . , p. In matrixvector
notation, compute the vector  = 	T .
2. Sort the coefficients in terms of absolute values as in (10.6), and extract
the top k coefficients.
3. Compute the best k-term approximation bk as in (10.7).
For any orthogonal basis, the computational complexity of this procedure is at
most O(p2), with the O(p log p) complexity of sorting in step 2 dominated by
the complexity of computing the basis coefficients in step 1. An attractive feature
of many orthogonal representations, including Fourier bases and discrete
wavelets, is that the basis coefficients can be computed in time O(p log p).
As discussed previously, Figure 10.1 provides one illustration of signal approximation
within the Haar wavelet basis. In particular, the bottom-left panel
shows the approximated signal b64, based on retaining only half of the Haar
wavelet coefficients (k/p = 64/128 = 0.5).
10.2.3 Reconstruction in Overcomplete Bases
Orthonormal bases, though useful in many ways, have a number of shortcomings.
In particular, there is a limited class of signals that have sparse
representations in any given orthonormal basis. For instance, Fourier bases
are particularly well-suited to reconstructing signals with a globally periodic
structure; in contrast, the Haar basis with its localized basis vectors is rather
poor at capturing this kind of structure. On the other hand, the Haar basis excels
at capturing step discontinuities, whereas such jumps have very nonsparse
representations in the Fourier basis.
Based on this intuition, it is relatively straightforward to construct signals
that are in some sense “simple,” but fail to have sparse representations in a
classical orthonormal basis. As an illustration, panel (a) of Figure 10.4 shows
a signal  2 R128 that contains a mixture of both some globally periodic
components, and some rapid (nearly discontinuous) transitions. As shown in
panel (b), its Haar coefficients  = 	T  are relatively dense, because many
basis vectors are required to reconstruct the globally periodic portion of the
signal. Similarly, as shown in panel (c), its representation  = T  in the
discrete cosine basis (a type of Fourier representation) is also relatively dense.
Due to this lack of sparsity, neither basis alone will provide a good sparse
approximation to the original signal.
However, suppose that we allow the reconstruction to use subsets of vectors
from both bases simultaneously; in this case, it might be possible to obtain a
significantly more accurate, or even exact, sparse approximation. To set up
SIGNALS AND SPARSE REPRESENTATIONS 275
Index
Signal
1 16 32 48 64 80 96 112 128
−0.05 0.05 0.15 0.25
(a) Mixed Signal
0.0 0.1 0.2 0.3 0.4 0.5
Index
Wavelet Coefficient
1 16 32 48 64 80 96 112 128
(b) Representation in Haar Basis
−0.2 0.0 0.2 0.4 0.6
Index
Wavelet Coefficient
1 16 32 48 64 80 96 112 128
(c) Representation in Cosine Basis
0.0 0.1 0.2 0.3 0.4 0.5
Index
Coefficient
1 32 64 96 128 160 192 224 256
Haar
Cosine
(d) Optimal Joint Representation
Figure 10.4 (a) Original signal  2 Rp with p = 128. (b) Representation 	T  in
the Haar basis. (c) Representation T  in the discrete cosine basis. (d) Coefficients
(b, b) 2 Rp×Rp of the optimally sparse joint representation obtained by solving basis
pursuit linear program (10.11).
the problem more precisely, given a pair of orthonormal bases { j}p
j=1 and
{j}p
j=1, let us consider reconstructions of the form
Xp
j=1
jj
| {z }

+
Xp
j=1
j j
| {z }
	
such that kk0 + kk0  k, (10.8)
and the associated optimization problem
minimize
(,)2Rp×Rp k −  −	k22
such that kk0 + kk0  k. (10.9)
Despite its superficial similarity to our earlier k-term approximation problem
(10.5), the optimization problem (10.9) is actually very difficult to solve.
Unlike the earlier case, we are now working in an overcomplete basis described
by the union of the two bases  and 	.
276 SIGNAL APPROXIMATION AND COMPRESSED SENSING
Nonetheless, we can resort to our usual relaxation of the `0-“norm,” and
consider the following convex program
minimize
(,)2Rp×Rp k −  −	k22
such that kk1 + kk1  R, (10.10)
where R > 0 is a user-defined radius. This program is a constrained version
of the lasso program, also referred to as the relaxed basis-pursuit program.
When seeking a perfect reconstruction, we can also consider the even simpler
problem
minimize
(,)2Rp×Rp kk1 + kk1 such that  =

 	
 



. (10.11)
This problem is a linear program (LP), often referred to as the basis-pursuit
linear program.
Returning to the example discussed in Figure 10.4, panel (d) shows the
optimal coefficients (b, b) 2 Rp × Rp obtained by solving the basis pursuit
LP (10.11). We thus find that the original signal in panel (a) can be generated
by an extremely sparse combination, with only six nonzero coefficients, in
the overcomplete basis formed by combining the Haar and discrete cosine
representations. In fact, this is the sparsest possible representation of the
signal, so that in this case, solving the basis pursuit LP (10.11) is equivalent
to solving the `0-constrained problem (10.9).
Naturally, the reader might wonder about the generality of this
phenomenon—namely, when does the solution to the basis pursuit LP coincide
with the computationally difficult `0-problem (10.9)? As it turns out,
the answer to this question depends on the degree of incoherence between the
two bases  and 	, as we explore at more length in Section 10.4.
10.3 Random Projection and Approximation
In the previous sections, we discussed approximating a signal by computing
its projection onto each of a fixed set of basis functions. We now turn to
the use of random projections in signal approximation. This allows one to
use a smaller number of (random) basis functions than is required under a
fixed basis. We will combine this with an `1-penalty on the coefficient of each
projection, leading to the idea of compressed sensing.
A random projection of a signal  is a measurement of the form
yi = hzi, i =
Xp
j=1
zij
j , (10.12)
where zi 2 Rp is a random vector. The idea of using random projections for
dimensionality reduction and approximation is an old one, dating back (at
least) to classical work on metric embedding and spherical sections of convex
RANDOM PROJECTION AND APPROXIMATION 277
bodies (see the bibliographic section for more details). We begin by describing
a classical use of random projection, namely for embedding data while
preserving distances between points, and then move on to discuss compressed
sensing, which combines random projections with `1-relaxation.
10.3.1 Johnson–Lindenstrauss Approximation
As one application of random projection, let us consider how they can be used
to approximate a finite collection of vectors, say representing some dataset.
The technique that we describe is often known as Johnson–Lindenstrauss embedding,
based on the authors who pioneered its use in studying the more
general problem of metric embedding (see the bibliographic section for more
details). Suppose that we are given M data points {u1, . . . , uM} lying in Rp.
If the data dimension p is large, then it might be too expensive to store the
dataset. In this setting, one approach is to design a dimension-reducing mapping
F : Rp ! RN with N  p that preserves some “essential” features of the
dataset, and then store only the projected dataset {F(u1), . . . , F(uM)}. For
example, since many algorithms operate on datasets by computing pairwise
distances, we might be interested in a mapping F with the guarantee that for
some tolerance  2 (0, 1), we have
(1−) kui−ui0k22
 kF(ui)−F(ui0 )k22
 (1+)kui−ui0k22for all pairs i 6= i0.
(10.13)
Of course, this is always possible if the projected dimension N is large enough,
but the goal is to do it with relatively small N.
As shown in the seminal work of Johnson and Lindenstrauss, random
projections provide one method for designing such approximate distancepreserving
embeddings. The construction is straightforward:
(a) Form a random matrix Z 2 RN×p with each Zij  N(0, 1), i.i.d., and
define the linear mapping F : Rp ! RN via
F(u) := 1
pN
Zu. (10.14)
(b) Compute the projected dataset {F(u1), F(u2), . . . , F(uM)}.
An interesting question is the following: for a given tolerance  2 (0, 1) and
number of data points M, how large should we choose the projected dimension
N to ensure that approximate distance-preserving property (10.13) holds with
high probability? In Exercises 10.1 and 10.2, we show that this property holds
with high probability as long as N > c
2 logM for some universal constant c.
Thus, the dependence on the number M of data points scales logarithmically,
and hence is very mild.
As a particular example, suppose that our goal is to obtain a compressed
representation of all Boolean vectors u 2 {−1, 0, 1}p that are k-sparse.1 By
1A vector u 2 Rp is k-sparse if only k  p elements are nonzero.
278 SIGNAL APPROXIMATION AND COMPRESSED SENSING
a simple counting argument, there are M = 2k
􀀀p
k

such vectors. Noting that
logM  k log
􀀀 e2p
k

, we see that a projection dimension N > c
2 k log
􀀀 e2p
k

suffices to preserve pairwise distances up to -accuracy between all k-sparse
Boolean vectors. This example provides a natural segue to the method of
compressed sensing, which combines random projections with `1-relaxation.
10.3.2 Compressed Sensing
Compressed sensing is a combination of random projection and `1-regularization
that was introduced in independent work by Candes and Tao (2005)
and Donoho (2006); since this pioneering work, an extensive literature on the
topic has developed, with numerous applications including medical imaging
and single-pixel cameras, among others. In this section, we provide a brief
introduction to the basic ideas.
The motivation for compressed sensing is the inherent wastefulness of the
standard method for compressing signals in an orthogonal basis. As described
in Section 10.2.2, this approach involves first computing the full vector  2 Rp
of basis coefficients (step 1 on page 274), and then discarding a large fraction of
them in order to obtain the k-sparse approximation bk of the underlying signal
 (step 2). Given that we end up discarding most of the basis coefficients,
is it really necessary to compute all of them? Of course, if one knew a priori
which subset of k coefficients were to be retained for the sparse approximation
bk, then one could simply compute this subset of basis coefficients. We refer
to this approach as the oracle technique. Of course, it is unimplementable in
practice, since we don’t know a priori which coefficients are the most relevant
for a given signal.
The power of compressed sensing is that it enables one to mimic the behavior
of the oracle with very little computational overhead. It combines random
projection with `1-minimization in the following way. Instead of pre-computing
all of the basis coefficients  = 	T , suppose that we compute some number
N of random projections, say of the form yi = hzi, i, for i = 1, 2, . . . ,N. We
are free to choose the form of the random projection vectors zi 2 Rp, and we
discuss a number of reasonable choices shortly.
Thus, the setup of our problem is as follows: we are given an N-vector y
of random projections of the signal . Also known to us is the N ×p random
matrix Z with ith row zi, used to compute the random projections; we refer
to Z as the design matrix or measurement matrix. The observation vector y
and design matrix Z are linked to the unknown signal  2 RN by the matrixvector
equation y = Z, and our goal is to recover (exactly or approximately)
the signal  2 Rp. See Figure 10.5(a) for an illustration of this setup.
At first sight, the problem seems very simple, since determining  amounts
to solving a linear system. However, for this method to be cheaper than the
standard approach (and therefore of practical interest), it is essential that the
number of projections (or sample size) N be much smaller than the ambient
dimension p. For this reason, the linear system y = Z is highly underRANDOM
PROJECTION AND APPROXIMATION 279
=
y
N × p
Z 
(a)
=
y
N × p
Z 	 
p − k
k
(b)
Figure 10.5 (a) An under-determined linear system y = Z: Each row zi of the
N ×p measurement matrix Z defines the random projection yi = hzi, i. The signal
 2 Rp need not be sparse in the canonical basis. (b) Equivalent representation of
the linear system: Basis coefficients  = 	T  are assumed to be k-sparse. This
transformation defines an equivalent linear system y = eZ with sparsity that can
be exploited.
determined: there are many signals  that are consistent with the observed
random projections.
However, if we also have the additional side-information that 	T  is
sparse, then it could be possible to recover  exactly, even though the linear
system on its own is under-determined. In an ideal world, we would like to
exploit this sparsity by solving the `0-based problem
minimize
2Rp k	T k0 such that y = Z. (10.15)
The `0-problem is combinatorial, and known to be computationally intractable
(NP-hard) in general; thus, we are led to consider the `1-relaxation
minimize
2Rp k	T k1 such that y = Z. (10.16)
Equivalently, we can write this problem in terms of the transform coefficient
vector  2 Rp, namely as
minimize
2Rp kk1 such that y = eZ, (10.17)
280 SIGNAL APPROXIMATION AND COMPRESSED SENSING
where we have defined the transformed matrix eZ := Z	 2 RN×p. See Figure
10.5(b) for an illustration of this transformed linear system.
In summary, then, the method of compressed sensing operates as follows:
1. For a given sample size N, compute the random projections yi = hzi,  for i = 1, 2, . . . ,N. i
2. Estimate the signal  by solving the linear program (10.16) to obtain
b. (Equivalently, solve the linear program (10.17) to obtain b, and set
b = 	b.)
To be clear, we have actually described a family of procedures, depending
on our choice of the random projection vectors {zi}Ni
=1, or equivalently the
transformed design matrix Z. A variety of different design matrices Z have
been studied for the purposes of compressed sensing. Perhaps the simplest
choice is to choose its entries zij  N(0, 1) in an i.i.d. manner, leading to a
standard Gaussian random matrix. Other choices of matrices for compressed
sensing include random Bernoulli matrices formed with i.i.d. entries drawn
as zij 2 {−1, +1} with equal probability, as well as random submatrices of
Fourier matrices.
When can compressed sensing succeed using a number of projections N less
than the signal dimension p? As we discuss in Section 10.4.2, it is sufficient that
the columns of the transformed design matrix eZ be “incoherent”, and there are
different measures of such incoherence. The simplest measure of incoherence
is pairwise, based on the inner products between the columns of eZ. A more
sophisticated notion of incoherence is the restricted isometry property (RIP),
based on looking on the conditioning of submatrices of eZ consisting of up to
k columns. An important fact is that the random design matrices discussed
above satisfy RIP with high probability using a relatively small number of
projections N. For instance, for the standard Gaussian or Bernoulli cases,
it can be shown that RIP holds with high probability with as few as N =


􀀀
k log p
k

samples, where k < p is the sparsity of the basis coefficient vector
. Note that any method—even the unimplementable oracle that already
knew the support of —would require at least N = k random projections for
exact recovery. Thus, compressed sensing incurs a multiplicative overhead of
only O
􀀀
log(p/k)

relative to oracle performance.
10.4 Equivalence between `0 and `1 Recovery
Thus far, we have discussed a number of applications of `1-norm regularization
in signal processing, including sparse approximation in overcomplete
bases (Section 10.2.3), and compressed sensing (Section 10.3.2). In both cases,
the `1-norm is introduced as a computationally tractable surrogate to optimization
problems involving the intractable `0-“norm.” Up to this point, we
have not addressed in any depth an important question: when is solving the
`1-relaxation equivalent to solving the original `0-problem?
More precisely, given an observation vector y 2 Rp and a design matrix
EQUIVALENCE BETWEEN `0 AND `1 RECOVERY 281
X 2 RN×p, let us consider the two problems
minimize
2Rp kk0 such that X = y, (10.18)
and
minimize
2Rp kk1 such that X = y. (10.19)
This setup includes as a special case the problem of sparse approximation in
an overcomplete basis, as discussed in Section 10.2.3; in this case, the observation
y is equal to the signal  to be approximated, and the design matrix
X =

 	

. It also includes the case of compressed sensing, where X is the
transformed version of the random projection matrix (namely, eZ in our earlier
notation).
10.4.1 Restricted Nullspace Property
Suppose that the `0-based problem (10.18) has a unique optimal solution, say
 2 Rp. Our interest is in understanding when  is also the unique optimal
solution of the `1-based problem (10.19), in which case we say that the basis
pursuit LP is equivalent to `0-recovery. Remarkably, there exists a very simple
necessary and sufficient condition on the design matrix X for this equivalence
to hold. For a given subset S  {1, 2, . . . , p}, it is stated in terms of the set
C(S) :=

 2 Rp | kSck1  kSk1
	
. (10.20)
The set C(S) is a cone, containing all vectors that are supported on S, and
other vectors as well. Roughly, it corresponds to the cone of vectors that have
most of their mass allocated to S. Given a matrix X 2 RN×p, its nullspace is
given by null(X) =

 2 Rp | X = 0
	
.
Definition 10.1. Restricted nullspace property. For a given subset S 
{1, 2, . . . , p}, we say that the design matrix X 2 RN×p satisfies the restricted
nullspace property over S, denoted by RN(S), if
null(X) \ C(S) = {0}. (10.21)
In words, the RN(S) property holds when the only element of the cone C(S)
that lies within the nullspace of X is the all-zeroes vector. The following
theorem highlights the significance of this property:
Theorem 10.1. `0 and `1 equivalence. Suppose that  2 Rp is the unique
solution to the `0 problem (10.18), and has support S. Then the basis pursuit
relaxation (10.19) has a unique solution equal to  if and only if X satisfies
the RN(S) property.
The proof of Theorem 10.1 is relatively short, and is provided in Section
10.4.3.
Since the subset S is not known in advance—indeed, it is usually what we
282 SIGNAL APPROXIMATION AND COMPRESSED SENSING
are trying to determine—it is natural to seek matrices that satisfy a uniform
version of the restricted nullspace property. For instance, we say that the
uniform RN property of order k holds if RN(S) holds for all subsets of size
at most k. In this case, we are guaranteed that the `1-relaxation succeeds for
any vector supported on any subset of size at most k.
10.4.2 Sufficient Conditions for Restricted Nullspace
Of course, in order for Theorem 10.1 to be useful in practice, we need to verify
the restricted nullspace property. A line of work has developed various conditions
for certifying the uniform RN property. The simplest and historically
earliest condition is based on the pairwise incoherence
(X) := max
j,j0=1,2,...,p
j6=j0
|hxj , xj0 i|
kxjk2kxj0k2
. (10.22)
For centered xj this is the maximal absolute pairwise correlation. When X
is rescaled to have unit-norm columns, an equivalent representation is given
by (X) = maxj6=j0 |hxj , xj0 i|, which illustrates that the pairwise incoherence
measures how close the Gram matrix XTX is to the p-dimensional identity
matrix in an element-wise sense.
The following result shows that having a low pairwise incoherence is sufficient
to guarantee exactness of the basis pursuit LP:
Proposition 10.1. Pairwise incoherence implies RN. Suppose that for some integer
k 2 {1, 2, . . . , p}, the pairwise incoherence satisfies the bound (X) < 1
3k .
Then X satisfies the uniform RN property of order k, and hence, the basis
pursuit LP is exact for all vectors with support at most k.
See Section 10.4.3 for the proof of this claim.
An attractive feature of the pairwise incoherence is that it is easily computed;
in particular, in O(Np2) time. A disadvantage is that it provides very
conservative bounds that do not always capture the actual performance of
`1-relaxation in practice. For instance, consider the matrix X =

 	

, as
arises in the overcomplete basis problem (10.11). We can numerically compute
the incoherence, say for the discrete cosine and Haar bases in dimension
p = 128, as illustrated in Figure 10.4. We find that Proposition 10.1 guarantees
exact recovery of all signals with sparsity k = 1, whereas in practice, the
`1-relaxation works for much larger values of k.
For random design matrices, such as those that arise in compressed sensing,
one can use probabilistic methods to bound the incoherence. For instance,
consider a random matrix X 2 RN×p with i.i.d. N(0, 1/N) entries. Here we
have rescaled the variance so that the columns of X have expected norm equal
to one. For such a matrix, one can show that (X) -
q
log p
N with high probability
as (N, p) tend to infinity (see Exercise 10.5). Combined with Proposition
10.1, we conclude that the `1-relaxation (10.16) will exactly recover all
EQUIVALENCE BETWEEN `0 AND `1 RECOVERY 283
signals with sparsity at most k as long as the number of projections scales as
N % k2 log p.
In fact, for random designs and compressed sensing, this scaling can be
sharpened using the restricted isometry property (RIP). Recall that the incoherence
condition (10.22) is a measure of the orthonormality of pairs of
columns of the design matrix X. The notion of restricted isometry is to constrain
much larger submatrices of X to have nearly orthogonal columns.
Definition 10.2. Restricted isometry property. For a tolerance  2 (0, 1) and
integer k 2 {1, 2, . . . , p}, we say that RIP(k, ) holds if
kXT
SXS − Ik×kkop   (10.23)
for all subsets S  {1, 2, . . . , p} of cardinality k.
We recall here that k · kop denotes the operator norm, or maximal singular
value of a matrix. Due to the symmetry of XT
SXS, we have the equivalent
representation
kXT
SXS − Ik×kkop = sup
kuk2=1

uT 􀀀
XT
SXS − Ik×k

u

= sup
kuk2=1

kXS uk22 − 1

.
Thus, we see that RIP(k, ) holds if and only if for all subsets S of cardinality
k, we have
kXS uk22
kuk22
2 [1 − , 1 + ] for all u 2 Rk\{0},
hence the terminology of restricted isometry.
The following result shows that RIP is a sufficient condition for the restricted
nullspace to hold:
Proposition 10.2. RIP implies restricted nullspace. If RIP(2k, ) holds with
 < 1/3, then the uniform RN property of order k holds, and hence the `1-
relaxation is exact for all vectors supported on at most k elements.
We work through the proof of a slightly weaker version of this claim in Exercise
10.8. Observe that the RIP(2k, ) condition imposes constraints on a
huge number of submatrices, namely
􀀀 p
2k

in total. On the other hand, as opposed
to the pairwise incoherence condition, the actual RIP constant  has no
dependence on k.
From known results in random matrix theory, various choices of random
projection matrices X satisfy RIP with high probability as long as
N % k log e p
k . Among other matrix ensembles, this statement applies to a standard
Gaussian random matrix X with i.i.d. N(0, 1
N ) entries; see Exercise 10.6
for details. Thus, we see that the RIP-based approach provides a certificate for
exact recovery based on far fewer samples than pairwise incoherence, which
as previously discussed, provides guarantees when N % k2 log p. On the other
hand, a major drawback of RIP is that—in sharp contrast to the pairwise
incoherence—it is very difficult to verify in practice due to the number
􀀀 p
2k

of submatrices.
284 SIGNAL APPROXIMATION AND COMPRESSED SENSING
10.4.3 Proofs
We conclude the chapter by providing proofs of the claims given in the preceding
section.
10.4.3.1 Proof of Theorem 10.1
First, suppose that X satisfies the RN(S) property. Let b 2 Rp be any optimal
solution to the basis pursuit LP (10.19), and define the error vector
 := b − . Our goal is to show that  = 0, and in order to do so, it suffices
to show that  2 null(X)\C(S). On the one hand, since  and b are optimal
(and hence feasible) solutions to the `0 and `1 problems, respectively, we are
guaranteed that X = y = Xb, showing that X = 0. On the other hand,
since  is also feasible for the `1-based problem (10.19), the optimality of b
implies that kbk1  kk1 = kS k1. Writing b =  + , we have
k
S k1  kbk1 = k
S + Sk1 + kSck1
 k
S k1 − kSk1 + kSck1,
where the final bound follows by triangle inequality. Rearranging terms, we
find that  2 C(S); since X satisfies the RN(S) condition by assumption, we
conclude that  = 0 as required.
We lead the reader through a proof of the converse in Exercise 10.4.
10.4.3.2 Proof of Proposition 10.1
We may assume without loss of generality (rescaling as needed) that kxjk2 = 1
for all j = 1, 2, . . . , p. To simplify notation, let us assume an incoherence
condition of the form (X) < 
k for some  > 0, and verify the sufficiency of
 = 1/3 in the course of the argument.
For an arbitrary subset S of cardinality k, suppose that  2 C(S)\{0}. It
suffices to show that kXk22
> 0, and so we begin with the lower bound
kXk22  kXSSk22
+ 2T
SXT
SXScSc . (10.24)
On one hand, we have
2

T
SXT
SXScSc

 2
X
i2S
X
j2Sc |i| · |j | · |hxi, xj i|
(i)
 2kSk1 kSck1 (X)
(ii)

2kSk21
k
(iii)
 2  kSk22
,
where inequality (i) uses the definition (10.22) of the pairwise incoherence;
BIBLIOGRAPHIC NOTES 285
inequality (ii) exploits the assumed bound on (X) combined with the fact
that  2 C(S); and inequality (iii) uses the fact that kSk21
 kkSk22
, by
Cauchy–Schwarz, since the cardinality of S is at most k. Consequently, we
have established that
kXk22
 kXSSk22
− 2kSk22
. (10.25)
In order to complete the proof, it remains to lower bound kXSSk22
. Letting
k · kop denote the operator norm (maximum singular value) of a matrix, we
have
kXT
SXS − Ik×kkop  max
i2S
X
j2S\{i}
|hxi, xj i|  k

k
= .
Consequently, kXSSk22
 (1−)kSk22
, and combined with the bound (10.25),
we conclude that kXk22
> (1 − 3)kSk22
, so that  = 1/3 is sufficient as
claimed.
Bibliographic Notes
There is an extensive literature on the sparsity of images and other signal
classes when represented in wavelet and other multiscale bases (Field 1987,
Ruderman 1994, Wainwright, Simoncelli and Willsky 2001, Simoncelli 2005).
Sparse approximation in overcomplete bases is discussed in various papers
(Donoho and Stark 1989, Chen et al. 1998, Donoho and Huo 2001, Elad
and Bruckstein 2002, Feuer and Nemirovski 2003). The multiscale basis illustrated
in Figure 10.2 is known as the steerable pyramid (Simoncelli and
Freeman 1995). Random projection is a widely used technique in computer
science and numerical linear algebra (Vempala 2004, Mahoney 2011, Pilanci
and Wainwright 2014, e.g.). Johnson and Lindenstrauss (1984) proved the
lemma that now bears their name in the context of establishing the existence
of metric embeddings, using random projection as a proof technique. Compressed
sensing was introduced independently by Cand`es, Romberg and Tao
(2006) and Donoho (2006). Lustig, Donoho, Santos and Pauly (2008) discuss
the applications of compressed sensing to medical imaging, whereas Cand`es
and Wakin (2008) discuss various applications in signal processing.
The restricted nullspace property is discussed in Donoho and Huo (2001),
Feuer and Nemirovski (2003), and Cohen, Dahmen and DeVore (2009). Various
authors (Donoho and Huo 2001, Elad and Bruckstein 2002, Feuer and
Nemirovski 2003) have studied the pairwise incoherence of overcomplete bases
and other design matrices, as a sufficient condition for the restricted nullspace
property. Cand`es and Tao (2005) introduced the restricted isometry property
as a milder sufficient condition for the restricted nullspace property. For
random matrices with i.i.d. sub-Gaussian rows, it follows from a combination
of union bound and standard results in random matrix theory (Davidson and
Szarek 2001, Vershynin 2012) that a sample size N > ck log
􀀀 ep
k

suffices to
286 SIGNAL APPROXIMATION AND COMPRESSED SENSING
ensure that the RIP is satisfied with high probability. Baraniuk, Davenport,
DeVore and Wakin (2008) point out connections between the RIP and the
Johnson–Lindenstrauss lemma; see also Exercise 10.6 for some related calculations.
Krahmer and Ward (2011) establish a partial converse, showing
that restricted isometry can be used to establish Johnson–Lindenstrauss type
guarantees.
Exercises
Ex. 10.1 Chi-squared concentration. If Y1, . . . , YN are i.i.d N(0, 1) variates,
then the variable Z := PN
i=1 Y 2
i has a chi-squared distribution with N degrees
of freedom. (In short, we write Z  2
N.)
(a) Show that for all  2 [−1, 1/2), we have
E[exp((Z − d))] =
h e−
p1 − 2
iN
. (10.26)
(b) Use the bound (10.26) to show that
P

|Z − N|  tN

 2e−Nt2
32 for all t 2 (0, 1/2). (10.27)
(The constants in this tail bound are not sharp, and can be improved.)
Ex. 10.2 Johnson–Lindenstrauss approximation. Recall from Section 10.3.1
the problem of distance-preserving embedding.
(a) Show that for any vector u with unit Euclidean norm, the random variable
NkF(u)k22
follows a 2-squared distribution with N degrees of freedom.
(b) For any  2 (0, 1), define the event
E() :=

kF(ui) − F(uj)k22
kui − ujk22
2 [1 − , 1 + ] for all pairs i 6= j.

.
Use the results of Exercise 10.1 and the union bound to show that
P

E()]  1 − 2e−N.
as long as N > 64
2 logM.
Ex. 10.3 For a given compact set A  Rp, an -covering set is a subset
{u1, . . . , uM} of elements of A with the property for any u 2 A, there is some
index j 2 {1, . . . ,M} such that ku − ujk2  . A -packing set is a subset
{v1, . . . , vM0
} of elements of A such that such that kvi −vjk2 >  for all pairs
i 6= j in {1, . . . ,M0}. We use M() to denote the size of the largest -packing,
and N() to denote the size of the smallest -covering.
(a) Show that M(2)  N().
EXERCISES 287
(b) Show that N()  M().
(c) Consider the Euclidean ball B2(1) = {u 2 Rp | kuk2 = 1}. For each
 2 (0, 1), show that there exists an -covering set with at most M = (c/)p
elements, for some universal constant c > 0. (Hint: Use part (b) and consider
the volumes of Euclidean balls in p-dimensions.)
Ex. 10.4 In this exercise, we work through the proof of the converse of Theorem
10.1, in particular showing that if the `1-relaxation has a unique optimal
solution, equal to the `0-solution, for all S-sparse vectors, then the set
null(X)\{0} has no intersection with C(S).
(a) For a given vector  2 null(X)\{0}, consider the basis-pursuit problem
minimize
2Rp kk1 such that X = X

S 0

.
What is the link between its unique optimal solution b and the vector

0
−Sc

?
(b) Use part (a) to show that  /2 C(S).
Ex. 10.5 Let X 2 RN×p be a random matrix with i.i.d. N
􀀀
0, 1/N

entries.
Show that it satisfies the pairwise incoherence condition (10.22) as long as
N > c k2 log p for a universal constant c. (Hint: The result of Exercise 10.1
may be useful.)
Ex. 10.6 Let X 2 RN×p be a random matrix with i.i.d. N
􀀀
0, 1/N

entries. In
this exercise, we show that the restricted isometry property (RIP) holds with
high probability as long as N > ck log(e p/k) for a sufficiently large constant
c > 0.
(a) Explain why it is sufficient to prove that there are constants c1, c2 such
that
kXT
SXS − I2k×2kkop  t (10.28)
with probability at least 1−c1e−c2Nt2 , for any fixed subset S of cardinality
2k, and any t 2 (0, 1).
(b) Let B2(1; S) = {u 2 Rp | kuk2 = 1 and uSc = 0} denote the intersection
of the Euclidean ball with the subspace of vectors supported on a
given subset S. Let {u1, . . . , uM} be an -covering of the set B2(1; S), as
previously defined in Exercise 10.3. Show that the bound (10.28) is implied
by a bound of the form
max
j=1,...,M

kXujk22
− 1

 ,
with probability at least 1 − c3ec4N2 , for any  2 (0, 1).
(c) Use part (b) and Exercise 10.3 to complete the proof.
288 SIGNAL APPROXIMATION AND COMPRESSED SENSING
Ex. 10.7 `0 and `1-balls. In this exercise, we consider the relationship between
`0 and `1-balls, and prove a containment property related to the success of
`1-relaxation. For an integer r 2 {1, . . . , p}, consider the following two subsets:
L0(r) := B2(1) \ B0(r) =

 2 Rp | kk2  1, and kk0  r
	
,
L1(r) := B2(1) \ B1(pr) =

 2 Rp | kk2  1, and kk1  pr
	
.
Let conv denote the closure of the convex hull (when applied to a set).
(a) Prove that conv
􀀀
L0(r)

 L1(r).
(b) Prove that L1(r)  2 conv
􀀀
L0(r)

.
(Hint: Part (b) is a more challenging problem: you may find it useful to consider
the support functions of the two sets. )
Ex. 10.8 In this exercise, we work through a proof of (a slightly weaker version
of) Proposition 10.2.
(a) For any subset S of cardinality k, the set C(S)\B2(1) is contained within
the set L1(r) with r = 4k.
(b) Now show that if RIP(8k, ) holds with  < 1/4, then the restricted
nullspace property holds. (Hint: Part (b) of Exercise 10.7 could be useful.)
Chapter 11
Theoretical Results for the Lasso
In this chapter, we turn our attention to some theoretical results concerning
the behavior of the lasso. We provide non-asymptotic bounds for the `2
and prediction error of the lasso, as well as its performance in recovering the
support set of the unknown regression vector.
11.1 Introduction
Consider the standard linear regression model in matrix-vector form
y = X + w, (11.1)
where X 2 RN×p is the model (design) matrix, w 2 RN is a vector of noise
variables, and  2 Rp is the unknown coefficient vector. In this chapter, we
develop some theoretical guarantees for both the constrained form of the lasso
minimize
kk1R ky − Xk22
, (11.2)
as well as for its Lagrangian version
minimize
2Rp
 1
2N ky − Xk22
+ Nkk1
	
. (11.3)
As we have discussed previously, by Lagrangian duality, there is a correspondence
between these two families of quadratic programs, where N can be interpreted
as the Lagrange multiplier associated with the constraint kk1  R.
11.1.1 Types of Loss Functions
Given a lasso estimate b 2 Rp, we can assess its quality in various ways. In
some settings, we are interested in the predictive performance of b, so that
we might compute a prediction loss function of the form
Lpred(b; ) = 1
N kXb − Xk22
, (11.4)
289
290 THEORETICAL RESULTS FOR THE LASSO
corresponding to the mean-squared error of b over the given samples of X. In
other applications—among them medical imaging, remote sensing, and compressed
sensing—the unknown vector  is of primary interest, so that it is
most appropriate to consider loss functions such as the `2-error
L2(b; ) = kb − k22
, (11.5)
which we refer to as a parameter estimation loss. Finally, we might actually be
interested in variable selection or support recovery, and so use the loss function
Lvs(b; ) =
(
0 if sign(bi) = sign(
i ) for all i = 1, . . . , p,
1 otherwise.
(11.6)
This assesses whether or not the estimate b shares the same signed support as
. In this chapter, we provide theoretical results for all three types of losses.
11.1.2 Types of Sparsity Models
A classical analysis of a method such as the lasso would fix the number of
covariates p, and then take the sample size N to infinity. Although this type
of analysis is certainly useful in some regimes, there are many settings in
which the number of covariates p may be of the same order, or substantially
larger than the sample size N. Examples include microarray gene expression
analysis, which might involve N = 100 observations of p = 10, 000 genes,
or social networks, in which one makes relatively few observations of a large
number of individuals. In such settings, it is doubtful whether theoretical
results based on “fixed p, large N” scaling would provide useful guidance to
practitioners.
Accordingly, our aim in this chapter is to develop theory that is applicable
to the high-dimensional regime, meaning that it allows for the scaling p  N.
Of course, if the model lacks any additional structure, then there is no hope
of recovering useful information about a p-dimensional vector with limited
samples. Indeed, whenever N < p, the linear model (11.1) is unidentifiable;
for instance, it is impossible to distinguish between the models  = 0 and
 = , where  2 Rp is any element of the p − N-dimensional nullspace of
X.
For this reason, it is necessary to impose additional constraints on the
unknown regression vector  2 Rp, and here we focus on various types of
sparsity constraints. The first setting is that of hard sparsity, in which we assume
that  has at most k  p nonzero entries. For such hard-sparse models,
it makes sense to consider the prediction and `2-norm losses as well as the
variable selection loss (11.6). Assuming that the model is exactly supported
on k coefficients may be overly restrictive, so that we also consider the case
of weakly sparse models, meaning that  can be closely approximated by
vectors with few nonzero entries. For instance, one way of formalizing this
BOUNDS ON LASSO `2-ERROR 291
2
1
3
1
2
1
3
1
Figure 11.1 Left: For q = 1, the set B(Rq) corresponds to the `1-ball, which is a
convex set. Right: Setting q = 0.75 yields a nonconvex set, with spikes along the
coordinate axes.
notion is by defining, for a parameter q 2 [0, 1] and radius Rq > 0, the set
B(Rq) =

 2 Rp |
Xp
j=1 |i|q  Rq
	
. (11.7)
This set is known as the `q-“ball” of radius1 Rq; as illustrated in Figure 11.1,
for q 2 [0, 1), it is not a ball in the strict sense of the word, since it is a
nonconvex set. In the special case q = 0, imposing the constraint  2 B(R0)
is equivalent to requiring that  has at most k = R0 nonzero entries.
11.2 Bounds on Lasso `2-Error
We begin by developing some results on the `2-norm loss (11.5) between a lasso
solution b and the true regression vector . We focus on the case when  is
k-sparse, meaning that its entries are nonzero on a subset S()  {1, 2, . . . , p} of cardinality k = |S()|. In the exercises, we work through some extensions
to the case of weakly-sparse coefficient vectors.
11.2.1 Strong Convexity in the Classical Setting
We begin by developing some conditions on the model matrix X that are
needed to establish bounds on `2-error. In order to provide some intuition for
these conditions, we begin by considering one route for proving `2-consistency
in the classical setting (i.e., p fixed, N tending to infinity). Suppose that we
estimate some parameter vector  by minimizing a data-dependent objective
1Strictly speaking, the radius would be R
1
q
q , but we take this liberty so as to simplify
notation.
292 THEORETICAL RESULTS FOR THE LASSO
function fN() over some constraint set. (For instance, the lasso minimizes
the least-squares loss fN() = 1
N ky − Xk22
subject to an `1-constraint.) Let
us suppose that the difference in function values fN = |fN(b) − fN() converges to zero as the sample size N increases. The key question is the|
following: what additional conditions are needed to ensure that the `2-norm
of the parameter vector difference  = kb − k2 also converges to zero?
 b
fN

 b
fN

Figure 11.2 Relation between differences in objective function values and differences
in parameter values. Left: the function fN is relatively “flat” around its optimum
b, so that a small function difference fN = |fN(b)−fN()| does not imply
that  = kb − k2 is small. Right: the function fN is strongly curved around its
optimum, so that a small difference fN in function values translates into a small
difference in parameter values.
To understand the issues involved, suppose that for some N, the objective
function fN takes the form shown in Figure 11.2(a). Due to the relative
“flatness” of the objective function around its minimum b, we see that the
difference fN = |fN(b) − fN()| in function values is quite small while at
the same time the difference  = kb −k2 in parameter values is relatively
large. In contrast, Figure 11.2(b) shows a more desirable situation, in which
the objective function has a high degree of curvature around its minimum
b. In this case, a bound on the function difference fN = |fN(b) − fN()| translates directly into a bound on  = kb − k2.
How do we formalize the intuition captured by Figure 11.2? A natural
way to specify that a function is suitably “curved” is via the notion of strong
convexity. More specifically, given a differentiable function f : Rp ! R, we
say that it is strongly convex with parameter 
 > 0 at  2 Rp if the inequality
f(0) − f()  rf()T (0 − ) + 

2 k0 − k22
(11.8)
hold for all 0 2 Rp. Note that this notion is a strengthening of ordinary
convexity, which corresponds to the case 
 = 0. When the function f is twice
continuously differentiable, an alternative characterization of strong convexity
BOUNDS ON LASSO `2-ERROR 293
is in terms of the Hessian r2f: in particular, the function f is strongly convex
with parameter 
 around  2 Rp if and only if the minimum eigenvalue of the
Hessian matrix r2f() is at least 
 for all vectors  in a neighborhood of .
If f is the negative log-likelihood under a parametric model, then r2f() is
the observed Fisher information matrix, so that strong convexity corresponds
to a uniform lower bound on the Fisher information in all directions.
11.2.2 Restricted Eigenvalues for Regression
Let us now return to the high-dimensional setting, in which the number of
parameters p might be larger than N. It is clear that the least-squares objective
function fN() = 1
2N ky − Xk22
is always convex; under what additional
conditions is it also strongly convex? A straightforward calculation yields that
r2f() = XTX/N for all  2 Rp. Thus, the least-squares loss is strongly
convex if and only if the eigenvalues of the p × p positive semidefinite matrix
XTX are uniformly bounded away from zero. However, it is easy to see that
any matrix of the form XTX has rank at most min{N, p}, so it is always
rank-deficient—and hence not strongly convex—whenever N < p. Figure 11.3
illustrates the situation.
C
bad
good
Figure 11.3 A convex loss function in high-dimensional settings (with p  N) cannot
be strongly convex; rather, it will be curved in some directions but flat in others.
As shown in Lemma 11.1, the lasso error b = b− must lie in a restricted subset C
of Rp. For this reason, it is only necessary that the loss function be curved in certain
directions of space.
For this reason, we need to relax our notion of strong convexity. It turns
out, as will be clarified by the analysis below, that it is only necessary to
impose a type of strong convexity condition for some subset C  Rp of possible
294 THEORETICAL RESULTS FOR THE LASSO
perturbation vectors  2 Rp. In particular, we say that a function f satisfies
restricted strong convexity at  with respect to C if there is a constant 
 > 0
such that
Tr2f()
kk22
 
 for all nonzero  2 C, (11.9)
and for all  2 Rp in a neighborhood of . In the specific case of linear regression,
this notion is equivalent to lower bounding the restricted eigenvalues
of the model matrix—in particular, requiring that
1
N TXTX
kk22
 
 for all nonzero  2 C. (11.10)
What constraint sets C are relevant? Suppose that the parameter vector 
is sparse—say supported on the subset S = S(). Defining the lasso error
b = b − , let bS 2 R|S| denote the subvector indexed by elements of S,
with bSc defined in an analogous manner. For appropriate choices of the `1-
ball radius—or equivalently, of the regularization parameter N—it turns out
that the lasso error satisfies a cone constraint of the form
kbSck1  kbSk1, (11.11)
for some constant   1. This fact is easiest to see for the lasso in its constrained
version. Indeed, assuming that we solve the constrained lasso (11.2)
with ball radius R = kk1, then since b is feasible for the program, we have
R = k
S k1  k + bk1
= k
S + bSk1 + kbSck1
 k
S k1 − kbSk1 + kbSck1.
Rearranging this inequality, we see that the bound (11.11) holds with  = 1.
If we instead solve the regularized version (11.3) of the lasso with a “suitable”
choice of N, then it turns out that the error satisfies the constraint
kbSck1  3kbSk1. (11.12)
(We establish this fact during the proof of Theorem 11.1 to follow.) Thus, in
either its constrained or regularized form, the lasso error is restricted to a set
of the form
C(S; ) :=

 2 Rp | kSck1  kSk1
	
, (11.13)
for some parameter   1; see Figure 11.3 for an illustration.
11.2.3 A Basic Consistency Result
With this intuition in place, we now state a result that provides a bound on
the lasso error kb−k2, based on the linear observation model y = X+w,
where  is k-sparse, supported on the subset S.
BOUNDS ON LASSO `2-ERROR 295
Theorem 11.1. Suppose that the model matrix X satisfies the restricted eigenvalue
bound (11.10) with parameter 
 > 0 over C(S; 3).
(a) Then any estimate b based on the constrained lasso (11.2) with R =
kk1 satisfies the bound
kb − k2 
4


r
k
N



XTw
pN



1. (11.14a)
(b) Given a regularization parameter N  2kXTwk1/N > 0, any estimate
b from the regularized lasso (11.3) satisfies the bound
kb − k2 
3


r
k
N
pN N. (11.14b)
Before proving these results, let us discuss the different factors in the
bounds (11.14a) and (11.14b), and then illustrate them with some examples.
First, it is important to note that these results are deterministic, and apply
to any set of linear regression equations with a given observed noise vector
w. Below we obtain results for specific statistical models, as determined by
assumptions on the noise vector w and/or the model matrix. These assumptions
will affect the rate through the restricted eigenvalue constant 
, and the
terms kXTwk1 and N in the two bounds. Based on our earlier discussion of
the role of strong convexity, it is natural that lasso `2-error is inversely proportional
to the restricted eigenvalue constant 
 > 0. The second term
p
k/N
is also to be expected, since we are trying to estimate unknown regression
vector with k unknown entries based on N samples. As we have discussed,
the final term in both bounds, involving either kXTwk1 or N, reflects the
interaction of the observation noise w with the model matrix X.
It is instructive to consider the consequences of Theorem 11.1 for some
linear regression models that are commonly used and studied.
Example 11.1. Classical linear Gaussian model. We begin with the classical
linear Gaussian model, for which the observation noise w 2 RN is Gaussian,
with i.i.d. N(0, 2) entries. Let us view the design matrix X as fixed, with
columns {x1, . . . , xp}. For any given column j 2 {1, . . . , p}, a simple calculation
shows that the random variable xT
j w/N is distributed as N(0, 2
N · kxjk22
N ).
Consequently, if the columns of the design matrix X are normalized (meaning
kxjk2/pN  1 for all j = 1, . . . , p), then this variable is stochastically
dominated by a N(0, 2
N ) variable, so that we have the Gaussian tail bound
P
"
|xT
j w|
N  t
#
 2e−Nt2
22 .
Since kXTwk1
N corresponds to the maximum over p such variables, the union
bound yields
P
h
kXTwk1
N  t
i
 2e−Nt2
22 +log p = 2e−12
(−2) log p,
296 THEORETICAL RESULTS FOR THE LASSO
where the second equality follows by setting t = 
q
 log p
N for some  > 2.
Consequently, we conclude that the lasso error satisfies the bound
kb − k2 
c 


r
k log p
N
. (11.15)
probability at least 1 − 2e−1
2 (−2) log p. This calculation has also given us
a choice of the regularization parameter N that is valid for the Lagrangian
lasso in Theorem 11.1(b). In particular, from our calculations, setting
N = 2
q
 log p
N for some  > 2 will be a valid choice with the same high
probability.
It should also be noted that the rate (11.15) is intuitively reasonable.
Indeed, if support set S() were known, then estimation of  would require
approximating a total of k parameters—namely, the elements 
i for all
i 2 S(). Even with knowledge of the support set, since the model has k free
parameters, no method can achieve squared `2-error that decays more quickly
than k
N . Thus, apart from the logarithmic factor, the lasso rate matches the
best possible that one could achieve, even if the subset S() were known a
priori. In fact, the rate (11.15)—including the logarithmic factor—is known to
be minimax optimal, meaning that it cannot be substantially improved upon
by any estimator. See the bibliographic section for further discussion.
Example 11.2. Compressed sensing. In the domain of compressed sensing
(Chapter 10), the design matrix X can be chosen by the user, and one standard
choice is to form a random matrix with i.i.d. N(0, 1) entries, and model the
noise vector w 2 RN as deterministic, say with bounded entries (kwk1  .)
Under these assumptions, each variable 1
N xT
j w is a zero-mean Gaussian with
variance at most 2
N . Thus, by following the same argument as in the preceding
example, we conclude that the lasso error will again obey the bound (11.15)
with high probability for this set-up.
By a more refined argument, one can derive a strengthening of the error
bound (11.15), namely:
kb − k2  c 
r
k log(ep/k)
N
. (11.16)
where e  2.71828, and c is a universal constant. This bound suggests that
the sample size N should satisfy the lower bound
N  k log(ep/k) (11.17)
in order for the lasso to have small error.
Following Donoho and Tanner (2009), let us consider the ratios  = k/N
and  = N/p, in which form the bound (11.17) can be rewritten as
(1 − log( ))  1. (11.18)
BOUNDS ON LASSO `2-ERROR 297
In order to study the accuracy of this prediction, we generated random ensembles
of the linear regression problem in dimension p = 200 and sample sizes
N ranging from 10 and 200, where each feature xij  N(0, 1) was generated
independently. Given this random design, we then generated outcomes from
a linear model yi = hxi, i + wi where wi  N(0, 1) and  = 4. For a
given sparsity level k, we chose a random subset S of size k, and for each
j 2 S, we generated 
j  N(0, 1) independently at random. In all cases, the
pre-factor  was chosen for each N and k, so that the signal-to-noise ratio
was approximately equal to 10. We then solved the Lagrangian lasso using
the regularization parameter N = 2
q
3log ep
k
N . Figure 11.4 is a heatmap of
the median of the Euclidean error kb − k2 over 10 realizations, with the
boundary (11.18) super-imposed. We see that there is a fairly sharp change at
the theoretical boundary, indicating that more samples are needed when the
underlying model is more dense.
0.0 0.2 0.4 0.6 0.8 1.0
0.0 0.2 0.4 0.6 0.8 1.0
2
4
6
8
10
12
14
 = N/p
 = k/N
Figure 11.4 Simulation experiment: median of the error kb−k2 over 10 realizations,
with the boundary (11.18) super-imposed.
Equipped with this intuition, we now turn to the proof of Theorem 11.1.
Proof of Theorem 11.1: The proof is very straightforward for the constrained
lasso bound (11.14a), and requires a bit more work for the regularized lasso
bound (11.14b).
Constrained Lasso. In this case, since  is feasible and b is optimal,
we have the inequality ky − Xbk22
 ky − Xk22
. Defining the error vector
b := b − , substituting in the relation y = X +w, and performing some
298 THEORETICAL RESULTS FOR THE LASSO
algebra yields the basic inequality
kXbk22
2N 
wTXb
N
. (11.19)
Applying a version of H¨older’s inequality to the right-hand side yields the
upper bound 1
N |wTXb|  1
N kXTwk1 kbk1. As shown in Chapter 10, the inequality
kbk1  R = kk1 implies that b 2 C(S; 1), whence we have
kbk1 = kbSk1 + kbSck1  2kbSk1  2pkkbk2.
On the other hand, applying the restricted eigenvalue condition (11.10) to
the left-hand side of the inequality (11.19) yields 1
N kXbk22
 
kbk22
. Putting
together the pieces yields the claimed bound (11.14a).
Lagrangian Lasso. Define the function
G() := 1
2N ky − X( + )k22
+ Nk + k1. (11.20)
Noting that b := b −  minimizes G by construction, we have G(b)  G(0).
Some algebra yields the modified basic inequality
kXbk22
2N 
wTXb
N
+ N

kk1 − k + bk1
	
. (11.21)
Now since Sc = 0, we have kk1 = kS k1, and
k + bk1 = k
S + bSk1 + kbSck1  k
S k1 − kbSk1 + kbSck1.
Substituting these relations into inequality (11.21) yields
kXbk22
2N 
wTXb
N
+ N

kbSk1 − kbSck1
	
 kXTwk1
N kbk1 + N

kbSk1 − kbSck1
	
, (11.22)
where the second step follows by applying H¨older’s inequality with `1 and `1
norms. Since 1
N kXTwk1  N2 by assumption, we have
kXbk22
2N 
N
2

kbSk1 + kbSck1
	
+ N

kbSk1 − kbSck1
	

3
2
pkNkbk2,
(11.23)
where the final step uses the fact that kbSk1  pkkbk2.
In order to complete the proof, we require the following auxiliary result:
Lemma 11.1. Suppose that N  2 kXTw
N k1 > 0. Then the error b := b−
associated with any lasso solution b belongs to the cone set C(S; 3).
BOUNDS ON PREDICTION ERROR 299
Taking this claim as given for the moment, let us complete the proof of the
bound (11.14b). Lemma 11.1 allows us to apply the 
-RE condition (11.10)
to b, which ensures that 1
N kXbk22
 
kbk22
. Combining this lower bound with
our earlier inequality (11.23) yields


2 kbk22

32
Npk kbk2,
and rearranging yields the bound (11.14b).
It remains to prove Lemma 11.1. Since kXTwk1
N  N2 , inequality (11.22)
implies that
0 
N
2 kbk1 + N

kbSk1 − kbSck1
	
,
Rearranging and then dividing out by N > 0 yields that kbSck1  3kbSk1 as
claimed.
Some extensions. As stated, Theorem 11.1 applies to regression models in
which  has at most k nonzero entries, an assumption that we referred to as
hard sparsity. However, a similar type of analysis can be performed for weakly
sparse models, say with  belonging to the `q-ball Bq(Rq) previously defined
in Equation (11.7). Under a similar set of assumptions, it can be shown that
the lasso error will satisfy the bound
kb − k22
 c Rq

2 log p
N
1−q/2
(11.24)
with high probability. We work through portions of this derivation in Exercise
11.3. In the special case q = 0, assuming that  belongs to the `0 ball is
equivalent to the assumption of hard sparsity (with radius R0 = k), so that
this rate (11.24) is equivalent to our previous result (11.16) derived as a consequence
of Theorem 11.1. Otherwise, note that the rate slows down as the
weak sparsity parameter q increases away from zero toward one, reflecting the
fact that we are imposing weaker conditions on the true regression vector .
The rate (11.24) is known to be minimax-optimal over the `q-ball, meaning
that no other estimator can achieve a substantially smaller `2-error; see the
bibliographic section for further discussion.
11.3 Bounds on Prediction Error
Thus far, we have studied the performance of the lasso in recovering the
true regression vector, as assessed by the Euclidean error kb − k2. In other
settings, it may suffice to obtain an estimate b that has a relatively low (insample)
prediction error Lpred(b, ) = 1
N kX(b − )k22
. In this section, we
develop some theoretical guarantees on this form of loss. For concreteness,
we focus on the Lagrangian lasso (11.3), although analogous results can be
derived for other forms of the lasso.
300 THEORETICAL RESULTS FOR THE LASSO
Theorem 11.2. Consider the Lagrangian lasso with a regularization parameter
N  2
N kXTwk1.
(a) If kk1  R1, then any optimal solution b satisfies
kX(b − )k22
N  12R1 N. (11.25a)
(b) If  is supported on a subset S, and the design matrix X satisfies the

-RE condition (11.10) over C(S; 3), then any optimal solution b satisfies
kX(b − )k22
N 
9

 |S| 2
N. (11.25b)
As we have discussed, for various statistical models, the choice N = c 
q
log p
N
is valid for Theorem 11.2 with high probability, so the two bounds take the
form
kX(b − )k22
N  c1  R1
r
log p
N
, and (11.26a)
kX(b − )k22
N  c2
2


|S| log p
N
. (11.26b)
The bound (11.26a), which depends on the `1-ball radius R1, is known as the
“slow rate” for the lasso, since the squared prediction error decays as 1/pN.
On the other hand, the bound (11.26b) is known as the “fast rate,” since it
decays as 1/N. Note that the latter is based on much stronger assumptions:
namely, the hard sparsity condition that  is supported on a small subset
S, and more disconcertingly, the 
-RE condition on the design matrix X. In
principle, prediction performance should not require an RE condition, so that
one might suspect that this requirement is an artifact of our proof technique.
Remarkably, as we discuss in the bibliographic section, this dependence turns
out to be unavoidable for any polynomial-time method.
Proof of Theorem 11.2: The proofs of both claims are relatively straightforward
given our development thus far.
Proof of bound (11.25a): Beginning with the modified basic inequality
(11.21), we have
0  kXTwk1
N kbk1 + N

kk1 − k + bk1
	

kXTwk1
N − N
	
kbk1 + 2Nkk1
(i)

1
2N
n
− kbk1 + 4kk1
o
,
SUPPORT RECOVERY IN LINEAR REGRESSION 301
where step (i) uses the fact that 1
N kXTwk1  N2 by assumption. Putting
together the pieces, we conclude that kbk1  4kk1  4R1. Returning again
to the modified basic inequality (11.21), we have
kXbk22
2N 
n
kXTwk1
N
+ N
o
kbk1  6NR1,
which establishes the claim (11.25a).
Proof of bound (11.25b): Given the stated choice of N, inequality (11.23)
holds, whence
kXbk22
2N  3pkNkbk22
.
By Lemma 11.1, the error vector b belongs to the cone C(S; 3), so that the

-RE condition guarantees that kbk22
 1
N 
 kXbk22
. Putting together the pieces
yields the claim (11.25b).
11.4 Support Recovery in Linear Regression
Thus far, we have focused on bounds on either the `2-error or the prediction
error associated with a lasso solution. In other settings, we are interested in
a somewhat more refined question, namely whether or not a lasso estimate
b has nonzero entries in the same positions as the true regression vector .
More precisely, suppose that the true regression vector  is k-sparse, meaning
that it is supported on a subset S = S() of cardinality k = |S|. In such a
setting, a natural goal is to correctly identify the subset S of relevant variables.
In terms of the lasso, we ask the following question: given an optimal lasso
solution b, when is its support set—denoted by bS = S(b)—exactly equal to
the true support S? We refer to this property as variable selection consistency
or sparsistency.
Note that it is possible for the `2 error kb−k2 to be quite small even if b
and  have different supports, as long as b is nonzero for all “suitably large”
entries of , and not “too large” in positions where  is zero. Similarly, it
is possible for the prediction error kX(b − )k2/pN to be small even when
b and  have very different supports. On the other hand, as we discuss in
the sequel, given an estimate b that correctly recovers the support of , we
can estimate  very well—both in `2-norm and the prediction semi-norm—
simply by performing an ordinary least-squares regression restricted to this
subset.
11.4.1 Variable-Selection Consistency for the Lasso
We begin by addressing the issue of variable selection in the context of deterministic
design matrices X. It turns out that variable selection requires a condition
related to but distinct from the restricted eigenvalue condition (11.10).
302 THEORETICAL RESULTS FOR THE LASSO
In particular, we assume a condition known either as mutual incoherence or
irrepresentability: there must exist some 
 > 0 such that
max
j2Sc k(XT
SXS)−1XT
Sxjk1  1 − 
. (11.27)
To interpret this condition, note that the submatrix XS 2 RN×k corresponds
to the subset of covariates that are in the support set. For each index j in
the complementary set Sc, the k-vector (XT
SXS)−1XT
Sxj is the regression
coefficient of xj on XS; this vector is a measure of how well the column xj
aligns with the columns of the submatrix XS. In the most desirable case, the
columns {xj , j 2 Sc} would all be orthogonal to the columns of XS, and we
would be guaranteed that 
 = 1. Of course, in the high-dimensional setting
(p  N), this complete orthogonality is not possible, but we can still hope
for a type of “near orthogonality” to hold.
In addition to this incoherence condition, we also assume that the design
matrix has normalized columns
max
j=1,...,p kxjk2/pN  Kclm. (11.28)
For example, we can take kxjk2 = pN and Kclm = 1. Further we assume that
the submatrix XS is well-behaved in the sense that
min(XT
SXS/N)  Cmin. (11.29)
Note that if this condition were violated, then the columns of XS would be
linearly dependent, and it would be impossible to estimate  even in the
“oracle case” when the support set S were known.
The following result applies to the regularized lasso (11.3) when applied to
an instance the linear observation model (11.1) such that the true parameter
 has support size k.
Theorem 11.3. Suppose that the design matrix X satisfies the mutual incoherence
condition (11.27) with parameter 
 > 0, and the column normalization
condition (11.28) and the eigenvalue condition (11.29) both hold. For a noise
vector w 2 RN with i.i.d. N(0, 2) entries, consider the regularized lasso program
(11.3) with
N 
8Kclm 


r
log p
N
. (11.30)
Then with probability greater than 1−c1e−c2N2
N , the lasso has the following
properties:
(a) Uniqueness: The optimal solution b is unique.
(b) No false inclusion: The unique optimal solution has its support S(b)
contained within the true support S().
SUPPORT RECOVERY IN LINEAR REGRESSION 303
(c) `1-bounds: The error b −  satisfies the `1 bound
kbS − 
S k1  N
 4
pCmin
+



(XT
SXS/N)−1


1

| {z }
B(N,;X)
, (11.31)
where for a matrix A, its 1-norm is given by kAk1 = maxkuk1=1 kAuk1.
(d) No false exclusion: The lasso solution includes all indices j 2 S() such
that |
j | > B(N, ;X), and hence is variable selection consistent as long
as min
j2S |
j | > B(N, ;X).
Before proving this result, let us try to interpret its main claims. First,
the uniqueness claim in part (a) is not trivial in the high-dimensional setting,
because as discussed previously, although the lasso objective is convex, it can
never be strictly convex when p > N. The uniqueness claim is important,
because it allows us to talk unambiguously about the support of the lasso
estimate b. Part (b) guarantees that the lasso does not falsely include variables
that are not in the support of , or equivalently that bSc = 0, whereas part
(c) guarantees that bS is uniformly close to S in the `1-norm. Finally, part
(d) is a consequence of this uniform norm bound: as long as the minimum value
of |
j | over indices j 2 S is not too small, then the lasso is variable-selection
consistent in the full sense.
11.4.1.1 Some Numerical Studies
In order to learn more about the impact of these results in practice, we ran a
few small simulation studies.We first explore the impact of the irrepresentability
condition (11.27). We fixed the sample size to N = 1000, and for a range of
problem dimensions p, we generated p i.i.d standard Gaussian variates, with
a fraction f = k/p of them being in the support set S. For correlations 
ranging over the interval [0, 0.6], for each j 2 S we randomly chose a predictor
` 2 Sc, and set x`   x` + c · xj with c chosen so that corr(xj , x`) = .
Figure 11.5 shows the average value of 1−
, the value of the irrepresentability
condition (11.27), over five realizations. We see for example with  = 0, we
fall into the “good” region 1 − 
 < 1 when p  1000 and there is f  2%
sparsity or p  500 with f  5% sparsity. However the maximum size of p
and sparsity level f decrease as the correlation  increases.
We also ran a small simulation study to examine the false discovery and
false exclusion rates for a lasso regression. We set N = 1000 and p = 500 with
k = 15 predictors in S having nonzero coefficients. The data matrices XS and
XSc were generated as above, with different values for the correlations . We
then generated a response y according to y = XSS + w, with the elements
of w i.i.d. N(0, 1).
We tried two different values for the nonzero regression coefficients in S:
all 0.25 or all 0.15, with randomly selected signs. These result in “effect sizes”
304 THEORETICAL RESULTS FOR THE LASSO
50 100 200 500 1000 2000
0.05 0.20 0.50 2.00 5.00
Number of Variables p
Maximum Inner Product 1 − g
r = 0
f = 0.02
f = 0.05
f = 0.1
f = 0.2
50 100 200 500 1000 2000
0.05 0.20 0.50 2.00 5.00
Number of Variables p
Maximum Inner Product 1 − g
r = 0.2
50 100 200 500 1000 2000
0.05 0.20 0.50 2.00 5.00
Number of Variables p
Maximum Inner Product 1 − g
r = 0.4
50 100 200 500 1000 2000
0.05 0.20 0.50 2.00 5.00
Number of Variables p
Maximum Inner Product 1 − g
r = 0.6
Figure 11.5 Irrepresentability condition in practice. Each plot shows values for
1−
 in (11.27) for simulated Gaussian data. Values less than one are good, and the
smaller the better. The sample size N = 1000 is fixed, and the number of predictors
p varies along the horizontal axis. The fraction f = k/p of true nonzero coefficients
(the sparsity level) varies within each panel, and finally, the correlation between each
true predictor and its null predictor partner (as described in the text) varies across
the four panels. A horizontal broken line is drawn at 1 − 
 = 1, below which the
irrepresentability condition holds. Each point is a mean of 1−
 over five simulations;
the standard errors of the means are small, averaging about 0.03.
SUPPORT RECOVERY IN LINEAR REGRESSION 305
(absolute standardized regression coefficients) for the 15 true predictors of 7.9
and 4.7, respectively. Finally, we chose N in an “optimal” way in each run:
we used the value yielding the correct number of nonzero coefficients (15).
The top row of Figure 11.6 shows the results. In the top left panel (the
best case), the average false discovery and false exclusion probabilities are zero
until  is greater than about 0.6. After that point, the lasso starts to include
false variables and exclude good ones, due to the high correlation between
signal and noise variables. The value 
 from the irrepresentability condition
is also shown, and drops below zero at around the value  = 0.6. (Hence
the condition holds below correlation 0.6.) In the top right panel, we see error
rates increase overall, even for small . Here the effect size is modestly reduced
from 7.9 to 4.7, which is the cause of the increase.
The lower panel of Figure 11.6 shows the results when the sample size
N is reduced to 200 (p < N) and the size k of the support set is increased
to 25. The values used for the nonzero regression coefficients were 5.0 and
0.5, yielding effect sizes of about 71 and 7, respectively. The irrepresentability
condition and other assumptions of the theorem do not hold. Now the error
rates are 15% or more irrespective of , and recovery of the true support set
seems unrealistic in this scenario.
11.4.2 Proof of Theorem 11.3
We begin by developing the necessary and sufficient conditions for optimality
in the lasso. A minor complication arises because the `1-norm is not differentiable,
due to its sharp point at the origin. Instead, we need to work in terms
of the subdifferential of the `1-norm. Here we provide a very brief introduction;
see Chapter 5 for further details. Given a convex function f : Rp ! R,
we say that z 2 Rp is a subgradient at , denoted by z 2 @f(), if we have
f( + )  f() + hz, i for all  2 Rp.
When f() = kk1, it can be seen that z 2 @kk1 if and only if zj = sign(j)
for all j = 1, 2, . . . , p, where we allow sign(0) to be any number in the interval
[−1, 1]. In application to the lasso program, we say that a pair (b, bz) 2 Rp×Rp
is primal-dual optimal if b is a minimizer and bz 2 @kbk1. Any such pair must
satisfy the zero-subgradient condition
−
1
N
XT (y − Xb) + Nbz = 0, (11.32)
which is the analogue of a zero gradient condition in this nondifferentiable
setting.
Our proof of Theorem 11.3 is based on a constructive procedure, known
as a primal-dual witness method (PDW). When this procedure succeeds, it
constructs a pair (b, bz) 2 Rp × Rp that are primal-dual optimal, and act as
a witness for the fact that the lasso has a unique optimal solution with the
306 THEORETICAL RESULTS FOR THE LASSO
0.0 0.2 0.4 0.6 0.8 1.0
0.0 0.2 0.4 0.6 0.8 1.0
Proportion
False Discovery Rate
False Exclusion Rate
g
0.0 0.2 0.4 0.6 0.8 1.0
0.0 0.2 0.4 0.6 0.8 1.0
Proportion
N=1000
0.0 0.2 0.4 0.6 0.8 1.0
0.0 0.2 0.4 0.6 0.8 1.0
Proportion
0.0 0.2 0.4 0.6 0.8 1.0
0.0 0.2 0.4 0.6 0.8 1.0
Proportion
N=200
 
 
Effect Size=7.9, k = 15 Effect Size=4.7, k = 15
Effect Size=70.7, k = 25 Effect Size=7.1, k = 25
Figure 11.6 Average false discovery and exclusion rates (with ± one standard error)
from simulation experiments with p = 500 variables. In the top row N = 1000,
and the size of S is k = 15. In the second row N = 200 and the subset size is
k = 25. The effect size is the strength of real coefficients, as measured by an absolute
Z statistic. Overall conclusion: when 
 is favorable, and the signal is strong, recovery
is good (top left). All other situations are problematic.
SUPPORT RECOVERY IN LINEAR REGRESSION 307
correct signed support. Using S = supp() to denote the support set of ,
this procedure consists of the following steps:
Primal-dual witness (PDW) construction.
1. Set bSc = 0.
2. Determine (bS, bzS) by solving the k-dimensional oracle subproblem
bS 2 arg min
S2Rk
 1
2N ky − XSSk22
+ NkSk1

. (11.33)
Thus bzS is an element of subdifferential @kbSk1 satisfying the relation
1
NXT
S (y − XS bS) + NbzS = 0.
3. Solve for bzSc via the zero-subgradient Equation (11.32), and check whether
or not the strict dual feasibility condition kbzSck1 < 1 holds.
To be clear, this procedure is not an implementable method for actually
solving the lasso program (since it pre-supposes knowledge of the true
support); rather, it is a proof technique for certifying variable-selection consistency
of the lasso. Note that the subvector bSc is determined in step 1,
whereas the remaining three subvectors are determined in steps 2 and 3. By
construction, the subvectors bS, bzS and bzSc satisfy the zero-subgradient condition
(11.32). We say that the PDW construction succeeds if the vector bzSc
constructed in step 3 satisfies the strict dual feasibility condition. The following
result shows that this success acts as a witness for the lasso:
Lemma 11.2. If the PDW construction succeeds, then under the lower eigenvalue
condition (11.29), the vector (bS, 0) 2 Rp is the unique optimal solution
of the regularized lasso (11.3).
Proof: When the PDW construction succeeds, then b = (bS, 0) is an optimal
solution with associated subgradient vector bz 2 Rp satisfying kbzSck1 < 1,
and hbz, bi = kbk1. Now let e 2 Rp be any other optimal solution of the lasso.
If we introduce the shorthand notation F() = 1
2N ky − Xk22
, then we are
guaranteed that F(b) + Nhbz, bi = F(e) + Nkek1, and hence
F(b) − Nhbz, e − bi = F(e) + N
􀀀
kek1 − hbz, ei

.
But by the zero-subgradient conditions for optimality (11.32), we have
Nbz = −rF(b), which implies that
F(b) + hrF(b), e − bi − F(e) = N
􀀀
kek1 − hbz, ei

.
By convexity of F, the left-hand side is negative, so that we must have
kek1  hbz, ei. Applying H¨older’s inequality with the `1 and `1 norms yields
the upper bound hbz, ei  kbzk1kek1. These two inequalities together imply
308 THEORETICAL RESULTS FOR THE LASSO
that kek1 = hbz, ei. Since kbzSck1 < 1, this equality can occur only if ej = 0
for all j 2 Sc.
Thus, all optimal solutions are supported only on S, and hence can be
obtained by solving the oracle subproblem (11.33). Given the lower eigenvalue
bound (11.29), this subproblem is strictly convex, and so has a unique
minimizer.
Based on Lemma 11.2, in order to prove parts (a) and (b) of Theorem 11.3,
it suffices to show that the subvector bzSc constructed in step 3 satisfies the
strict dual feasibility condition kbzSck1 < 1.
Establishing strict dual feasibility. Let us delve into the form of the subvector
bzSc constructed in step 3. By using the fact that bSc = S c = 0 and writing
out the zero-subgradient condition (11.32) in block matrix form, we obtain
1
N

XT
SXS XT
SXSc
XT
ScXS XT
ScXSc
 bS − S 0

−
1
N

XT
Sw
XT
Scw

+ N

bzS
bzSc

=

00

.
(11.34)
Solving for the vector bzSc 2 Rp−k yields
bzSc = 1
N
XT
Scw
N −
XT
ScXS
N
􀀀bS − 
S

. (11.35)
Similarly, using the assumed invertibility of XT
SXS in order to solve for the
difference bS − S yields
bS − 
S =
XT
SXS
N
−1 XT
Sw
N − N
XT
SXS
N
−1
sign(
S )
| {z }
US
. (11.36)
Substituting this expression back into Equation (11.35) and simplifying yields
bzSc = XT
ScXS(XT
SXS)−1 sign(
S )
| {z }
μ
+XT
Sc

I − XS(XT
SXS)−1XT
S
 w
N N

| {z }
VSc
.
By triangle inequality, we have
kbzSck1  kμk1 + kVSck1.
Note that the vector μ 2 Rp−k is a deterministic quantity, and moreover,
by the mutual incoherence condition (11.27), we have kμk1  1 − 
. The
remaining quantity VSc 2 Rp−k is a zero-mean Gaussian random vector, and
we need to show that kVSck1 < 
 with high probability.
SUPPORT RECOVERY IN LINEAR REGRESSION 309
For an arbitrary j 2 Sc, consider the random variable
Vj := XTj

I − XS(XT
SXS)−1XT
S

| {z }
S?(X)
 w
N N

.
Noting that the matrix S?(X) is an orthogonal projection matrix and using
the column normalization condition (11.28), we see that each Vj is zero-mean
with variance at most 2K2
clm/(2
NN). Therefore, combining Gaussian tail
bounds with the union bound, we find that
P

kVSck1  
/2

 2 (p − k) e
−
2
N
N(
/2)2
22K2
clm .
This probability vanishes at rate 2e−22
NN for the choice of N given in the
theorem statement.
Establishing `1 bounds. Next we establish a bound on the `1-norm of the
difference vector US = bS − S from Equation (11.36). By the triangle inequality,
we have
kUSk1 






XT
SXS
N
−1 XT
Sw
N






1
+






XT
SXS
N
−1





1
N, (11.37)
where we have multiplied and divided different terms by N for later convenience.
The second term is a deterministic quantity, so that it remains to
bound the first term. For each i = 1, . . . , k, consider the random variable
Zi := eTi
 1
N
XT
SXS
−1 1
N
XT
Sw.
Since the elements of w are i.i.d. N(0, 2) variables, the variable Zi is zeromean
Gaussian with variance at most
2
N






 1
N
XT
SXS
−1






2

2
CminN
,
where we have used the eigenvalue condition (11.29). Therefore, again combining
Gaussian tail bounds with the union bound, we find that
P[kUSk1 > t]  2e−t2CminN
22 +log k.
Let us set t = 4N/pCmin and then observe that our choice of N guarantees
that 8N2
N > log p  log k. Putting together these pieces, we conclude that
kUSk1  4N/pCmin with probability at least 1 − 2e−c22
NN. Overall, we
conclude that
kbS − 
S k1  N
 4
pCmin
+



(XT
SXS/N)−1


1

,
with probability greater than 1 − 2e−c22
NN, as claimed.
310 THEORETICAL RESULTS FOR THE LASSO
11.5 Beyond the Basic Lasso
In this chapter, we have limited ourselves to discussion of the basic lasso,
which involves the least-squares loss function combined with the `1-norm as a
regularizer. However, many of the ingredients have straightforward extensions
to more general cost functions, including logistic regression and other types
of generalized linear models, as well as to more exotic forms of regularization,
including the group lasso, nuclear norm, and other types of structured
regularizers. Here we sketch out the basic picture, referring the reader to the
bibliographic section for links to further details.
Consider an objective function of the form
F() = 1
N
XN
i=1
f(; zi), (11.38)
where the function  7! g(; zi) measures the fit of the parameter vector
 2 Rp to the sample zi. In the context of regression problems, each sample
takes the form zi = (xi, yi) 2 Rp×R, whereas in problems such as the graphical
lasso, each sample corresponds to a vector zi = xi 2 Rp. Letting  : Rp ! R
denote a regularizer, we then consider an estimator of the form
b 2 arg min
2
 {F() + N()} . (11.39)
We can view b as an estimate of the deterministic vector  that minimizes
the population objective function ¯ F() := E[f(;Z)].
To put our previous discussion in context, the familiar lasso is a special
case of this general M-estimator, based on the choices
f(; xi, yi) = 12
􀀀
yi − hxi, i
2
, and () = kk1,
and with the optimization taking place over 
 = Rp. In the case of random
design, say with covariates xi  N(0,), the population objective function
for linear regression takes the form ¯ F() = 1
2 ( − )T( − ) + 12
2.
Considering the general M-estimator (11.39), our goal here is to provide
some intuition on how to analyze the error kb −k2. When N < p, then the
objective function (11.38) can never be strongly convex: indeed, assuming that
it is twice differentiable, the Hessian is a sum of N matrices in p dimensions,
and so must be rank degenerate. As noted previously, the restricted eigenvalue
condition is a special case of a more general property of cost functions and
regularizers, known as restricted strong convexity. In particular, given a set
aCtRipf, tahedrieffeerxeinsttisaablpeafruanmcteitoenr F
 >sa0tissfiuecshrtehsatrticted strong convexity over C
F( + ) − F() − hrF(), i  
kk22
for all  2 C. (11.40)
When F is twice differentiable, then this lower bound is equivalent to controlling
the Hessian in a neighborhood of , as in the definition (11.9)—see
BIBLIOGRAPHIC NOTES 311
Exercise 11.6 for details. Thus, in the special case of a least-squares problem,
restricted strong convexity is equivalent to a restricted eigenvalue condition.
For what type of sets C can a condition of this form be expected to hold?
Since our ultimate goal is to control the error vector b = b − , we need
only ensure that strong convexity hold over a subset C that is guaranteed—
typically with high probability over the data—to contain the error vector.
Such sets exist for regularizers that satisfy a property known as decomposability,
which generalizes a basic property of the `1-norm to a broader family
of regularizers. Decomposability is defined in terms of a subspace M of the
parameter set 
, meant to describe the structure expected in the optimum
, and its orthogonal complementM?, corresponding to undesirable perturbations
away from the model structure. With this notation, a regularizer  is
said to be decomposable with respect to M if
( + ) = () + () for all pairs (, ) 2M×M?. (11.41)
In the case of the `1-norm, the model subspace is simply the set of all vectors
with support on some fixed set S, whereas the orthogonal complement M?
consists of vectors supported on the complementary set Sc. The decomposability
relation (11.41) follows from the coordinate-wise nature of the `1-norm.
With appropriate choices of subspaces, many other regularizers are decomposable,
including weighted forms of the lasso, the group lasso and overlap
group lasso penalties, and (with a minor generalization) the nuclear norm for
low-rank matrices. See the bibliographic section for further details.
Bibliographic Notes
Knight and Fu (2000) derive asymptotic theory for the lasso and related estimators
when the dimension p is fixed; the irrepresentable condition (11.27)
appears implicitly in their analysis. Greenshtein and Ritov (2004) were the
first authors to provide a high-dimensional analysis of the lasso, in particular
providing bounds on the prediction error allowing for the p  N setting.
The irrepresentable or mutual incoherence condition (11.27) was developed
independently by Fuchs (2004) and Tropp (2006) in signal processing, and
Meinshausen and B¨uhlmann (2006) as well as Zhao and Yu (2006) in statistics.
The notion of restricted eigenvalues was introduced by Bickel, Ritov and
Tsybakov (2009); it is a less restrictive condition than the restricted isometry
property from Chapter 10. van de Geer and B¨uhlmann (2009) provide a
comparison between these and other related conditions for proving estimation
error bounds on the lasso. Cand`es and Tao (2007) defined and developed theory
for the “Dantzig selector”, a problem closely related to the lasso. Raskutti,
Wainwright and Yu (2010) show that the RE condition holds with high probability
for various types of random Gaussian design matrices; see Rudelson
and Zhou (2013) for extensions to sub-Gaussian designs.
The proof of Theorem 11.1 is based on the work of Bickel et al. (2009),
312 THEORETICAL RESULTS FOR THE LASSO
whereas Negahban et al. (2012) derive the lasso error bound (11.24) for `q-
sparse vectors. The basic inequality technique used in these proofs is standard
in the analysis of M-estimators (van de Geer 2000). Raskutti, Wainwright and
Yu (2011) analyze the minimax rates of regression over `q-balls, obtaining rates
for both `2-error and prediction error. Theorem 11.2(a) was proved by Bunea,
Tsybakov andWegkamp (2007), whereas part (b) is due to Bickel et al. (2009).
The restricted eigenvalue condition is actually required by any polynomialtime
method in order to achieve the “fast rates” given in Theorem 11.2(b),
as follows from the results of Zhang, Wainwright and Jordan (2014). Under
a standard assumption in complexity theory, they prove that no polynomialtime
algorithm can achieve the fast rate without imposing an RE condition.
Theorem 11.3 and the primal-dual witness (PDW) proof is due to Wainwright
(2009). In the same paper, sharp threshold results are established for
Gaussian ensembles of design matrices, in particular concrete upper and lower
bounds on the sample size that govern the transition from success to failure
in support recovery. The proof of Lemma 11.2 was suggested by Caramanis
(2010). The PDW method has been applied to a range of other problems,
including analysis of group lasso (Obozinski et al. 2011, Wang, Liang
and Xing 2013) and related relaxations (Jalali, Ravikumar, Sanghavi and
Ruan 2010, Negahban and Wainwright 2011b), graphical lasso (Ravikumar
et al. 2011), and methods for Gaussian graph selection with hidden variables
(Chandrasekaran et al. 2012). Lee, Sun and Taylor (2013) provide a
general formulation of the PDW method for a broader class of M-estimators.
As noted in Section 11.5, the analysis in this chapter can be extended to
a much broader class of M-estimators, namely those based on decomposable
regularizers. Negahban et al. (2012) provide a general framework for analyzing
the estimation error kb −k2 for such M-estimators. As alluded to here, the
two key ingredients are restricted strong convexity of the cost function, and
decomposability of the regularizer.
Exercises
Ex. 11.1 For a given q 2 (0, 1], recall the set Bq(Rq) defined in Equation (11.7)
as a model of soft sparsity.
(a) A related object is the weak `q-ball with parameters (C, ), given by
Bw()(C) :=

 2 Rp | ||(j)  Cj− for j = 1, . . . , p
	
. (11.42a)
Here ||(j) denote the order statistics of  in absolute value, ordered from
largest to smallest (so that ||(1) = max
j=1,2,...,p |j | and ||(p) = min
j=1,2,...,p |j |.)
For any  > 1/q, show that there is a radius Rq depending on (C, ) such
that Bw()(C)  Bq(Rq).
(b) For a given integer k 2 {1, 2, . . . , p}, the best k-term approximation to a
EXERCISES 313
vector  2 Rp is given by
k() := arg min
kk0k k − k22
. (11.42b)
Give a closed form expression for k().
(c) When  2 Bq(Rq) for some q 2 (0, 1], show that the best k-term approximation
satisfies
kk() − k22

􀀀
Rq
2/q 􀀀 1
k
 2
q−1
. (11.42c)
Ex. 11.2 In this exercise, we analyze an alternative version of the lasso, namely
the estimator
b = arg min
2Rp kk1 such that 1
N ky − Xk22
 C, (11.43)
where the constant C > 0 is a parameter to be chosen by the user. (This form
of the lasso is often referred to as relaxed basis pursuit.)
(a) Suppose that C is chosen such that  is feasible for the convex program.
Show that the error vector b = b −  must satisfy the cone constraint
kbSck1  kbSk1.
(b) Assuming the linear observation model y = X+w, show that b satisfies
the basic inequality
kXbk22
N  2kXTwk1
N kbk1 +

C − kwk22
N

.
(c) Assuming a 
-RE condition on X, use part (b) to establish a bound on
the `2-error kb − k2.
Ex. 11.3 In this exercise, we sketch out the proof of the bound (11.24).
In particular, we show that if N  kXTwk1
N and  2 Bq(Rq), then the
Lagrangian lasso error satisfies a bound of the form
kb − k22
 c Rq 
1−q/2
N . (11.44a)
(a) Generalize Lemma 11.1 by showing that the error vector b satisfies the
“cone-like” constraint
kbSck1  3kbSk1 + k
Sck1, (11.44b)
valid for any subset S  {1, 2, . . . , p} and its complement.
(b) Suppose that X satisfies a 
-RE condition over all vectors satisfying the
cone-like condition (11.44b). Prove that
kbk22
 N

4kbSk1 + k
S ck1
	
.
again valid for any subset S of indices.
(c) Optimize the choice of S so as to obtain the claimed bound (11.44a).
314 THEORETICAL RESULTS FOR THE LASSO
Ex. 11.4 Consider a random design matrix X 2 RN×p with each row xi 2 Rp
drawn i.i.d. from a N(0,) distribution, where the covariance matrix  is
strictly positive definite. Show that a 
-RE condition holds over the set C(S; )
with high probability whenever the sample size is lower bounded as N >
c |S|2 log p for a sufficiently large constant c. (Remark: This scaling of the
sample size is not optimal; a more refined argument can be used to reduce
|S|2 to |S|.)
Ex. 11.5 Consider a random design matrix X 2 RN×p with i.i.d. N(0, 1) entries.
In this exercise, we show that the mutual incoherence condition (11.27)
holds with high probability as long as N > ck log p for a sufficiently large
numerical constant c. (Hint: For N > 4k, it is known that the event
E = {min
􀀀XT
SXS
N

 14
} holds with high probability.)
(a) Show that

 = 1 − max
j2Sc
max
z2{−1,+1}k
xT
j XS(XT
SXS)−1z
| {z }
Vj,z
.
(b) Recalling the event E, show that there is a numerical constant c0 > 0
such that
P

Vj,z  t

 e−c0 Nt2
k + P[Ec] for any t > 0,
valid for each fixed index j 2 Sc and vector z 2 {−1, +1}k.
(c) Use part (b) to complete the proof.
Ex. 11.6 Consider a twice differentiable function F : Rp ! R and a set C  Rp
such that
r2F()
kk22
 
kk22
for all  2 C,
uniformly for all  in a neighborhood of some fixed parameter . Show that
the RSC condition (11.40) holds.
